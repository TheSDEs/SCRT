{
    "swagger": "2.0",
    "info": {
        "title": "Secret Network REST",
        "version": "1.0",
        "description": "A REST interface for state queries, transaction generation and broadcasting.\n\nCurrently load balances multiple backends"
    },
    "host": "keplr-gateway.scrtlabs.com",
    "basePath": "/lcd",
    "schemes": [
        "https"
    ],
    "securityDefinitions": {
        "apiKeyHeader": {
            "type": "apiKey",
            "name": "Ocp-Apim-Subscription-Key",
            "in": "header"
        },
        "apiKeyQuery": {
            "type": "apiKey",
            "name": "subscription-key",
            "in": "query"
        }
    },
    "security": [
        {
            "apiKeyHeader": []
        },
        {
            "apiKeyQuery": []
        }
    ],
    "paths": {
        "/gov/parameters/tallying": {
            "get": {
                "description": "Query governance tally parameters",
                "operationId": "get-gov-parameters-tallying",
                "summary": "Query governance tally parameters",
                "tags": [
                    "Governance"
                ],
                "produces": [
                    "application/json"
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object"
                        },
                        "examples": {
                            "application/json": {}
                        }
                    },
                    "400": {
                        "description": "<other_path> is not a valid query request path"
                    },
                    "404": {
                        "description": "Found no tally parameters"
                    },
                    "500": {
                        "description": "Internal Server Error"
                    }
                }
            }
        },
        "/distribution/validators/{validatorAddr}/rewards": {
            "post": {
                "description": "Withdraw the validator's self-delegation and commissions rewards",
                "operationId": "post-distribution-validators-validatoraddr-rewards",
                "summary": "Withdraw the validator's rewards",
                "tags": [
                    "Distribution"
                ],
                "parameters": [
                    {
                        "name": "validatorAddr",
                        "in": "path",
                        "description": "Bech32 OperatorAddress of validator",
                        "required": true,
                        "type": "string"
                    },
                    {
                        "name": "distributionValidators-validatorAddr-RewardsPostRequest-1",
                        "in": "body",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "base_req": {
                                    "type": "object",
                                    "properties": {
                                        "from": {
                                            "description": "Sender address or Keybase name to generate a transaction",
                                            "type": "string",
                                            "example": "cosmos1g9ahr6xhht5rmqven628nklxluzyv8z9jqjcmc"
                                        },
                                        "memo": {
                                            "type": "string",
                                            "example": "Sent via Cosmos Voyager ðŸš€"
                                        },
                                        "chain_id": {
                                            "type": "string",
                                            "example": "Cosmos-Hub"
                                        },
                                        "account_number": {
                                            "type": "string",
                                            "example": "0"
                                        },
                                        "sequence": {
                                            "type": "string",
                                            "example": "1"
                                        },
                                        "gas": {
                                            "type": "string",
                                            "example": "200000"
                                        },
                                        "gas_adjustment": {
                                            "type": "string",
                                            "example": "1.2"
                                        },
                                        "fees": {
                                            "type": "array",
                                            "items": {
                                                "type": "object",
                                                "properties": {
                                                    "denom": {
                                                        "type": "string",
                                                        "example": "stake"
                                                    },
                                                    "amount": {
                                                        "type": "string",
                                                        "example": "50"
                                                    }
                                                }
                                            }
                                        },
                                        "simulate": {
                                            "description": "Estimate gas for a transaction (cannot be used in conjunction with generate_only)",
                                            "type": "boolean",
                                            "example": false
                                        }
                                    }
                                }
                            },
                            "example": {
                                "base_req": {
                                    "from": "cosmos1g9ahr6xhht5rmqven628nklxluzyv8z9jqjcmc",
                                    "memo": "Sent via Cosmos Voyager ðŸš€",
                                    "chain_id": "Cosmos-Hub",
                                    "account_number": "0",
                                    "sequence": "1",
                                    "gas": "200000",
                                    "gas_adjustment": "2022-01-02",
                                    "fees": [
                                        {
                                            "denom": "stake",
                                            "amount": "50"
                                        }
                                    ],
                                    "simulate": false
                                }
                            }
                        }
                    }
                ],
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "msg": {
                                    "type": "array",
                                    "items": {
                                        "type": "string"
                                    }
                                },
                                "fee": {
                                    "type": "object",
                                    "properties": {
                                        "gas": {
                                            "type": "string"
                                        },
                                        "amount": {
                                            "type": "array",
                                            "items": {
                                                "type": "object",
                                                "properties": {
                                                    "denom": {
                                                        "type": "string",
                                                        "example": "stake"
                                                    },
                                                    "amount": {
                                                        "type": "string",
                                                        "example": "50"
                                                    }
                                                }
                                            }
                                        }
                                    }
                                },
                                "memo": {
                                    "type": "string"
                                },
                                "signature": {
                                    "type": "object",
                                    "properties": {
                                        "signature": {
                                            "type": "string",
                                            "example": "MEUCIQD02fsDPra8MtbRsyB1w7bqTM55Wu138zQbFcWx4+CFyAIge5WNPfKIuvzBZ69MyqHsqD8S1IwiEp+iUb6VSdtlpgY="
                                        },
                                        "pub_key": {
                                            "type": "object",
                                            "properties": {
                                                "type": {
                                                    "type": "string",
                                                    "example": "tendermint/PubKeySecp256k1"
                                                },
                                                "value": {
                                                    "type": "string",
                                                    "example": "Avz04VhtKJh8ACCVzlI8aTosGy0ikFXKIVHQ3jKMrosH"
                                                }
                                            }
                                        },
                                        "account_number": {
                                            "type": "string",
                                            "example": "0"
                                        },
                                        "sequence": {
                                            "type": "string",
                                            "example": "0"
                                        }
                                    }
                                }
                            }
                        },
                        "examples": {
                            "application/json": {
                                "msg": [
                                    "string"
                                ],
                                "fee": {
                                    "gas": "string",
                                    "amount": [
                                        {
                                            "denom": "stake",
                                            "amount": "50"
                                        }
                                    ]
                                },
                                "memo": "string",
                                "signature": {
                                    "signature": "MEUCIQD02fsDPra8MtbRsyB1w7bqTM55Wu138zQbFcWx4+CFyAIge5WNPfKIuvzBZ69MyqHsqD8S1IwiEp+iUb6VSdtlpgY=",
                                    "pub_key": {
                                        "type": "tendermint/PubKeySecp256k1",
                                        "value": "Avz04VhtKJh8ACCVzlI8aTosGy0ikFXKIVHQ3jKMrosH"
                                    },
                                    "account_number": "0",
                                    "sequence": "0"
                                }
                            }
                        }
                    },
                    "400": {
                        "description": "Invalid validator address"
                    },
                    "401": {
                        "description": "Key password is wrong"
                    },
                    "500": {
                        "description": "Internal Server Error"
                    }
                }
            },
            "get": {
                "description": "Query the commission and self-delegation rewards of validator.",
                "operationId": "get-distribution-validators-validatoraddr-rewards",
                "summary": "Commission and self-delegation rewards of a single validator",
                "tags": [
                    "Distribution"
                ],
                "parameters": [
                    {
                        "name": "validatorAddr",
                        "in": "path",
                        "description": "Bech32 OperatorAddress of validator",
                        "required": true,
                        "type": "string"
                    }
                ],
                "produces": [
                    "application/json"
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "type": "object",
                                "properties": {
                                    "denom": {
                                        "type": "string",
                                        "example": "stake"
                                    },
                                    "amount": {
                                        "type": "string",
                                        "example": "50"
                                    }
                                }
                            }
                        },
                        "examples": {
                            "application/json": [
                                {
                                    "denom": "stake",
                                    "amount": "50"
                                }
                            ]
                        }
                    },
                    "400": {
                        "description": "Invalid validator address"
                    },
                    "500": {
                        "description": "Internal Server Error"
                    }
                }
            }
        },
        "/distribution/community_pool": {
            "get": {
                "description": "Community pool parameters",
                "operationId": "get-distribution-community_pool",
                "summary": "Community pool parameters",
                "tags": [
                    "Distribution"
                ],
                "produces": [
                    "application/json"
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "type": "object",
                                "properties": {
                                    "denom": {
                                        "type": "string",
                                        "example": "stake"
                                    },
                                    "amount": {
                                        "type": "string",
                                        "example": "50"
                                    }
                                }
                            }
                        },
                        "examples": {
                            "application/json": [
                                {
                                    "denom": "stake",
                                    "amount": "50"
                                }
                            ]
                        }
                    },
                    "500": {
                        "description": "Internal Server Error"
                    }
                }
            }
        },
        "/txs": {
            "post": {
                "description": "Broadcast a signed tx to a full node",
                "operationId": "post-txs",
                "summary": "Broadcast a signed tx",
                "tags": [
                    "Transactions"
                ],
                "parameters": [
                    {
                        "name": "txsPostRequest",
                        "in": "body",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "tx": {
                                    "type": "object",
                                    "properties": {
                                        "msg": {
                                            "type": "array",
                                            "items": {
                                                "type": "string"
                                            }
                                        },
                                        "fee": {
                                            "type": "object",
                                            "properties": {
                                                "gas": {
                                                    "type": "string"
                                                },
                                                "amount": {
                                                    "type": "array",
                                                    "items": {
                                                        "type": "object",
                                                        "properties": {
                                                            "denom": {
                                                                "type": "string",
                                                                "example": "stake"
                                                            },
                                                            "amount": {
                                                                "type": "string",
                                                                "example": "50"
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        },
                                        "memo": {
                                            "type": "string"
                                        },
                                        "signature": {
                                            "type": "object",
                                            "properties": {
                                                "signature": {
                                                    "type": "string",
                                                    "example": "MEUCIQD02fsDPra8MtbRsyB1w7bqTM55Wu138zQbFcWx4+CFyAIge5WNPfKIuvzBZ69MyqHsqD8S1IwiEp+iUb6VSdtlpgY="
                                                },
                                                "pub_key": {
                                                    "type": "object",
                                                    "properties": {
                                                        "type": {
                                                            "type": "string",
                                                            "example": "tendermint/PubKeySecp256k1"
                                                        },
                                                        "value": {
                                                            "type": "string",
                                                            "example": "Avz04VhtKJh8ACCVzlI8aTosGy0ikFXKIVHQ3jKMrosH"
                                                        }
                                                    }
                                                },
                                                "account_number": {
                                                    "type": "string",
                                                    "example": "0"
                                                },
                                                "sequence": {
                                                    "type": "string",
                                                    "example": "0"
                                                }
                                            }
                                        }
                                    }
                                },
                                "mode": {
                                    "type": "string",
                                    "example": "block"
                                },
                                "sequences": {
                                    "type": "array",
                                    "items": {
                                        "type": "string",
                                        "example": "1"
                                    }
                                },
                                "fee_granter": {
                                    "description": "bech32 encoded address",
                                    "type": "string",
                                    "example": "secret11wg2mlrxdmnnkkykgqg4znky86nyrtc45q336yv"
                                }
                            },
                            "example": {
                                "tx": {
                                    "msg": [
                                        "string"
                                    ],
                                    "fee": {
                                        "gas": "string",
                                        "amount": [
                                            {
                                                "denom": "stake",
                                                "amount": "50"
                                            }
                                        ]
                                    },
                                    "memo": "string",
                                    "signature": {
                                        "signature": "MEUCIQD02fsDPra8MtbRsyB1w7bqTM55Wu138zQbFcWx4+CFyAIge5WNPfKIuvzBZ69MyqHsqD8S1IwiEp+iUb6VSdtlpgY=",
                                        "pub_key": {
                                            "type": "tendermint/PubKeySecp256k1",
                                            "value": "Avz04VhtKJh8ACCVzlI8aTosGy0ikFXKIVHQ3jKMrosH"
                                        },
                                        "account_number": "0",
                                        "sequence": "0"
                                    }
                                },
                                "mode": "block",
                                "sequences": [
                                    "1"
                                ],
                                "fee_granter": "secret11wg2mlrxdmnnkkykgqg4znky86nyrtc45q336yv"
                            }
                        },
                        "description": "The tx must be a signed StdTx. The supported broadcast modes include `\"block\"`(return after tx commit), `\"sync\"`(return afer CheckTx) and `\"async\"`(return right away)."
                    }
                ],
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "responses": {
                    "200": {
                        "description": "Tx broadcasting result",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "check_tx": {
                                    "type": "object",
                                    "properties": {
                                        "code": {
                                            "type": "integer"
                                        },
                                        "data": {
                                            "type": "string"
                                        },
                                        "gas_used": {
                                            "type": "integer"
                                        },
                                        "gas_wanted": {
                                            "type": "integer"
                                        },
                                        "info": {
                                            "type": "string"
                                        },
                                        "log": {
                                            "type": "string"
                                        },
                                        "tags": {
                                            "type": "array",
                                            "items": {
                                                "type": "object",
                                                "properties": {
                                                    "key": {
                                                        "type": "string"
                                                    },
                                                    "value": {
                                                        "type": "string"
                                                    }
                                                }
                                            }
                                        }
                                    },
                                    "example": {
                                        "code": 0,
                                        "data": "data",
                                        "log": "log",
                                        "gas_used": 5000,
                                        "gas_wanted": 10000,
                                        "info": "info",
                                        "tags": [
                                            "",
                                            ""
                                        ]
                                    }
                                },
                                "deliver_tx": {
                                    "type": "object",
                                    "properties": {
                                        "code": {
                                            "type": "integer"
                                        },
                                        "data": {
                                            "type": "string"
                                        },
                                        "gas_used": {
                                            "type": "integer"
                                        },
                                        "gas_wanted": {
                                            "type": "integer"
                                        },
                                        "info": {
                                            "type": "string"
                                        },
                                        "log": {
                                            "type": "string"
                                        },
                                        "tags": {
                                            "type": "array",
                                            "items": {
                                                "type": "object",
                                                "properties": {
                                                    "key": {
                                                        "type": "string"
                                                    },
                                                    "value": {
                                                        "type": "string"
                                                    }
                                                }
                                            }
                                        }
                                    },
                                    "example": {
                                        "code": 5,
                                        "data": "data",
                                        "log": "log",
                                        "gas_used": 5000,
                                        "gas_wanted": 10000,
                                        "info": "info",
                                        "tags": [
                                            "",
                                            ""
                                        ]
                                    }
                                },
                                "hash": {
                                    "type": "string",
                                    "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                                },
                                "height": {
                                    "type": "integer"
                                }
                            }
                        },
                        "examples": {
                            "application/json": {
                                "check_tx": {
                                    "code": 0,
                                    "data": "data",
                                    "log": "log",
                                    "gas_used": 5000,
                                    "gas_wanted": 10000,
                                    "info": "info",
                                    "tags": [
                                        "",
                                        ""
                                    ]
                                },
                                "deliver_tx": {
                                    "code": 5,
                                    "data": "data",
                                    "log": "log",
                                    "gas_used": 5000,
                                    "gas_wanted": 10000,
                                    "info": "info",
                                    "tags": [
                                        "",
                                        ""
                                    ]
                                },
                                "hash": "EE5F3404034C524501629B56E0DDC38FAD651F04",
                                "height": 0
                            }
                        }
                    },
                    "500": {
                        "description": "Internal Server Error"
                    }
                }
            },
            "get": {
                "description": "Search transactions by events.",
                "operationId": "get-txs",
                "summary": "Search transactions",
                "tags": [
                    "Transactions"
                ],
                "parameters": [
                    {
                        "name": "message.action",
                        "in": "query",
                        "description": "transaction events such as 'message.action=send' which results in the following endpoint: 'GET /txs?message.action=send'. note that each module documents its own events. look for xx_events.md in the corresponding cosmos-sdk/docs/spec directory",
                        "type": "string"
                    },
                    {
                        "name": "message.sender",
                        "in": "query",
                        "description": "transaction tags with sender: 'GET /txs?message.action=send&message.sender=cosmos16xyempempp92x9hyzz9wrgf94r6j9h5f06pxxv'",
                        "type": "string"
                    },
                    {
                        "name": "page",
                        "in": "query",
                        "description": "Page number",
                        "type": "integer"
                    },
                    {
                        "name": "limit",
                        "in": "query",
                        "description": "Maximum number of items per page",
                        "type": "integer"
                    },
                    {
                        "name": "tx.minheight",
                        "in": "query",
                        "description": "transactions on blocks with height greater or equal this value",
                        "type": "integer"
                    },
                    {
                        "name": "tx.maxheight",
                        "in": "query",
                        "description": "transactions on blocks with height less than or equal this value",
                        "type": "integer"
                    }
                ],
                "produces": [
                    "application/json"
                ],
                "responses": {
                    "200": {
                        "description": "All txs matching the provided events",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "total_count": {
                                    "type": "number",
                                    "example": 1
                                },
                                "count": {
                                    "type": "number",
                                    "example": 1
                                },
                                "page_number": {
                                    "type": "number",
                                    "example": 1
                                },
                                "page_total": {
                                    "type": "number",
                                    "example": 1
                                },
                                "limit": {
                                    "type": "number",
                                    "example": 30
                                },
                                "txs": {
                                    "type": "array",
                                    "items": {
                                        "type": "object",
                                        "properties": {
                                            "hash": {
                                                "type": "string",
                                                "example": "D085138D913993919295FF4B0A9107F1F2CDE0D37A87CE0644E217CBF3B49656"
                                            },
                                            "height": {
                                                "type": "number",
                                                "example": 368
                                            },
                                            "tx": {
                                                "type": "object",
                                                "properties": {
                                                    "msg": {
                                                        "type": "array",
                                                        "items": {
                                                            "type": "string"
                                                        }
                                                    },
                                                    "fee": {
                                                        "type": "object",
                                                        "properties": {
                                                            "gas": {
                                                                "type": "string"
                                                            },
                                                            "amount": {
                                                                "type": "array",
                                                                "items": {
                                                                    "type": "object",
                                                                    "properties": {
                                                                        "denom": {
                                                                            "type": "string",
                                                                            "example": "stake"
                                                                        },
                                                                        "amount": {
                                                                            "type": "string",
                                                                            "example": "50"
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    },
                                                    "memo": {
                                                        "type": "string"
                                                    },
                                                    "signature": {
                                                        "type": "object",
                                                        "properties": {
                                                            "signature": {
                                                                "type": "string",
                                                                "example": "MEUCIQD02fsDPra8MtbRsyB1w7bqTM55Wu138zQbFcWx4+CFyAIge5WNPfKIuvzBZ69MyqHsqD8S1IwiEp+iUb6VSdtlpgY="
                                                            },
                                                            "pub_key": {
                                                                "type": "object",
                                                                "properties": {
                                                                    "type": {
                                                                        "type": "string",
                                                                        "example": "tendermint/PubKeySecp256k1"
                                                                    },
                                                                    "value": {
                                                                        "type": "string",
                                                                        "example": "Avz04VhtKJh8ACCVzlI8aTosGy0ikFXKIVHQ3jKMrosH"
                                                                    }
                                                                }
                                                            },
                                                            "account_number": {
                                                                "type": "string",
                                                                "example": "0"
                                                            },
                                                            "sequence": {
                                                                "type": "string",
                                                                "example": "0"
                                                            }
                                                        }
                                                    }
                                                }
                                            },
                                            "result": {
                                                "type": "object",
                                                "properties": {
                                                    "log": {
                                                        "type": "string"
                                                    },
                                                    "gas_wanted": {
                                                        "type": "string",
                                                        "example": "200000"
                                                    },
                                                    "gas_used": {
                                                        "type": "string",
                                                        "example": "26354"
                                                    },
                                                    "tags": {
                                                        "type": "array",
                                                        "items": {
                                                            "type": "object",
                                                            "properties": {
                                                                "key": {
                                                                    "type": "string"
                                                                },
                                                                "value": {
                                                                    "type": "string"
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        },
                        "examples": {
                            "application/json": {
                                "total_count": 1,
                                "count": 1,
                                "page_number": 1,
                                "page_total": 1,
                                "limit": 30,
                                "txs": [
                                    {
                                        "hash": "D085138D913993919295FF4B0A9107F1F2CDE0D37A87CE0644E217CBF3B49656",
                                        "height": 368,
                                        "tx": {
                                            "msg": [
                                                "string"
                                            ],
                                            "fee": {
                                                "gas": "string",
                                                "amount": [
                                                    {
                                                        "denom": "stake",
                                                        "amount": "50"
                                                    }
                                                ]
                                            },
                                            "memo": "string",
                                            "signature": {
                                                "signature": "MEUCIQD02fsDPra8MtbRsyB1w7bqTM55Wu138zQbFcWx4+CFyAIge5WNPfKIuvzBZ69MyqHsqD8S1IwiEp+iUb6VSdtlpgY=",
                                                "pub_key": {
                                                    "type": "tendermint/PubKeySecp256k1",
                                                    "value": "Avz04VhtKJh8ACCVzlI8aTosGy0ikFXKIVHQ3jKMrosH"
                                                },
                                                "account_number": "0",
                                                "sequence": "0"
                                            }
                                        },
                                        "result": {
                                            "log": "string",
                                            "gas_wanted": "200000",
                                            "gas_used": "26354",
                                            "tags": [
                                                {
                                                    "key": "string",
                                                    "value": "string"
                                                }
                                            ]
                                        }
                                    }
                                ]
                            }
                        }
                    },
                    "400": {
                        "description": "Invalid search events"
                    },
                    "500": {
                        "description": "Internal Server Error"
                    }
                }
            }
        },
        "/wasm/code/{codeID}/hash": {
            "get": {
                "description": "Get code ID data hash",
                "operationId": "get-wasm-code-codeid-hash",
                "summary": "Get code ID data hash",
                "tags": [
                    "Wasm"
                ],
                "parameters": [
                    {
                        "name": "codeID",
                        "in": "path",
                        "description": "code ID you want to query",
                        "required": true,
                        "type": "number"
                    }
                ],
                "produces": [
                    "application/json"
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "height": {
                                    "type": "string"
                                },
                                "result": {
                                    "type": "object",
                                    "properties": {
                                        "height": {
                                            "type": "string"
                                        },
                                        "result": {
                                            "type": "string"
                                        }
                                    }
                                }
                            }
                        },
                        "examples": {
                            "application/json": {
                                "height": "string",
                                "result": {
                                    "height": "string",
                                    "result": "string"
                                }
                            }
                        }
                    },
                    "404": {
                        "description": "Not Found"
                    }
                }
            }
        },
        "/gov/proposals/{proposalId}/proposer": {
            "get": {
                "description": "Query for the proposer for a proposal",
                "operationId": "get-gov-proposals-proposalid-proposer",
                "summary": "Query proposer",
                "tags": [
                    "Governance"
                ],
                "parameters": [
                    {
                        "name": "proposalId",
                        "in": "path",
                        "required": true,
                        "type": "string"
                    }
                ],
                "produces": [
                    "application/json"
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "proposal_id": {
                                    "type": "string"
                                },
                                "proposer": {
                                    "type": "string"
                                }
                            }
                        },
                        "examples": {
                            "application/json": {
                                "proposal_id": "string",
                                "proposer": "string"
                            }
                        }
                    },
                    "400": {
                        "description": "Invalid proposal ID"
                    },
                    "500": {
                        "description": "Internal Server Error"
                    }
                }
            }
        },
        "/wasm/contract/{contractAddress}/query/{query}": {
            "get": {
                "description": "Get stored information with store key",
                "operationId": "get-wasm-contract-contractaddress-query-query",
                "summary": "Get stored information with store key",
                "tags": [
                    "Wasm"
                ],
                "parameters": [
                    {
                        "name": "contractAddress",
                        "in": "path",
                        "description": "contract address you want to lookup",
                        "required": true,
                        "type": "string"
                    },
                    {
                        "name": "query",
                        "in": "path",
                        "description": "hex encoded data for the query",
                        "required": true,
                        "type": "string"
                    },
                    {
                        "name": "encoding",
                        "in": "query",
                        "description": "encoding of the query data (only hex supported)",
                        "type": "string"
                    }
                ],
                "produces": [
                    "application/json"
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "height": {
                                    "type": "string"
                                },
                                "result": {
                                    "type": "object",
                                    "properties": {
                                        "key": {
                                            "type": "string"
                                        },
                                        "value": {
                                            "type": "string"
                                        }
                                    }
                                }
                            }
                        },
                        "examples": {
                            "application/json": {
                                "height": "string",
                                "result": {
                                    "key": "string",
                                    "value": "string"
                                }
                            }
                        }
                    }
                }
            }
        },
        "/wasm/code/{codeID}": {
            "get": {
                "description": "Get code info of the code ID",
                "operationId": "get-wasm-code-codeid",
                "summary": "Get code info of the code ID",
                "tags": [
                    "Wasm"
                ],
                "parameters": [
                    {
                        "name": "codeID",
                        "in": "path",
                        "description": "code ID you want to query",
                        "required": true,
                        "type": "number"
                    }
                ],
                "produces": [
                    "application/json"
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "height": {
                                    "type": "string"
                                },
                                "result": {
                                    "type": "object",
                                    "properties": {
                                        "code_hash": {
                                            "type": "string"
                                        },
                                        "creator": {
                                            "type": "string"
                                        }
                                    }
                                }
                            }
                        },
                        "examples": {
                            "application/json": {
                                "height": "string",
                                "result": {
                                    "code_hash": "string",
                                    "creator": "string"
                                }
                            }
                        }
                    }
                }
            },
            "post": {
                "description": "Instantiate wasm contract message",
                "operationId": "post-wasm-code-codeid",
                "summary": "Instantiate wasm contract message",
                "tags": [
                    "Wasm"
                ],
                "parameters": [
                    {
                        "name": "codeID",
                        "in": "path",
                        "description": "code ID you want to instantiate",
                        "required": true,
                        "type": "number"
                    },
                    {
                        "name": "wasmCode-codeID-PostRequest-1",
                        "in": "body",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "base_req": {
                                    "type": "object",
                                    "properties": {
                                        "from": {
                                            "description": "Sender address or Keybase name to generate a transaction",
                                            "type": "string",
                                            "example": "cosmos1g9ahr6xhht5rmqven628nklxluzyv8z9jqjcmc"
                                        },
                                        "memo": {
                                            "type": "string",
                                            "example": "Sent via Cosmos Voyager ðŸš€"
                                        },
                                        "chain_id": {
                                            "type": "string",
                                            "example": "Cosmos-Hub"
                                        },
                                        "account_number": {
                                            "type": "string",
                                            "example": "0"
                                        },
                                        "sequence": {
                                            "type": "string",
                                            "example": "1"
                                        },
                                        "gas": {
                                            "type": "string",
                                            "example": "200000"
                                        },
                                        "gas_adjustment": {
                                            "type": "string",
                                            "example": "1.2"
                                        },
                                        "fees": {
                                            "type": "array",
                                            "items": {
                                                "type": "object",
                                                "properties": {
                                                    "denom": {
                                                        "type": "string",
                                                        "example": "stake"
                                                    },
                                                    "amount": {
                                                        "type": "string",
                                                        "example": "50"
                                                    }
                                                }
                                            }
                                        },
                                        "simulate": {
                                            "description": "Estimate gas for a transaction (cannot be used in conjunction with generate_only)",
                                            "type": "boolean",
                                            "example": false
                                        }
                                    }
                                },
                                "init_coins": {
                                    "type": "array",
                                    "items": {
                                        "type": "object",
                                        "properties": {
                                            "denom": {
                                                "type": "string",
                                                "example": "stake"
                                            },
                                            "amount": {
                                                "type": "string",
                                                "example": "50"
                                            }
                                        }
                                    }
                                },
                                "init_msg": {
                                    "description": "json formatted string",
                                    "type": "string",
                                    "example": "{}"
                                }
                            }
                        }
                    }
                ],
                "consumes": [
                    "*/*"
                ],
                "produces": [
                    "application/json"
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "msg": {
                                    "type": "array",
                                    "items": {
                                        "type": "string"
                                    }
                                },
                                "fee": {
                                    "type": "object",
                                    "properties": {
                                        "gas": {
                                            "type": "string"
                                        },
                                        "amount": {
                                            "type": "array",
                                            "items": {
                                                "type": "object",
                                                "properties": {
                                                    "denom": {
                                                        "type": "string",
                                                        "example": "stake"
                                                    },
                                                    "amount": {
                                                        "type": "string",
                                                        "example": "50"
                                                    }
                                                }
                                            }
                                        }
                                    }
                                },
                                "memo": {
                                    "type": "string"
                                },
                                "signature": {
                                    "type": "object",
                                    "properties": {
                                        "signature": {
                                            "type": "string",
                                            "example": "MEUCIQD02fsDPra8MtbRsyB1w7bqTM55Wu138zQbFcWx4+CFyAIge5WNPfKIuvzBZ69MyqHsqD8S1IwiEp+iUb6VSdtlpgY="
                                        },
                                        "pub_key": {
                                            "type": "object",
                                            "properties": {
                                                "type": {
                                                    "type": "string",
                                                    "example": "tendermint/PubKeySecp256k1"
                                                },
                                                "value": {
                                                    "type": "string",
                                                    "example": "Avz04VhtKJh8ACCVzlI8aTosGy0ikFXKIVHQ3jKMrosH"
                                                }
                                            }
                                        },
                                        "account_number": {
                                            "type": "string",
                                            "example": "0"
                                        },
                                        "sequence": {
                                            "type": "string",
                                            "example": "0"
                                        }
                                    }
                                }
                            }
                        },
                        "examples": {
                            "application/json": {
                                "msg": [
                                    "string"
                                ],
                                "fee": {
                                    "gas": "string",
                                    "amount": [
                                        {
                                            "denom": "stake",
                                            "amount": "50"
                                        }
                                    ]
                                },
                                "memo": "string",
                                "signature": {
                                    "signature": "MEUCIQD02fsDPra8MtbRsyB1w7bqTM55Wu138zQbFcWx4+CFyAIge5WNPfKIuvzBZ69MyqHsqD8S1IwiEp+iUb6VSdtlpgY=",
                                    "pub_key": {
                                        "type": "tendermint/PubKeySecp256k1",
                                        "value": "Avz04VhtKJh8ACCVzlI8aTosGy0ikFXKIVHQ3jKMrosH"
                                    },
                                    "account_number": "0",
                                    "sequence": "0"
                                }
                            }
                        }
                    },
                    "400": {
                        "description": "Bad request"
                    },
                    "500": {
                        "description": "Internal Server Error"
                    }
                }
            }
        },
        "/gov/proposals/{proposalId}/tally": {
            "get": {
                "description": "Gets a proposal's tally result at the current time. If the proposal is pending deposits (i.e status 'DepositPeriod') it returns an empty tally result.",
                "operationId": "get-gov-proposals-proposalid-tally",
                "summary": "Get a proposal's tally result at the current time",
                "tags": [
                    "Governance"
                ],
                "parameters": [
                    {
                        "name": "proposalId",
                        "in": "path",
                        "description": "proposal id",
                        "required": true,
                        "type": "string"
                    }
                ],
                "produces": [
                    "application/json"
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "yes": {
                                    "type": "string",
                                    "example": "0.0000000000"
                                },
                                "abstain": {
                                    "type": "string",
                                    "example": "0.0000000000"
                                },
                                "no": {
                                    "type": "string",
                                    "example": "0.0000000000"
                                },
                                "no_with_veto": {
                                    "type": "string",
                                    "example": "0.0000000000"
                                }
                            }
                        },
                        "examples": {
                            "application/json": {
                                "yes": "0.0000000000",
                                "abstain": "0.0000000000",
                                "no": "0.0000000000",
                                "no_with_veto": "0.0000000000"
                            }
                        }
                    },
                    "400": {
                        "description": "Invalid proposal id"
                    },
                    "500": {
                        "description": "Internal Server Error"
                    }
                }
            }
        },
        "/staking/validators/{validatorAddr}": {
            "get": {
                "description": "Query the information from a single validator",
                "operationId": "get-staking-validators-validatoraddr",
                "summary": "Query the information from a single validator",
                "tags": [
                    "Staking"
                ],
                "parameters": [
                    {
                        "name": "validatorAddr",
                        "in": "path",
                        "description": "Bech32 OperatorAddress of validator",
                        "required": true,
                        "type": "string"
                    }
                ],
                "produces": [
                    "application/json"
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "operator_address": {
                                    "description": "bech32 encoded address",
                                    "type": "string",
                                    "example": "cosmosvaloper16xyempempp92x9hyzz9wrgf94r6j9h5f2w4n2l"
                                },
                                "consensus_pubkey": {
                                    "type": "string",
                                    "example": "cosmosvalconspub1zcjduepq0vu2zgkgk49efa0nqwzndanq5m4c7pa3u4apz4g2r9gspqg6g9cs3k9cuf"
                                },
                                "jailed": {
                                    "type": "boolean"
                                },
                                "status": {
                                    "type": "integer"
                                },
                                "tokens": {
                                    "type": "string"
                                },
                                "delegator_shares": {
                                    "type": "string"
                                },
                                "description": {
                                    "type": "object",
                                    "properties": {
                                        "moniker": {
                                            "type": "string"
                                        },
                                        "identity": {
                                            "type": "string"
                                        },
                                        "website": {
                                            "type": "string"
                                        },
                                        "security_contact": {
                                            "type": "string"
                                        },
                                        "details": {
                                            "type": "string"
                                        }
                                    }
                                },
                                "bond_height": {
                                    "type": "string",
                                    "example": "0"
                                },
                                "bond_intra_tx_counter": {
                                    "type": "integer",
                                    "example": 0
                                },
                                "unbonding_height": {
                                    "type": "string",
                                    "example": "0"
                                },
                                "unbonding_time": {
                                    "type": "string",
                                    "example": "1970-01-01T00:00:00Z"
                                },
                                "commission": {
                                    "type": "object",
                                    "properties": {
                                        "rate": {
                                            "type": "string",
                                            "example": "0"
                                        },
                                        "max_rate": {
                                            "type": "string",
                                            "example": "0"
                                        },
                                        "max_change_rate": {
                                            "type": "string",
                                            "example": "0"
                                        },
                                        "update_time": {
                                            "type": "string",
                                            "example": "1970-01-01T00:00:00Z"
                                        }
                                    }
                                }
                            }
                        },
                        "examples": {
                            "application/json": {
                                "operator_address": "cosmosvaloper16xyempempp92x9hyzz9wrgf94r6j9h5f2w4n2l",
                                "consensus_pubkey": "cosmosvalconspub1zcjduepq0vu2zgkgk49efa0nqwzndanq5m4c7pa3u4apz4g2r9gspqg6g9cs3k9cuf",
                                "jailed": true,
                                "status": 0,
                                "tokens": "string",
                                "delegator_shares": "string",
                                "description": {
                                    "moniker": "string",
                                    "identity": "string",
                                    "website": "string",
                                    "security_contact": "string",
                                    "details": "string"
                                },
                                "bond_height": "0",
                                "bond_intra_tx_counter": 0,
                                "unbonding_height": "0",
                                "unbonding_time": "1970-01-01T00:00:00+00:00",
                                "commission": {
                                    "rate": "0",
                                    "max_rate": "0",
                                    "max_change_rate": "0",
                                    "update_time": "1970-01-01T00:00:00+00:00"
                                }
                            }
                        }
                    },
                    "400": {
                        "description": "Invalid validator address"
                    },
                    "500": {
                        "description": "Internal Server Error"
                    }
                }
            }
        },
        "/node_info": {
            "get": {
                "description": "Information about the connected node",
                "operationId": "get-node_info",
                "summary": "The properties of the connected node",
                "tags": [
                    "Gaia REST"
                ],
                "produces": [
                    "application/json"
                ],
                "responses": {
                    "200": {
                        "description": "Node status",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "application_version": {
                                    "type": "object",
                                    "properties": {
                                        "build_tags": {
                                            "type": "string"
                                        },
                                        "client_name": {
                                            "type": "string"
                                        },
                                        "commit": {
                                            "type": "string"
                                        },
                                        "go": {
                                            "type": "string"
                                        },
                                        "name": {
                                            "type": "string"
                                        },
                                        "server_name": {
                                            "type": "string"
                                        },
                                        "version": {
                                            "type": "string"
                                        }
                                    }
                                },
                                "node_info": {
                                    "type": "object",
                                    "properties": {
                                        "id": {
                                            "type": "string"
                                        },
                                        "moniker": {
                                            "type": "string",
                                            "example": "validator-name"
                                        },
                                        "protocol_version": {
                                            "type": "object",
                                            "properties": {
                                                "p2p": {
                                                    "type": "string",
                                                    "example": "7"
                                                },
                                                "block": {
                                                    "type": "string",
                                                    "example": "10"
                                                },
                                                "app": {
                                                    "type": "string",
                                                    "example": "0"
                                                }
                                            }
                                        },
                                        "network": {
                                            "type": "string",
                                            "example": "gaia-2"
                                        },
                                        "channels": {
                                            "type": "string"
                                        },
                                        "listen_addr": {
                                            "type": "string",
                                            "example": "192.168.56.1:26656"
                                        },
                                        "version": {
                                            "description": "Tendermint version",
                                            "type": "string",
                                            "example": "0.15.0"
                                        },
                                        "other": {
                                            "description": "more information on versions",
                                            "type": "object",
                                            "properties": {
                                                "tx_index": {
                                                    "type": "string",
                                                    "example": "on"
                                                },
                                                "rpc_address": {
                                                    "type": "string",
                                                    "example": "tcp://0.0.0.0:26657"
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        },
                        "examples": {
                            "application/json": {
                                "application_version": {
                                    "build_tags": "string",
                                    "client_name": "string",
                                    "commit": "string",
                                    "go": "string",
                                    "name": "string",
                                    "server_name": "string",
                                    "version": "string"
                                },
                                "node_info": {
                                    "id": "string",
                                    "moniker": "validator-name",
                                    "protocol_version": {
                                        "p2p": "7",
                                        "block": "10",
                                        "app": "0"
                                    },
                                    "network": "gaia-2",
                                    "channels": "string",
                                    "listen_addr": "192.168.56.1:26656",
                                    "version": "0.15.0",
                                    "other": {
                                        "tx_index": "on",
                                        "rpc_address": "tcp://0.0.0.0:26657"
                                    }
                                }
                            }
                        }
                    },
                    "500": {
                        "description": "Failed to query node status"
                    }
                }
            }
        },
        "/syncing": {
            "get": {
                "description": "Get if the node is currently syning with other nodes",
                "operationId": "get-syncing",
                "summary": "Syncing state of node",
                "tags": [
                    "Tendermint RPC"
                ],
                "produces": [
                    "application/json"
                ],
                "responses": {
                    "200": {
                        "description": "Node syncing status",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "syncing": {
                                    "type": "boolean"
                                }
                            }
                        },
                        "examples": {
                            "application/json": {
                                "syncing": true
                            }
                        }
                    },
                    "500": {
                        "description": "Server internal error"
                    }
                }
            }
        },
        "/blocks/latest": {
            "get": {
                "description": "Get the latest block",
                "operationId": "get-blocks-latest",
                "summary": "Get the latest block",
                "tags": [
                    "Tendermint RPC"
                ],
                "produces": [
                    "application/json"
                ],
                "responses": {
                    "200": {
                        "description": "The latest block",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "block_meta": {
                                    "type": "object",
                                    "properties": {
                                        "header": {
                                            "type": "object",
                                            "properties": {
                                                "chain_id": {
                                                    "type": "string",
                                                    "example": "cosmoshub-2"
                                                },
                                                "height": {
                                                    "type": "number",
                                                    "example": 1
                                                },
                                                "time": {
                                                    "type": "string",
                                                    "example": "2017-12-30T04:53:09.287Z"
                                                },
                                                "num_txs": {
                                                    "type": "number",
                                                    "example": 0
                                                },
                                                "last_block_id": {
                                                    "type": "object",
                                                    "properties": {
                                                        "hash": {
                                                            "type": "string",
                                                            "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                                                        },
                                                        "parts": {
                                                            "type": "object",
                                                            "properties": {
                                                                "total": {
                                                                    "type": "number",
                                                                    "example": 0
                                                                },
                                                                "hash": {
                                                                    "type": "string",
                                                                    "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                                                                }
                                                            }
                                                        }
                                                    }
                                                },
                                                "total_txs": {
                                                    "type": "number",
                                                    "example": 35
                                                },
                                                "last_commit_hash": {
                                                    "type": "string",
                                                    "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                                                },
                                                "data_hash": {
                                                    "type": "string",
                                                    "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                                                },
                                                "validators_hash": {
                                                    "type": "string",
                                                    "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                                                },
                                                "next_validators_hash": {
                                                    "type": "string",
                                                    "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                                                },
                                                "consensus_hash": {
                                                    "type": "string",
                                                    "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                                                },
                                                "app_hash": {
                                                    "type": "string",
                                                    "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                                                },
                                                "last_results_hash": {
                                                    "type": "string",
                                                    "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                                                },
                                                "evidence_hash": {
                                                    "type": "string",
                                                    "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                                                },
                                                "proposer_address": {
                                                    "description": "bech32 encoded address",
                                                    "type": "string",
                                                    "example": "cosmos1depk54cuajgkzea6zpgkq36tnjwdzv4afc3d27"
                                                },
                                                "version": {
                                                    "type": "object",
                                                    "properties": {
                                                        "block": {
                                                            "type": "string",
                                                            "example": "10"
                                                        },
                                                        "app": {
                                                            "type": "string",
                                                            "example": "0"
                                                        }
                                                    }
                                                }
                                            }
                                        },
                                        "block_id": {
                                            "type": "object",
                                            "properties": {
                                                "hash": {
                                                    "type": "string",
                                                    "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                                                },
                                                "parts": {
                                                    "type": "object",
                                                    "properties": {
                                                        "total": {
                                                            "type": "number",
                                                            "example": 0
                                                        },
                                                        "hash": {
                                                            "type": "string",
                                                            "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                },
                                "block": {
                                    "type": "object",
                                    "properties": {
                                        "header": {
                                            "type": "object",
                                            "properties": {
                                                "chain_id": {
                                                    "type": "string",
                                                    "example": "cosmoshub-2"
                                                },
                                                "height": {
                                                    "type": "number",
                                                    "example": 1
                                                },
                                                "time": {
                                                    "type": "string",
                                                    "example": "2017-12-30T04:53:09.287Z"
                                                },
                                                "num_txs": {
                                                    "type": "number",
                                                    "example": 0
                                                },
                                                "last_block_id": {
                                                    "type": "object",
                                                    "properties": {
                                                        "hash": {
                                                            "type": "string",
                                                            "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                                                        },
                                                        "parts": {
                                                            "type": "object",
                                                            "properties": {
                                                                "total": {
                                                                    "type": "number",
                                                                    "example": 0
                                                                },
                                                                "hash": {
                                                                    "type": "string",
                                                                    "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                                                                }
                                                            }
                                                        }
                                                    }
                                                },
                                                "total_txs": {
                                                    "type": "number",
                                                    "example": 35
                                                },
                                                "last_commit_hash": {
                                                    "type": "string",
                                                    "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                                                },
                                                "data_hash": {
                                                    "type": "string",
                                                    "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                                                },
                                                "validators_hash": {
                                                    "type": "string",
                                                    "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                                                },
                                                "next_validators_hash": {
                                                    "type": "string",
                                                    "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                                                },
                                                "consensus_hash": {
                                                    "type": "string",
                                                    "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                                                },
                                                "app_hash": {
                                                    "type": "string",
                                                    "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                                                },
                                                "last_results_hash": {
                                                    "type": "string",
                                                    "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                                                },
                                                "evidence_hash": {
                                                    "type": "string",
                                                    "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                                                },
                                                "proposer_address": {
                                                    "description": "bech32 encoded address",
                                                    "type": "string",
                                                    "example": "cosmos1depk54cuajgkzea6zpgkq36tnjwdzv4afc3d27"
                                                },
                                                "version": {
                                                    "type": "object",
                                                    "properties": {
                                                        "block": {
                                                            "type": "string",
                                                            "example": "10"
                                                        },
                                                        "app": {
                                                            "type": "string",
                                                            "example": "0"
                                                        }
                                                    }
                                                }
                                            }
                                        },
                                        "txs": {
                                            "type": "array",
                                            "items": {
                                                "type": "string"
                                            }
                                        },
                                        "evidence": {
                                            "type": "array",
                                            "items": {
                                                "type": "string"
                                            }
                                        },
                                        "last_commit": {
                                            "type": "object",
                                            "properties": {
                                                "block_id": {
                                                    "type": "object",
                                                    "properties": {
                                                        "hash": {
                                                            "type": "string",
                                                            "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                                                        },
                                                        "parts": {
                                                            "type": "object",
                                                            "properties": {
                                                                "total": {
                                                                    "type": "number",
                                                                    "example": 0
                                                                },
                                                                "hash": {
                                                                    "type": "string",
                                                                    "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                                                                }
                                                            }
                                                        }
                                                    }
                                                },
                                                "precommits": {
                                                    "type": "array",
                                                    "items": {
                                                        "type": "object",
                                                        "properties": {
                                                            "validator_address": {
                                                                "type": "string"
                                                            },
                                                            "validator_index": {
                                                                "type": "string",
                                                                "example": "0"
                                                            },
                                                            "height": {
                                                                "type": "string",
                                                                "example": "0"
                                                            },
                                                            "round": {
                                                                "type": "string",
                                                                "example": "0"
                                                            },
                                                            "timestamp": {
                                                                "type": "string",
                                                                "example": "2017-12-30T04:53:09.287Z"
                                                            },
                                                            "type": {
                                                                "type": "number",
                                                                "example": 2
                                                            },
                                                            "block_id": {
                                                                "type": "object",
                                                                "properties": {
                                                                    "hash": {
                                                                        "type": "string",
                                                                        "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                                                                    },
                                                                    "parts": {
                                                                        "type": "object",
                                                                        "properties": {
                                                                            "total": {
                                                                                "type": "number",
                                                                                "example": 0
                                                                            },
                                                                            "hash": {
                                                                                "type": "string",
                                                                                "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            },
                                                            "signature": {
                                                                "type": "string",
                                                                "example": "7uTC74QlknqYWEwg7Vn6M8Om7FuZ0EO4bjvuj6rwH1mTUJrRuMMZvAAqT9VjNgP0RA/TDp6u/92AqrZfXJSpBQ=="
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        },
                        "examples": {
                            "application/json": {
                                "block_meta": {
                                    "header": {
                                        "chain_id": "cosmoshub-2",
                                        "height": 1,
                                        "time": "2017-12-30T04:53:09.287+00:00",
                                        "num_txs": 0,
                                        "last_block_id": {
                                            "hash": "EE5F3404034C524501629B56E0DDC38FAD651F04",
                                            "parts": {
                                                "total": 0,
                                                "hash": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                                            }
                                        },
                                        "total_txs": 35,
                                        "last_commit_hash": "EE5F3404034C524501629B56E0DDC38FAD651F04",
                                        "data_hash": "EE5F3404034C524501629B56E0DDC38FAD651F04",
                                        "validators_hash": "EE5F3404034C524501629B56E0DDC38FAD651F04",
                                        "next_validators_hash": "EE5F3404034C524501629B56E0DDC38FAD651F04",
                                        "consensus_hash": "EE5F3404034C524501629B56E0DDC38FAD651F04",
                                        "app_hash": "EE5F3404034C524501629B56E0DDC38FAD651F04",
                                        "last_results_hash": "EE5F3404034C524501629B56E0DDC38FAD651F04",
                                        "evidence_hash": "EE5F3404034C524501629B56E0DDC38FAD651F04",
                                        "proposer_address": "cosmos1depk54cuajgkzea6zpgkq36tnjwdzv4afc3d27",
                                        "version": {
                                            "block": "10",
                                            "app": "0"
                                        }
                                    },
                                    "block_id": {
                                        "hash": "EE5F3404034C524501629B56E0DDC38FAD651F04",
                                        "parts": {
                                            "total": 0,
                                            "hash": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                                        }
                                    }
                                },
                                "block": {
                                    "header": {
                                        "chain_id": "cosmoshub-2",
                                        "height": 1,
                                        "time": "2017-12-30T04:53:09.287+00:00",
                                        "num_txs": 0,
                                        "last_block_id": {
                                            "hash": "EE5F3404034C524501629B56E0DDC38FAD651F04",
                                            "parts": {
                                                "total": 0,
                                                "hash": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                                            }
                                        },
                                        "total_txs": 35,
                                        "last_commit_hash": "EE5F3404034C524501629B56E0DDC38FAD651F04",
                                        "data_hash": "EE5F3404034C524501629B56E0DDC38FAD651F04",
                                        "validators_hash": "EE5F3404034C524501629B56E0DDC38FAD651F04",
                                        "next_validators_hash": "EE5F3404034C524501629B56E0DDC38FAD651F04",
                                        "consensus_hash": "EE5F3404034C524501629B56E0DDC38FAD651F04",
                                        "app_hash": "EE5F3404034C524501629B56E0DDC38FAD651F04",
                                        "last_results_hash": "EE5F3404034C524501629B56E0DDC38FAD651F04",
                                        "evidence_hash": "EE5F3404034C524501629B56E0DDC38FAD651F04",
                                        "proposer_address": "cosmos1depk54cuajgkzea6zpgkq36tnjwdzv4afc3d27",
                                        "version": {
                                            "block": "10",
                                            "app": "0"
                                        }
                                    },
                                    "txs": [
                                        "string"
                                    ],
                                    "evidence": [
                                        "string"
                                    ],
                                    "last_commit": {
                                        "block_id": {
                                            "hash": "EE5F3404034C524501629B56E0DDC38FAD651F04",
                                            "parts": {
                                                "total": 0,
                                                "hash": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                                            }
                                        },
                                        "precommits": [
                                            {
                                                "validator_address": "string",
                                                "validator_index": "0",
                                                "height": "0",
                                                "round": "0",
                                                "timestamp": "2017-12-30T04:53:09.287+00:00",
                                                "type": 2,
                                                "block_id": {
                                                    "hash": "EE5F3404034C524501629B56E0DDC38FAD651F04",
                                                    "parts": {
                                                        "total": 0,
                                                        "hash": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                                                    }
                                                },
                                                "signature": "7uTC74QlknqYWEwg7Vn6M8Om7FuZ0EO4bjvuj6rwH1mTUJrRuMMZvAAqT9VjNgP0RA/TDp6u/92AqrZfXJSpBQ=="
                                            }
                                        ]
                                    }
                                }
                            }
                        }
                    },
                    "500": {
                        "description": "Server internal error"
                    }
                }
            }
        },
        "/blocks/{height}": {
            "get": {
                "description": "Get a block at a certain height",
                "operationId": "get-blocks-height",
                "summary": "Get a block at a certain height",
                "tags": [
                    "Tendermint RPC"
                ],
                "parameters": [
                    {
                        "name": "height",
                        "in": "path",
                        "description": "Block height",
                        "required": true,
                        "type": "number"
                    }
                ],
                "produces": [
                    "application/json"
                ],
                "responses": {
                    "200": {
                        "description": "The block at a specific height",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "block_meta": {
                                    "type": "object",
                                    "properties": {
                                        "header": {
                                            "type": "object",
                                            "properties": {
                                                "chain_id": {
                                                    "type": "string",
                                                    "example": "cosmoshub-2"
                                                },
                                                "height": {
                                                    "type": "number",
                                                    "example": 1
                                                },
                                                "time": {
                                                    "type": "string",
                                                    "example": "2017-12-30T04:53:09.287Z"
                                                },
                                                "num_txs": {
                                                    "type": "number",
                                                    "example": 0
                                                },
                                                "last_block_id": {
                                                    "type": "object",
                                                    "properties": {
                                                        "hash": {
                                                            "type": "string",
                                                            "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                                                        },
                                                        "parts": {
                                                            "type": "object",
                                                            "properties": {
                                                                "total": {
                                                                    "type": "number",
                                                                    "example": 0
                                                                },
                                                                "hash": {
                                                                    "type": "string",
                                                                    "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                                                                }
                                                            }
                                                        }
                                                    }
                                                },
                                                "total_txs": {
                                                    "type": "number",
                                                    "example": 35
                                                },
                                                "last_commit_hash": {
                                                    "type": "string",
                                                    "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                                                },
                                                "data_hash": {
                                                    "type": "string",
                                                    "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                                                },
                                                "validators_hash": {
                                                    "type": "string",
                                                    "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                                                },
                                                "next_validators_hash": {
                                                    "type": "string",
                                                    "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                                                },
                                                "consensus_hash": {
                                                    "type": "string",
                                                    "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                                                },
                                                "app_hash": {
                                                    "type": "string",
                                                    "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                                                },
                                                "last_results_hash": {
                                                    "type": "string",
                                                    "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                                                },
                                                "evidence_hash": {
                                                    "type": "string",
                                                    "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                                                },
                                                "proposer_address": {
                                                    "description": "bech32 encoded address",
                                                    "type": "string",
                                                    "example": "cosmos1depk54cuajgkzea6zpgkq36tnjwdzv4afc3d27"
                                                },
                                                "version": {
                                                    "type": "object",
                                                    "properties": {
                                                        "block": {
                                                            "type": "string",
                                                            "example": "10"
                                                        },
                                                        "app": {
                                                            "type": "string",
                                                            "example": "0"
                                                        }
                                                    }
                                                }
                                            }
                                        },
                                        "block_id": {
                                            "type": "object",
                                            "properties": {
                                                "hash": {
                                                    "type": "string",
                                                    "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                                                },
                                                "parts": {
                                                    "type": "object",
                                                    "properties": {
                                                        "total": {
                                                            "type": "number",
                                                            "example": 0
                                                        },
                                                        "hash": {
                                                            "type": "string",
                                                            "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                },
                                "block": {
                                    "type": "object",
                                    "properties": {
                                        "header": {
                                            "type": "object",
                                            "properties": {
                                                "chain_id": {
                                                    "type": "string",
                                                    "example": "cosmoshub-2"
                                                },
                                                "height": {
                                                    "type": "number",
                                                    "example": 1
                                                },
                                                "time": {
                                                    "type": "string",
                                                    "example": "2017-12-30T04:53:09.287Z"
                                                },
                                                "num_txs": {
                                                    "type": "number",
                                                    "example": 0
                                                },
                                                "last_block_id": {
                                                    "type": "object",
                                                    "properties": {
                                                        "hash": {
                                                            "type": "string",
                                                            "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                                                        },
                                                        "parts": {
                                                            "type": "object",
                                                            "properties": {
                                                                "total": {
                                                                    "type": "number",
                                                                    "example": 0
                                                                },
                                                                "hash": {
                                                                    "type": "string",
                                                                    "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                                                                }
                                                            }
                                                        }
                                                    }
                                                },
                                                "total_txs": {
                                                    "type": "number",
                                                    "example": 35
                                                },
                                                "last_commit_hash": {
                                                    "type": "string",
                                                    "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                                                },
                                                "data_hash": {
                                                    "type": "string",
                                                    "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                                                },
                                                "validators_hash": {
                                                    "type": "string",
                                                    "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                                                },
                                                "next_validators_hash": {
                                                    "type": "string",
                                                    "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                                                },
                                                "consensus_hash": {
                                                    "type": "string",
                                                    "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                                                },
                                                "app_hash": {
                                                    "type": "string",
                                                    "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                                                },
                                                "last_results_hash": {
                                                    "type": "string",
                                                    "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                                                },
                                                "evidence_hash": {
                                                    "type": "string",
                                                    "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                                                },
                                                "proposer_address": {
                                                    "description": "bech32 encoded address",
                                                    "type": "string",
                                                    "example": "cosmos1depk54cuajgkzea6zpgkq36tnjwdzv4afc3d27"
                                                },
                                                "version": {
                                                    "type": "object",
                                                    "properties": {
                                                        "block": {
                                                            "type": "string",
                                                            "example": "10"
                                                        },
                                                        "app": {
                                                            "type": "string",
                                                            "example": "0"
                                                        }
                                                    }
                                                }
                                            }
                                        },
                                        "txs": {
                                            "type": "array",
                                            "items": {
                                                "type": "string"
                                            }
                                        },
                                        "evidence": {
                                            "type": "array",
                                            "items": {
                                                "type": "string"
                                            }
                                        },
                                        "last_commit": {
                                            "type": "object",
                                            "properties": {
                                                "block_id": {
                                                    "type": "object",
                                                    "properties": {
                                                        "hash": {
                                                            "type": "string",
                                                            "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                                                        },
                                                        "parts": {
                                                            "type": "object",
                                                            "properties": {
                                                                "total": {
                                                                    "type": "number",
                                                                    "example": 0
                                                                },
                                                                "hash": {
                                                                    "type": "string",
                                                                    "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                                                                }
                                                            }
                                                        }
                                                    }
                                                },
                                                "precommits": {
                                                    "type": "array",
                                                    "items": {
                                                        "type": "object",
                                                        "properties": {
                                                            "validator_address": {
                                                                "type": "string"
                                                            },
                                                            "validator_index": {
                                                                "type": "string",
                                                                "example": "0"
                                                            },
                                                            "height": {
                                                                "type": "string",
                                                                "example": "0"
                                                            },
                                                            "round": {
                                                                "type": "string",
                                                                "example": "0"
                                                            },
                                                            "timestamp": {
                                                                "type": "string",
                                                                "example": "2017-12-30T04:53:09.287Z"
                                                            },
                                                            "type": {
                                                                "type": "number",
                                                                "example": 2
                                                            },
                                                            "block_id": {
                                                                "type": "object",
                                                                "properties": {
                                                                    "hash": {
                                                                        "type": "string",
                                                                        "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                                                                    },
                                                                    "parts": {
                                                                        "type": "object",
                                                                        "properties": {
                                                                            "total": {
                                                                                "type": "number",
                                                                                "example": 0
                                                                            },
                                                                            "hash": {
                                                                                "type": "string",
                                                                                "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            },
                                                            "signature": {
                                                                "type": "string",
                                                                "example": "7uTC74QlknqYWEwg7Vn6M8Om7FuZ0EO4bjvuj6rwH1mTUJrRuMMZvAAqT9VjNgP0RA/TDp6u/92AqrZfXJSpBQ=="
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        },
                        "examples": {
                            "application/json": {
                                "block_meta": {
                                    "header": {
                                        "chain_id": "cosmoshub-2",
                                        "height": 1,
                                        "time": "2017-12-30T04:53:09.287+00:00",
                                        "num_txs": 0,
                                        "last_block_id": {
                                            "hash": "EE5F3404034C524501629B56E0DDC38FAD651F04",
                                            "parts": {
                                                "total": 0,
                                                "hash": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                                            }
                                        },
                                        "total_txs": 35,
                                        "last_commit_hash": "EE5F3404034C524501629B56E0DDC38FAD651F04",
                                        "data_hash": "EE5F3404034C524501629B56E0DDC38FAD651F04",
                                        "validators_hash": "EE5F3404034C524501629B56E0DDC38FAD651F04",
                                        "next_validators_hash": "EE5F3404034C524501629B56E0DDC38FAD651F04",
                                        "consensus_hash": "EE5F3404034C524501629B56E0DDC38FAD651F04",
                                        "app_hash": "EE5F3404034C524501629B56E0DDC38FAD651F04",
                                        "last_results_hash": "EE5F3404034C524501629B56E0DDC38FAD651F04",
                                        "evidence_hash": "EE5F3404034C524501629B56E0DDC38FAD651F04",
                                        "proposer_address": "cosmos1depk54cuajgkzea6zpgkq36tnjwdzv4afc3d27",
                                        "version": {
                                            "block": "10",
                                            "app": "0"
                                        }
                                    },
                                    "block_id": {
                                        "hash": "EE5F3404034C524501629B56E0DDC38FAD651F04",
                                        "parts": {
                                            "total": 0,
                                            "hash": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                                        }
                                    }
                                },
                                "block": {
                                    "header": {
                                        "chain_id": "cosmoshub-2",
                                        "height": 1,
                                        "time": "2017-12-30T04:53:09.287+00:00",
                                        "num_txs": 0,
                                        "last_block_id": {
                                            "hash": "EE5F3404034C524501629B56E0DDC38FAD651F04",
                                            "parts": {
                                                "total": 0,
                                                "hash": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                                            }
                                        },
                                        "total_txs": 35,
                                        "last_commit_hash": "EE5F3404034C524501629B56E0DDC38FAD651F04",
                                        "data_hash": "EE5F3404034C524501629B56E0DDC38FAD651F04",
                                        "validators_hash": "EE5F3404034C524501629B56E0DDC38FAD651F04",
                                        "next_validators_hash": "EE5F3404034C524501629B56E0DDC38FAD651F04",
                                        "consensus_hash": "EE5F3404034C524501629B56E0DDC38FAD651F04",
                                        "app_hash": "EE5F3404034C524501629B56E0DDC38FAD651F04",
                                        "last_results_hash": "EE5F3404034C524501629B56E0DDC38FAD651F04",
                                        "evidence_hash": "EE5F3404034C524501629B56E0DDC38FAD651F04",
                                        "proposer_address": "cosmos1depk54cuajgkzea6zpgkq36tnjwdzv4afc3d27",
                                        "version": {
                                            "block": "10",
                                            "app": "0"
                                        }
                                    },
                                    "txs": [
                                        "string"
                                    ],
                                    "evidence": [
                                        "string"
                                    ],
                                    "last_commit": {
                                        "block_id": {
                                            "hash": "EE5F3404034C524501629B56E0DDC38FAD651F04",
                                            "parts": {
                                                "total": 0,
                                                "hash": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                                            }
                                        },
                                        "precommits": [
                                            {
                                                "validator_address": "string",
                                                "validator_index": "0",
                                                "height": "0",
                                                "round": "0",
                                                "timestamp": "2017-12-30T04:53:09.287+00:00",
                                                "type": 2,
                                                "block_id": {
                                                    "hash": "EE5F3404034C524501629B56E0DDC38FAD651F04",
                                                    "parts": {
                                                        "total": 0,
                                                        "hash": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                                                    }
                                                },
                                                "signature": "7uTC74QlknqYWEwg7Vn6M8Om7FuZ0EO4bjvuj6rwH1mTUJrRuMMZvAAqT9VjNgP0RA/TDp6u/92AqrZfXJSpBQ=="
                                            }
                                        ]
                                    }
                                }
                            }
                        }
                    },
                    "400": {
                        "description": "Invalid height"
                    },
                    "404": {
                        "description": "Request block height doesn't"
                    },
                    "500": {
                        "description": "Server internal error"
                    }
                }
            }
        },
        "/validatorsets/latest": {
            "get": {
                "description": "Get the latest validator set",
                "operationId": "get-validatorsets-latest",
                "summary": "Get the latest validator set",
                "tags": [
                    "Tendermint RPC"
                ],
                "produces": [
                    "application/json"
                ],
                "responses": {
                    "200": {
                        "description": "The validator set at the latest block height",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "block_height": {
                                    "type": "string"
                                },
                                "validators": {
                                    "type": "array",
                                    "items": {
                                        "type": "object",
                                        "properties": {
                                            "address": {
                                                "description": "bech32 encoded address",
                                                "type": "string",
                                                "example": "cosmosvaloper16xyempempp92x9hyzz9wrgf94r6j9h5f2w4n2l"
                                            },
                                            "pub_key": {
                                                "type": "string",
                                                "example": "cosmosvalconspub1zcjduepq0vu2zgkgk49efa0nqwzndanq5m4c7pa3u4apz4g2r9gspqg6g9cs3k9cuf"
                                            },
                                            "voting_power": {
                                                "type": "string",
                                                "example": "1000"
                                            },
                                            "proposer_priority": {
                                                "type": "string",
                                                "example": "1000"
                                            }
                                        }
                                    }
                                }
                            }
                        },
                        "examples": {
                            "application/json": {
                                "block_height": "string",
                                "validators": [
                                    {
                                        "address": "cosmosvaloper16xyempempp92x9hyzz9wrgf94r6j9h5f2w4n2l",
                                        "pub_key": "cosmosvalconspub1zcjduepq0vu2zgkgk49efa0nqwzndanq5m4c7pa3u4apz4g2r9gspqg6g9cs3k9cuf",
                                        "voting_power": "1000",
                                        "proposer_priority": "1000"
                                    }
                                ]
                            }
                        }
                    },
                    "500": {
                        "description": "Server internal error"
                    }
                }
            }
        },
        "/validatorsets/{height}": {
            "get": {
                "description": "Get a validator set a certain height",
                "operationId": "get-validatorsets-height",
                "summary": "Get a validator set a certain height",
                "tags": [
                    "Tendermint RPC"
                ],
                "parameters": [
                    {
                        "name": "height",
                        "in": "path",
                        "description": "Block height",
                        "required": true,
                        "type": "number"
                    }
                ],
                "produces": [
                    "application/json"
                ],
                "responses": {
                    "200": {
                        "description": "The validator set at a specific block height",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "block_height": {
                                    "type": "string"
                                },
                                "validators": {
                                    "type": "array",
                                    "items": {
                                        "type": "object",
                                        "properties": {
                                            "address": {
                                                "description": "bech32 encoded address",
                                                "type": "string",
                                                "example": "cosmosvaloper16xyempempp92x9hyzz9wrgf94r6j9h5f2w4n2l"
                                            },
                                            "pub_key": {
                                                "type": "string",
                                                "example": "cosmosvalconspub1zcjduepq0vu2zgkgk49efa0nqwzndanq5m4c7pa3u4apz4g2r9gspqg6g9cs3k9cuf"
                                            },
                                            "voting_power": {
                                                "type": "string",
                                                "example": "1000"
                                            },
                                            "proposer_priority": {
                                                "type": "string",
                                                "example": "1000"
                                            }
                                        }
                                    }
                                }
                            }
                        },
                        "examples": {
                            "application/json": {
                                "block_height": "string",
                                "validators": [
                                    {
                                        "address": "cosmosvaloper16xyempempp92x9hyzz9wrgf94r6j9h5f2w4n2l",
                                        "pub_key": "cosmosvalconspub1zcjduepq0vu2zgkgk49efa0nqwzndanq5m4c7pa3u4apz4g2r9gspqg6g9cs3k9cuf",
                                        "voting_power": "1000",
                                        "proposer_priority": "1000"
                                    }
                                ]
                            }
                        }
                    },
                    "400": {
                        "description": "Invalid height"
                    },
                    "404": {
                        "description": "Block at height not available"
                    },
                    "500": {
                        "description": "Server internal error"
                    }
                }
            }
        },
        "/txs/{hash}": {
            "get": {
                "description": "Retrieve a transaction using its hash.",
                "operationId": "get-txs-hash",
                "summary": "Get a Tx by hash",
                "tags": [
                    "Transactions"
                ],
                "parameters": [
                    {
                        "name": "hash",
                        "in": "path",
                        "description": "Tx hash",
                        "required": true,
                        "type": "string"
                    }
                ],
                "produces": [
                    "application/json"
                ],
                "responses": {
                    "200": {
                        "description": "Tx with the provided hash",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "hash": {
                                    "type": "string",
                                    "example": "D085138D913993919295FF4B0A9107F1F2CDE0D37A87CE0644E217CBF3B49656"
                                },
                                "height": {
                                    "type": "number",
                                    "example": 368
                                },
                                "tx": {
                                    "type": "object",
                                    "properties": {
                                        "msg": {
                                            "type": "array",
                                            "items": {
                                                "type": "string"
                                            }
                                        },
                                        "fee": {
                                            "type": "object",
                                            "properties": {
                                                "gas": {
                                                    "type": "string"
                                                },
                                                "amount": {
                                                    "type": "array",
                                                    "items": {
                                                        "type": "object",
                                                        "properties": {
                                                            "denom": {
                                                                "type": "string",
                                                                "example": "stake"
                                                            },
                                                            "amount": {
                                                                "type": "string",
                                                                "example": "50"
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        },
                                        "memo": {
                                            "type": "string"
                                        },
                                        "signature": {
                                            "type": "object",
                                            "properties": {
                                                "signature": {
                                                    "type": "string",
                                                    "example": "MEUCIQD02fsDPra8MtbRsyB1w7bqTM55Wu138zQbFcWx4+CFyAIge5WNPfKIuvzBZ69MyqHsqD8S1IwiEp+iUb6VSdtlpgY="
                                                },
                                                "pub_key": {
                                                    "type": "object",
                                                    "properties": {
                                                        "type": {
                                                            "type": "string",
                                                            "example": "tendermint/PubKeySecp256k1"
                                                        },
                                                        "value": {
                                                            "type": "string",
                                                            "example": "Avz04VhtKJh8ACCVzlI8aTosGy0ikFXKIVHQ3jKMrosH"
                                                        }
                                                    }
                                                },
                                                "account_number": {
                                                    "type": "string",
                                                    "example": "0"
                                                },
                                                "sequence": {
                                                    "type": "string",
                                                    "example": "0"
                                                }
                                            }
                                        }
                                    }
                                },
                                "result": {
                                    "type": "object",
                                    "properties": {
                                        "log": {
                                            "type": "string"
                                        },
                                        "gas_wanted": {
                                            "type": "string",
                                            "example": "200000"
                                        },
                                        "gas_used": {
                                            "type": "string",
                                            "example": "26354"
                                        },
                                        "tags": {
                                            "type": "array",
                                            "items": {
                                                "type": "object",
                                                "properties": {
                                                    "key": {
                                                        "type": "string"
                                                    },
                                                    "value": {
                                                        "type": "string"
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        },
                        "examples": {
                            "application/json": {
                                "hash": "D085138D913993919295FF4B0A9107F1F2CDE0D37A87CE0644E217CBF3B49656",
                                "height": 368,
                                "tx": {
                                    "msg": [
                                        "string"
                                    ],
                                    "fee": {
                                        "gas": "string",
                                        "amount": [
                                            {
                                                "denom": "stake",
                                                "amount": "50"
                                            }
                                        ]
                                    },
                                    "memo": "string",
                                    "signature": {
                                        "signature": "MEUCIQD02fsDPra8MtbRsyB1w7bqTM55Wu138zQbFcWx4+CFyAIge5WNPfKIuvzBZ69MyqHsqD8S1IwiEp+iUb6VSdtlpgY=",
                                        "pub_key": {
                                            "type": "tendermint/PubKeySecp256k1",
                                            "value": "Avz04VhtKJh8ACCVzlI8aTosGy0ikFXKIVHQ3jKMrosH"
                                        },
                                        "account_number": "0",
                                        "sequence": "0"
                                    }
                                },
                                "result": {
                                    "log": "string",
                                    "gas_wanted": "200000",
                                    "gas_used": "26354",
                                    "tags": [
                                        {
                                            "key": "string",
                                            "value": "string"
                                        }
                                    ]
                                }
                            }
                        }
                    },
                    "500": {
                        "description": "Internal Server Error"
                    }
                }
            }
        },
        "/txs/encode": {
            "post": {
                "description": "Encode a transaction (signed or not) from JSON to base64-encoded Amino serialized bytes",
                "operationId": "post-txs-encode",
                "summary": "Encode a transaction to the Amino wire format",
                "tags": [
                    "Transactions"
                ],
                "parameters": [
                    {
                        "name": "txsEncodePostRequest",
                        "in": "body",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "tx": {
                                    "type": "object",
                                    "properties": {
                                        "msg": {
                                            "type": "array",
                                            "items": {
                                                "type": "string"
                                            }
                                        },
                                        "fee": {
                                            "type": "object",
                                            "properties": {
                                                "gas": {
                                                    "type": "string"
                                                },
                                                "amount": {
                                                    "type": "array",
                                                    "items": {
                                                        "type": "object",
                                                        "properties": {
                                                            "denom": {
                                                                "type": "string",
                                                                "example": "stake"
                                                            },
                                                            "amount": {
                                                                "type": "string",
                                                                "example": "50"
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        },
                                        "memo": {
                                            "type": "string"
                                        },
                                        "signature": {
                                            "type": "object",
                                            "properties": {
                                                "signature": {
                                                    "type": "string",
                                                    "example": "MEUCIQD02fsDPra8MtbRsyB1w7bqTM55Wu138zQbFcWx4+CFyAIge5WNPfKIuvzBZ69MyqHsqD8S1IwiEp+iUb6VSdtlpgY="
                                                },
                                                "pub_key": {
                                                    "type": "object",
                                                    "properties": {
                                                        "type": {
                                                            "type": "string",
                                                            "example": "tendermint/PubKeySecp256k1"
                                                        },
                                                        "value": {
                                                            "type": "string",
                                                            "example": "Avz04VhtKJh8ACCVzlI8aTosGy0ikFXKIVHQ3jKMrosH"
                                                        }
                                                    }
                                                },
                                                "account_number": {
                                                    "type": "string",
                                                    "example": "0"
                                                },
                                                "sequence": {
                                                    "type": "string",
                                                    "example": "0"
                                                }
                                            }
                                        }
                                    }
                                }
                            },
                            "example": {
                                "tx": {
                                    "msg": [
                                        "string"
                                    ],
                                    "fee": {
                                        "gas": "string",
                                        "amount": [
                                            {
                                                "denom": "stake",
                                                "amount": "50"
                                            }
                                        ]
                                    },
                                    "memo": "string",
                                    "signature": {
                                        "signature": "MEUCIQD02fsDPra8MtbRsyB1w7bqTM55Wu138zQbFcWx4+CFyAIge5WNPfKIuvzBZ69MyqHsqD8S1IwiEp+iUb6VSdtlpgY=",
                                        "pub_key": {
                                            "type": "tendermint/PubKeySecp256k1",
                                            "value": "Avz04VhtKJh8ACCVzlI8aTosGy0ikFXKIVHQ3jKMrosH"
                                        },
                                        "account_number": "0",
                                        "sequence": "0"
                                    }
                                }
                            }
                        },
                        "description": "The tx to encode"
                    }
                ],
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "responses": {
                    "200": {
                        "description": "The tx was successfully decoded and re-encoded",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "tx": {
                                    "type": "string",
                                    "example": "The base64-encoded Amino-serialized bytes for the tx"
                                }
                            }
                        },
                        "examples": {
                            "application/json": {
                                "tx": "The base64-encoded Amino-serialized bytes for the tx"
                            }
                        }
                    },
                    "400": {
                        "description": "The tx was malformated"
                    },
                    "500": {
                        "description": "Server internal error"
                    }
                }
            }
        },
        "/txs/decode": {
            "post": {
                "description": "Decode a transaction (signed or not) from base64-encoded Amino serialized bytes to JSON",
                "operationId": "post-txs-decode",
                "summary": "Decode a transaction from the Amino wire format",
                "tags": [
                    "Transactions"
                ],
                "parameters": [
                    {
                        "name": "txsDecodePostRequest",
                        "in": "body",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "tx": {
                                    "type": "string",
                                    "example": "SvBiXe4KPqijYZoKFFHEzJ8c2HPAfv2EFUcIhx0yPagwEhTy0vPA+GGhCEslKXa4Af0uB+mfShoMCgVzdGFrZRIDMTAwEgQQwJoM"
                                }
                            },
                            "example": {
                                "tx": "SvBiXe4KPqijYZoKFFHEzJ8c2HPAfv2EFUcIhx0yPagwEhTy0vPA+GGhCEslKXa4Af0uB+mfShoMCgVzdGFrZRIDMTAwEgQQwJoM"
                            }
                        },
                        "description": "The tx to decode"
                    }
                ],
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "responses": {
                    "200": {
                        "description": "The tx was successfully decoded",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "msg": {
                                    "type": "array",
                                    "items": {
                                        "type": "string"
                                    }
                                },
                                "fee": {
                                    "type": "object",
                                    "properties": {
                                        "gas": {
                                            "type": "string"
                                        },
                                        "amount": {
                                            "type": "array",
                                            "items": {
                                                "type": "object",
                                                "properties": {
                                                    "denom": {
                                                        "type": "string",
                                                        "example": "stake"
                                                    },
                                                    "amount": {
                                                        "type": "string",
                                                        "example": "50"
                                                    }
                                                }
                                            }
                                        }
                                    }
                                },
                                "memo": {
                                    "type": "string"
                                },
                                "signature": {
                                    "type": "object",
                                    "properties": {
                                        "signature": {
                                            "type": "string",
                                            "example": "MEUCIQD02fsDPra8MtbRsyB1w7bqTM55Wu138zQbFcWx4+CFyAIge5WNPfKIuvzBZ69MyqHsqD8S1IwiEp+iUb6VSdtlpgY="
                                        },
                                        "pub_key": {
                                            "type": "object",
                                            "properties": {
                                                "type": {
                                                    "type": "string",
                                                    "example": "tendermint/PubKeySecp256k1"
                                                },
                                                "value": {
                                                    "type": "string",
                                                    "example": "Avz04VhtKJh8ACCVzlI8aTosGy0ikFXKIVHQ3jKMrosH"
                                                }
                                            }
                                        },
                                        "account_number": {
                                            "type": "string",
                                            "example": "0"
                                        },
                                        "sequence": {
                                            "type": "string",
                                            "example": "0"
                                        }
                                    }
                                }
                            }
                        },
                        "examples": {
                            "application/json": {
                                "msg": [
                                    "string"
                                ],
                                "fee": {
                                    "gas": "string",
                                    "amount": [
                                        {
                                            "denom": "stake",
                                            "amount": "50"
                                        }
                                    ]
                                },
                                "memo": "string",
                                "signature": {
                                    "signature": "MEUCIQD02fsDPra8MtbRsyB1w7bqTM55Wu138zQbFcWx4+CFyAIge5WNPfKIuvzBZ69MyqHsqD8S1IwiEp+iUb6VSdtlpgY=",
                                    "pub_key": {
                                        "type": "tendermint/PubKeySecp256k1",
                                        "value": "Avz04VhtKJh8ACCVzlI8aTosGy0ikFXKIVHQ3jKMrosH"
                                    },
                                    "account_number": "0",
                                    "sequence": "0"
                                }
                            }
                        }
                    },
                    "400": {
                        "description": "The tx was malformated"
                    },
                    "500": {
                        "description": "Server internal error"
                    }
                }
            }
        },
        "/bank/accounts/{address}/transfers": {
            "post": {
                "description": "Send coins from one account to another",
                "operationId": "post-bank-accounts-address-transfers",
                "summary": "Send coins from one account to another",
                "tags": [
                    "Bank"
                ],
                "parameters": [
                    {
                        "name": "address",
                        "in": "path",
                        "description": "Account address in bech32 format",
                        "required": true,
                        "type": "string"
                    },
                    {
                        "name": "bankAccounts-address-TransfersPostRequest-1",
                        "in": "body",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "base_req": {
                                    "type": "object",
                                    "properties": {
                                        "from": {
                                            "description": "Sender address or Keybase name to generate a transaction",
                                            "type": "string",
                                            "example": "cosmos1g9ahr6xhht5rmqven628nklxluzyv8z9jqjcmc"
                                        },
                                        "memo": {
                                            "type": "string",
                                            "example": "Sent via Cosmos Voyager ðŸš€"
                                        },
                                        "chain_id": {
                                            "type": "string",
                                            "example": "Cosmos-Hub"
                                        },
                                        "account_number": {
                                            "type": "string",
                                            "example": "0"
                                        },
                                        "sequence": {
                                            "type": "string",
                                            "example": "1"
                                        },
                                        "gas": {
                                            "type": "string",
                                            "example": "200000"
                                        },
                                        "gas_adjustment": {
                                            "type": "string",
                                            "example": "1.2"
                                        },
                                        "fees": {
                                            "type": "array",
                                            "items": {
                                                "type": "object",
                                                "properties": {
                                                    "denom": {
                                                        "type": "string",
                                                        "example": "stake"
                                                    },
                                                    "amount": {
                                                        "type": "string",
                                                        "example": "50"
                                                    }
                                                }
                                            }
                                        },
                                        "simulate": {
                                            "description": "Estimate gas for a transaction (cannot be used in conjunction with generate_only)",
                                            "type": "boolean",
                                            "example": false
                                        }
                                    }
                                },
                                "amount": {
                                    "type": "array",
                                    "items": {
                                        "type": "object",
                                        "properties": {
                                            "denom": {
                                                "type": "string",
                                                "example": "stake"
                                            },
                                            "amount": {
                                                "type": "string",
                                                "example": "50"
                                            }
                                        }
                                    }
                                }
                            },
                            "example": {
                                "base_req": {
                                    "from": "cosmos1g9ahr6xhht5rmqven628nklxluzyv8z9jqjcmc",
                                    "memo": "Sent via Cosmos Voyager ðŸš€",
                                    "chain_id": "Cosmos-Hub",
                                    "account_number": "0",
                                    "sequence": "1",
                                    "gas": "200000",
                                    "gas_adjustment": "2022-01-02",
                                    "fees": [
                                        {
                                            "denom": "stake",
                                            "amount": "50"
                                        }
                                    ],
                                    "simulate": false
                                },
                                "amount": [
                                    {
                                        "denom": "stake",
                                        "amount": "50"
                                    }
                                ]
                            }
                        },
                        "description": "The sender and tx information"
                    }
                ],
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "responses": {
                    "202": {
                        "description": "Tx was succesfully generated",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "msg": {
                                    "type": "array",
                                    "items": {
                                        "type": "string"
                                    }
                                },
                                "fee": {
                                    "type": "object",
                                    "properties": {
                                        "gas": {
                                            "type": "string"
                                        },
                                        "amount": {
                                            "type": "array",
                                            "items": {
                                                "type": "object",
                                                "properties": {
                                                    "denom": {
                                                        "type": "string",
                                                        "example": "stake"
                                                    },
                                                    "amount": {
                                                        "type": "string",
                                                        "example": "50"
                                                    }
                                                }
                                            }
                                        }
                                    }
                                },
                                "memo": {
                                    "type": "string"
                                },
                                "signature": {
                                    "type": "object",
                                    "properties": {
                                        "signature": {
                                            "type": "string",
                                            "example": "MEUCIQD02fsDPra8MtbRsyB1w7bqTM55Wu138zQbFcWx4+CFyAIge5WNPfKIuvzBZ69MyqHsqD8S1IwiEp+iUb6VSdtlpgY="
                                        },
                                        "pub_key": {
                                            "type": "object",
                                            "properties": {
                                                "type": {
                                                    "type": "string",
                                                    "example": "tendermint/PubKeySecp256k1"
                                                },
                                                "value": {
                                                    "type": "string",
                                                    "example": "Avz04VhtKJh8ACCVzlI8aTosGy0ikFXKIVHQ3jKMrosH"
                                                }
                                            }
                                        },
                                        "account_number": {
                                            "type": "string",
                                            "example": "0"
                                        },
                                        "sequence": {
                                            "type": "string",
                                            "example": "0"
                                        }
                                    }
                                }
                            }
                        },
                        "examples": {
                            "application/json": {
                                "msg": [
                                    "string"
                                ],
                                "fee": {
                                    "gas": "string",
                                    "amount": [
                                        {
                                            "denom": "stake",
                                            "amount": "50"
                                        }
                                    ]
                                },
                                "memo": "string",
                                "signature": {
                                    "signature": "MEUCIQD02fsDPra8MtbRsyB1w7bqTM55Wu138zQbFcWx4+CFyAIge5WNPfKIuvzBZ69MyqHsqD8S1IwiEp+iUb6VSdtlpgY=",
                                    "pub_key": {
                                        "type": "tendermint/PubKeySecp256k1",
                                        "value": "Avz04VhtKJh8ACCVzlI8aTosGy0ikFXKIVHQ3jKMrosH"
                                    },
                                    "account_number": "0",
                                    "sequence": "0"
                                }
                            }
                        }
                    },
                    "400": {
                        "description": "Invalid request"
                    },
                    "500": {
                        "description": "Server internal error"
                    }
                }
            }
        },
        "/staking/delegators/{delegatorAddr}/delegations": {
            "get": {
                "description": "Get all delegations from a delegator",
                "operationId": "get-staking-delegators-delegatoraddr-delegations",
                "summary": "Get all delegations from a delegator",
                "tags": [
                    "Staking"
                ],
                "parameters": [
                    {
                        "name": "delegatorAddr",
                        "in": "path",
                        "description": "Bech32 AccAddress of Delegator",
                        "required": true,
                        "type": "string"
                    }
                ],
                "produces": [
                    "application/json"
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "type": "object",
                                "properties": {
                                    "delegator_address": {
                                        "type": "string"
                                    },
                                    "validator_address": {
                                        "type": "string"
                                    },
                                    "shares": {
                                        "type": "string"
                                    },
                                    "balance": {
                                        "type": "object",
                                        "properties": {
                                            "denom": {
                                                "type": "string",
                                                "example": "stake"
                                            },
                                            "amount": {
                                                "type": "string",
                                                "example": "50"
                                            }
                                        }
                                    }
                                }
                            }
                        },
                        "examples": {
                            "application/json": [
                                {
                                    "delegator_address": "string",
                                    "validator_address": "string",
                                    "shares": "string",
                                    "balance": {
                                        "denom": "stake",
                                        "amount": "50"
                                    }
                                }
                            ]
                        }
                    },
                    "400": {
                        "description": "Invalid delegator address"
                    },
                    "500": {
                        "description": "Internal Server Error"
                    }
                }
            },
            "post": {
                "description": "Submit delegation",
                "operationId": "post-staking-delegators-delegatoraddr-delegations",
                "summary": "Submit delegation",
                "tags": [
                    "Staking"
                ],
                "parameters": [
                    {
                        "name": "delegatorAddr",
                        "in": "path",
                        "description": "Bech32 AccAddress of Delegator",
                        "required": true,
                        "type": "string"
                    },
                    {
                        "name": "stakingDelegators-delegatorAddr-DelegationsPostRequest-1",
                        "in": "body",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "base_req": {
                                    "type": "object",
                                    "properties": {
                                        "from": {
                                            "description": "Sender address or Keybase name to generate a transaction",
                                            "type": "string",
                                            "example": "cosmos1g9ahr6xhht5rmqven628nklxluzyv8z9jqjcmc"
                                        },
                                        "memo": {
                                            "type": "string",
                                            "example": "Sent via Cosmos Voyager ðŸš€"
                                        },
                                        "chain_id": {
                                            "type": "string",
                                            "example": "Cosmos-Hub"
                                        },
                                        "account_number": {
                                            "type": "string",
                                            "example": "0"
                                        },
                                        "sequence": {
                                            "type": "string",
                                            "example": "1"
                                        },
                                        "gas": {
                                            "type": "string",
                                            "example": "200000"
                                        },
                                        "gas_adjustment": {
                                            "type": "string",
                                            "example": "1.2"
                                        },
                                        "fees": {
                                            "type": "array",
                                            "items": {
                                                "type": "object",
                                                "properties": {
                                                    "denom": {
                                                        "type": "string",
                                                        "example": "stake"
                                                    },
                                                    "amount": {
                                                        "type": "string",
                                                        "example": "50"
                                                    }
                                                }
                                            }
                                        },
                                        "simulate": {
                                            "description": "Estimate gas for a transaction (cannot be used in conjunction with generate_only)",
                                            "type": "boolean",
                                            "example": false
                                        }
                                    }
                                },
                                "delegator_address": {
                                    "description": "bech32 encoded address",
                                    "type": "string",
                                    "example": "cosmos1depk54cuajgkzea6zpgkq36tnjwdzv4afc3d27"
                                },
                                "validator_address": {
                                    "description": "bech32 encoded address",
                                    "type": "string",
                                    "example": "cosmosvaloper16xyempempp92x9hyzz9wrgf94r6j9h5f2w4n2l"
                                },
                                "amount": {
                                    "type": "object",
                                    "properties": {
                                        "denom": {
                                            "type": "string",
                                            "example": "stake"
                                        },
                                        "amount": {
                                            "type": "string",
                                            "example": "50"
                                        }
                                    }
                                }
                            },
                            "example": {
                                "base_req": {
                                    "from": "cosmos1g9ahr6xhht5rmqven628nklxluzyv8z9jqjcmc",
                                    "memo": "Sent via Cosmos Voyager ðŸš€",
                                    "chain_id": "Cosmos-Hub",
                                    "account_number": "0",
                                    "sequence": "1",
                                    "gas": "200000",
                                    "gas_adjustment": "2022-01-02",
                                    "fees": [
                                        {
                                            "denom": "stake",
                                            "amount": "50"
                                        }
                                    ],
                                    "simulate": false
                                },
                                "delegator_address": "cosmos1depk54cuajgkzea6zpgkq36tnjwdzv4afc3d27",
                                "validator_address": "cosmosvaloper16xyempempp92x9hyzz9wrgf94r6j9h5f2w4n2l",
                                "amount": {
                                    "denom": "stake",
                                    "amount": "50"
                                }
                            }
                        },
                        "description": "Delegate an amount of liquid coins to a validator"
                    }
                ],
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "msg": {
                                    "type": "array",
                                    "items": {
                                        "type": "string"
                                    }
                                },
                                "fee": {
                                    "type": "object",
                                    "properties": {
                                        "gas": {
                                            "type": "string"
                                        },
                                        "amount": {
                                            "type": "array",
                                            "items": {
                                                "type": "object",
                                                "properties": {
                                                    "denom": {
                                                        "type": "string",
                                                        "example": "stake"
                                                    },
                                                    "amount": {
                                                        "type": "string",
                                                        "example": "50"
                                                    }
                                                }
                                            }
                                        }
                                    }
                                },
                                "memo": {
                                    "type": "string"
                                },
                                "signature": {
                                    "type": "object",
                                    "properties": {
                                        "signature": {
                                            "type": "string",
                                            "example": "MEUCIQD02fsDPra8MtbRsyB1w7bqTM55Wu138zQbFcWx4+CFyAIge5WNPfKIuvzBZ69MyqHsqD8S1IwiEp+iUb6VSdtlpgY="
                                        },
                                        "pub_key": {
                                            "type": "object",
                                            "properties": {
                                                "type": {
                                                    "type": "string",
                                                    "example": "tendermint/PubKeySecp256k1"
                                                },
                                                "value": {
                                                    "type": "string",
                                                    "example": "Avz04VhtKJh8ACCVzlI8aTosGy0ikFXKIVHQ3jKMrosH"
                                                }
                                            }
                                        },
                                        "account_number": {
                                            "type": "string",
                                            "example": "0"
                                        },
                                        "sequence": {
                                            "type": "string",
                                            "example": "0"
                                        }
                                    }
                                }
                            }
                        },
                        "examples": {
                            "application/json": {
                                "msg": [
                                    "string"
                                ],
                                "fee": {
                                    "gas": "string",
                                    "amount": [
                                        {
                                            "denom": "stake",
                                            "amount": "50"
                                        }
                                    ]
                                },
                                "memo": "string",
                                "signature": {
                                    "signature": "MEUCIQD02fsDPra8MtbRsyB1w7bqTM55Wu138zQbFcWx4+CFyAIge5WNPfKIuvzBZ69MyqHsqD8S1IwiEp+iUb6VSdtlpgY=",
                                    "pub_key": {
                                        "type": "tendermint/PubKeySecp256k1",
                                        "value": "Avz04VhtKJh8ACCVzlI8aTosGy0ikFXKIVHQ3jKMrosH"
                                    },
                                    "account_number": "0",
                                    "sequence": "0"
                                }
                            }
                        }
                    },
                    "400": {
                        "description": "Invalid delegator address or delegation request body"
                    },
                    "401": {
                        "description": "Key password is wrong"
                    },
                    "500": {
                        "description": "Internal Server Error"
                    }
                }
            }
        },
        "/staking/delegators/{delegatorAddr}/delegations/{validatorAddr}": {
            "get": {
                "description": "Query the current delegation between a delegator and a validator",
                "operationId": "get-staking-delegators-delegatoraddr-delegations-validatoraddr",
                "summary": "Query the current delegation between a delegator and a validator",
                "tags": [
                    "Staking"
                ],
                "parameters": [
                    {
                        "name": "delegatorAddr",
                        "in": "path",
                        "description": "Bech32 AccAddress of Delegator",
                        "required": true,
                        "type": "string"
                    },
                    {
                        "name": "validatorAddr",
                        "in": "path",
                        "description": "Bech32 OperatorAddress of validator",
                        "required": true,
                        "type": "string"
                    }
                ],
                "produces": [
                    "application/json"
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "delegator_address": {
                                    "type": "string"
                                },
                                "validator_address": {
                                    "type": "string"
                                },
                                "shares": {
                                    "type": "string"
                                },
                                "balance": {
                                    "type": "object",
                                    "properties": {
                                        "denom": {
                                            "type": "string",
                                            "example": "stake"
                                        },
                                        "amount": {
                                            "type": "string",
                                            "example": "50"
                                        }
                                    }
                                }
                            }
                        },
                        "examples": {
                            "application/json": {
                                "delegator_address": "string",
                                "validator_address": "string",
                                "shares": "string",
                                "balance": {
                                    "denom": "stake",
                                    "amount": "50"
                                }
                            }
                        }
                    },
                    "400": {
                        "description": "Invalid delegator address or validator address"
                    },
                    "500": {
                        "description": "Internal Server Error"
                    }
                }
            }
        },
        "/staking/delegators/{delegatorAddr}/unbonding_delegations": {
            "get": {
                "description": "Get all unbonding delegations from a delegator",
                "operationId": "get-staking-delegators-delegatoraddr-unbonding_delegations",
                "summary": "Get all unbonding delegations from a delegator",
                "tags": [
                    "Staking"
                ],
                "parameters": [
                    {
                        "name": "delegatorAddr",
                        "in": "path",
                        "description": "Bech32 AccAddress of Delegator",
                        "required": true,
                        "type": "string"
                    }
                ],
                "produces": [
                    "application/json"
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "type": "object",
                                "properties": {
                                    "delegator_address": {
                                        "type": "string"
                                    },
                                    "validator_address": {
                                        "type": "string"
                                    },
                                    "initial_balance": {
                                        "type": "string"
                                    },
                                    "balance": {
                                        "type": "string"
                                    },
                                    "creation_height": {
                                        "type": "integer"
                                    },
                                    "min_time": {
                                        "type": "integer"
                                    }
                                }
                            }
                        },
                        "examples": {
                            "application/json": [
                                {
                                    "delegator_address": "string",
                                    "validator_address": "string",
                                    "initial_balance": "string",
                                    "balance": "string",
                                    "creation_height": 0,
                                    "min_time": 0
                                }
                            ]
                        }
                    },
                    "400": {
                        "description": "Invalid delegator address"
                    },
                    "500": {
                        "description": "Internal Server Error"
                    }
                }
            },
            "post": {
                "description": "Submit an unbonding delegation",
                "operationId": "post-staking-delegators-delegatoraddr-unbonding_delegations",
                "summary": "Submit an unbonding delegation",
                "tags": [
                    "Staking"
                ],
                "parameters": [
                    {
                        "name": "delegatorAddr",
                        "in": "path",
                        "description": "Bech32 AccAddress of Delegator",
                        "required": true,
                        "type": "string"
                    },
                    {
                        "name": "stakingDelegators-delegatorAddr-Unbonding_delegationsPostRequest-1",
                        "in": "body",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "base_req": {
                                    "type": "object",
                                    "properties": {
                                        "from": {
                                            "description": "Sender address or Keybase name to generate a transaction",
                                            "type": "string",
                                            "example": "cosmos1g9ahr6xhht5rmqven628nklxluzyv8z9jqjcmc"
                                        },
                                        "memo": {
                                            "type": "string",
                                            "example": "Sent via Cosmos Voyager ðŸš€"
                                        },
                                        "chain_id": {
                                            "type": "string",
                                            "example": "Cosmos-Hub"
                                        },
                                        "account_number": {
                                            "type": "string",
                                            "example": "0"
                                        },
                                        "sequence": {
                                            "type": "string",
                                            "example": "1"
                                        },
                                        "gas": {
                                            "type": "string",
                                            "example": "200000"
                                        },
                                        "gas_adjustment": {
                                            "type": "string",
                                            "example": "1.2"
                                        },
                                        "fees": {
                                            "type": "array",
                                            "items": {
                                                "type": "object",
                                                "properties": {
                                                    "denom": {
                                                        "type": "string",
                                                        "example": "stake"
                                                    },
                                                    "amount": {
                                                        "type": "string",
                                                        "example": "50"
                                                    }
                                                }
                                            }
                                        },
                                        "simulate": {
                                            "description": "Estimate gas for a transaction (cannot be used in conjunction with generate_only)",
                                            "type": "boolean",
                                            "example": false
                                        }
                                    }
                                },
                                "delegator_address": {
                                    "description": "bech32 encoded address",
                                    "type": "string",
                                    "example": "cosmos1depk54cuajgkzea6zpgkq36tnjwdzv4afc3d27"
                                },
                                "validator_address": {
                                    "description": "bech32 encoded address",
                                    "type": "string",
                                    "example": "cosmosvaloper16xyempempp92x9hyzz9wrgf94r6j9h5f2w4n2l"
                                },
                                "amount": {
                                    "type": "object",
                                    "properties": {
                                        "denom": {
                                            "type": "string",
                                            "example": "stake"
                                        },
                                        "amount": {
                                            "type": "string",
                                            "example": "50"
                                        }
                                    }
                                }
                            },
                            "example": {
                                "base_req": {
                                    "from": "cosmos1g9ahr6xhht5rmqven628nklxluzyv8z9jqjcmc",
                                    "memo": "Sent via Cosmos Voyager ðŸš€",
                                    "chain_id": "Cosmos-Hub",
                                    "account_number": "0",
                                    "sequence": "1",
                                    "gas": "200000",
                                    "gas_adjustment": "2022-01-02",
                                    "fees": [
                                        {
                                            "denom": "stake",
                                            "amount": "50"
                                        }
                                    ],
                                    "simulate": false
                                },
                                "delegator_address": "cosmos1depk54cuajgkzea6zpgkq36tnjwdzv4afc3d27",
                                "validator_address": "cosmosvaloper16xyempempp92x9hyzz9wrgf94r6j9h5f2w4n2l",
                                "amount": {
                                    "denom": "stake",
                                    "amount": "50"
                                }
                            }
                        },
                        "description": "Unbond an amount of bonded shares from a validator"
                    }
                ],
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "msg": {
                                    "type": "array",
                                    "items": {
                                        "type": "string"
                                    }
                                },
                                "fee": {
                                    "type": "object",
                                    "properties": {
                                        "gas": {
                                            "type": "string"
                                        },
                                        "amount": {
                                            "type": "array",
                                            "items": {
                                                "type": "object",
                                                "properties": {
                                                    "denom": {
                                                        "type": "string",
                                                        "example": "stake"
                                                    },
                                                    "amount": {
                                                        "type": "string",
                                                        "example": "50"
                                                    }
                                                }
                                            }
                                        }
                                    }
                                },
                                "memo": {
                                    "type": "string"
                                },
                                "signature": {
                                    "type": "object",
                                    "properties": {
                                        "signature": {
                                            "type": "string",
                                            "example": "MEUCIQD02fsDPra8MtbRsyB1w7bqTM55Wu138zQbFcWx4+CFyAIge5WNPfKIuvzBZ69MyqHsqD8S1IwiEp+iUb6VSdtlpgY="
                                        },
                                        "pub_key": {
                                            "type": "object",
                                            "properties": {
                                                "type": {
                                                    "type": "string",
                                                    "example": "tendermint/PubKeySecp256k1"
                                                },
                                                "value": {
                                                    "type": "string",
                                                    "example": "Avz04VhtKJh8ACCVzlI8aTosGy0ikFXKIVHQ3jKMrosH"
                                                }
                                            }
                                        },
                                        "account_number": {
                                            "type": "string",
                                            "example": "0"
                                        },
                                        "sequence": {
                                            "type": "string",
                                            "example": "0"
                                        }
                                    }
                                }
                            }
                        },
                        "examples": {
                            "application/json": {
                                "msg": [
                                    "string"
                                ],
                                "fee": {
                                    "gas": "string",
                                    "amount": [
                                        {
                                            "denom": "stake",
                                            "amount": "50"
                                        }
                                    ]
                                },
                                "memo": "string",
                                "signature": {
                                    "signature": "MEUCIQD02fsDPra8MtbRsyB1w7bqTM55Wu138zQbFcWx4+CFyAIge5WNPfKIuvzBZ69MyqHsqD8S1IwiEp+iUb6VSdtlpgY=",
                                    "pub_key": {
                                        "type": "tendermint/PubKeySecp256k1",
                                        "value": "Avz04VhtKJh8ACCVzlI8aTosGy0ikFXKIVHQ3jKMrosH"
                                    },
                                    "account_number": "0",
                                    "sequence": "0"
                                }
                            }
                        }
                    },
                    "400": {
                        "description": "Invalid delegator address or unbonding delegation request body"
                    },
                    "401": {
                        "description": "Key password is wrong"
                    },
                    "500": {
                        "description": "Internal Server Error"
                    }
                }
            }
        },
        "/staking/delegators/{delegatorAddr}/unbonding_delegations/{validatorAddr}": {
            "get": {
                "description": "Query all unbonding delegations between a delegator and a validator",
                "operationId": "get-staking-delegators-delegatoraddr-unbonding_delegations-validatoraddr",
                "summary": "Query all unbonding delegations between a delegator and a validator",
                "tags": [
                    "Staking"
                ],
                "parameters": [
                    {
                        "name": "delegatorAddr",
                        "in": "path",
                        "description": "Bech32 AccAddress of Delegator",
                        "required": true,
                        "type": "string"
                    },
                    {
                        "name": "validatorAddr",
                        "in": "path",
                        "description": "Bech32 OperatorAddress of validator",
                        "required": true,
                        "type": "string"
                    }
                ],
                "produces": [
                    "application/json"
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "delegator_address": {
                                    "type": "string"
                                },
                                "validator_address": {
                                    "type": "string"
                                },
                                "entries": {
                                    "type": "array",
                                    "items": {
                                        "type": "object",
                                        "properties": {
                                            "initial_balance": {
                                                "type": "string"
                                            },
                                            "balance": {
                                                "type": "string"
                                            },
                                            "creation_height": {
                                                "type": "string"
                                            },
                                            "min_time": {
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        },
                        "examples": {
                            "application/json": {
                                "delegator_address": "string",
                                "validator_address": "string",
                                "entries": [
                                    {
                                        "initial_balance": "string",
                                        "balance": "string",
                                        "creation_height": "string",
                                        "min_time": "string"
                                    }
                                ]
                            }
                        }
                    },
                    "400": {
                        "description": "Invalid delegator address or validator address"
                    },
                    "500": {
                        "description": "Internal Server Error"
                    }
                }
            }
        },
        "/staking/redelegations": {
            "get": {
                "description": "Get all redelegations (filter by query params)",
                "operationId": "get-staking-redelegations",
                "summary": "Get all redelegations (filter by query params)",
                "tags": [
                    "Staking"
                ],
                "parameters": [
                    {
                        "name": "delegator",
                        "in": "query",
                        "description": "Bech32 AccAddress of Delegator",
                        "type": "string"
                    },
                    {
                        "name": "validator_from",
                        "in": "query",
                        "description": "Bech32 ValAddress of SrcValidator",
                        "type": "string"
                    },
                    {
                        "name": "validator_to",
                        "in": "query",
                        "description": "Bech32 ValAddress of DstValidator",
                        "type": "string"
                    }
                ],
                "produces": [
                    "application/json"
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "$ref": "#/definitions/Redelegation"
                            }
                        }
                    },
                    "500": {
                        "description": "Internal Server Error"
                    }
                }
            }
        },
        "/staking/delegators/{delegatorAddr}/redelegations": {
            "post": {
                "description": "Submit a redelegation",
                "operationId": "post-staking-delegators-delegatoraddr-redelegations",
                "summary": "Submit a redelegation",
                "tags": [
                    "Staking"
                ],
                "parameters": [
                    {
                        "name": "delegatorAddr",
                        "in": "path",
                        "description": "Bech32 AccAddress of Delegator",
                        "required": true,
                        "type": "string"
                    },
                    {
                        "name": "stakingDelegators-delegatorAddr-RedelegationsPostRequest-1",
                        "in": "body",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "base_req": {
                                    "type": "object",
                                    "properties": {
                                        "from": {
                                            "description": "Sender address or Keybase name to generate a transaction",
                                            "type": "string",
                                            "example": "cosmos1g9ahr6xhht5rmqven628nklxluzyv8z9jqjcmc"
                                        },
                                        "memo": {
                                            "type": "string",
                                            "example": "Sent via Cosmos Voyager ðŸš€"
                                        },
                                        "chain_id": {
                                            "type": "string",
                                            "example": "Cosmos-Hub"
                                        },
                                        "account_number": {
                                            "type": "string",
                                            "example": "0"
                                        },
                                        "sequence": {
                                            "type": "string",
                                            "example": "1"
                                        },
                                        "gas": {
                                            "type": "string",
                                            "example": "200000"
                                        },
                                        "gas_adjustment": {
                                            "type": "string",
                                            "example": "1.2"
                                        },
                                        "fees": {
                                            "type": "array",
                                            "items": {
                                                "type": "object",
                                                "properties": {
                                                    "denom": {
                                                        "type": "string",
                                                        "example": "stake"
                                                    },
                                                    "amount": {
                                                        "type": "string",
                                                        "example": "50"
                                                    }
                                                }
                                            }
                                        },
                                        "simulate": {
                                            "description": "Estimate gas for a transaction (cannot be used in conjunction with generate_only)",
                                            "type": "boolean",
                                            "example": false
                                        }
                                    }
                                },
                                "delegator_address": {
                                    "description": "bech32 encoded address",
                                    "type": "string",
                                    "example": "cosmos1depk54cuajgkzea6zpgkq36tnjwdzv4afc3d27"
                                },
                                "validator_src_addressess": {
                                    "description": "bech32 encoded address",
                                    "type": "string",
                                    "example": "cosmosvaloper16xyempempp92x9hyzz9wrgf94r6j9h5f2w4n2l"
                                },
                                "validator_dst_address": {
                                    "description": "bech32 encoded address",
                                    "type": "string",
                                    "example": "cosmosvaloper16xyempempp92x9hyzz9wrgf94r6j9h5f2w4n2l"
                                },
                                "shares": {
                                    "type": "string",
                                    "example": "100"
                                }
                            },
                            "example": {
                                "base_req": {
                                    "from": "cosmos1g9ahr6xhht5rmqven628nklxluzyv8z9jqjcmc",
                                    "memo": "Sent via Cosmos Voyager ðŸš€",
                                    "chain_id": "Cosmos-Hub",
                                    "account_number": "0",
                                    "sequence": "1",
                                    "gas": "200000",
                                    "gas_adjustment": "2022-01-02",
                                    "fees": [
                                        {
                                            "denom": "stake",
                                            "amount": "50"
                                        }
                                    ],
                                    "simulate": false
                                },
                                "delegator_address": "cosmos1depk54cuajgkzea6zpgkq36tnjwdzv4afc3d27",
                                "validator_src_addressess": "cosmosvaloper16xyempempp92x9hyzz9wrgf94r6j9h5f2w4n2l",
                                "validator_dst_address": "cosmosvaloper16xyempempp92x9hyzz9wrgf94r6j9h5f2w4n2l",
                                "shares": "100"
                            }
                        },
                        "description": "The sender and tx information"
                    }
                ],
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "responses": {
                    "200": {
                        "description": "Tx was succesfully generated",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "msg": {
                                    "type": "array",
                                    "items": {
                                        "type": "string"
                                    }
                                },
                                "fee": {
                                    "type": "object",
                                    "properties": {
                                        "gas": {
                                            "type": "string"
                                        },
                                        "amount": {
                                            "type": "array",
                                            "items": {
                                                "type": "object",
                                                "properties": {
                                                    "denom": {
                                                        "type": "string",
                                                        "example": "stake"
                                                    },
                                                    "amount": {
                                                        "type": "string",
                                                        "example": "50"
                                                    }
                                                }
                                            }
                                        }
                                    }
                                },
                                "memo": {
                                    "type": "string"
                                },
                                "signature": {
                                    "type": "object",
                                    "properties": {
                                        "signature": {
                                            "type": "string",
                                            "example": "MEUCIQD02fsDPra8MtbRsyB1w7bqTM55Wu138zQbFcWx4+CFyAIge5WNPfKIuvzBZ69MyqHsqD8S1IwiEp+iUb6VSdtlpgY="
                                        },
                                        "pub_key": {
                                            "type": "object",
                                            "properties": {
                                                "type": {
                                                    "type": "string",
                                                    "example": "tendermint/PubKeySecp256k1"
                                                },
                                                "value": {
                                                    "type": "string",
                                                    "example": "Avz04VhtKJh8ACCVzlI8aTosGy0ikFXKIVHQ3jKMrosH"
                                                }
                                            }
                                        },
                                        "account_number": {
                                            "type": "string",
                                            "example": "0"
                                        },
                                        "sequence": {
                                            "type": "string",
                                            "example": "0"
                                        }
                                    }
                                }
                            }
                        },
                        "examples": {
                            "application/json": {
                                "msg": [
                                    "string"
                                ],
                                "fee": {
                                    "gas": "string",
                                    "amount": [
                                        {
                                            "denom": "stake",
                                            "amount": "50"
                                        }
                                    ]
                                },
                                "memo": "string",
                                "signature": {
                                    "signature": "MEUCIQD02fsDPra8MtbRsyB1w7bqTM55Wu138zQbFcWx4+CFyAIge5WNPfKIuvzBZ69MyqHsqD8S1IwiEp+iUb6VSdtlpgY=",
                                    "pub_key": {
                                        "type": "tendermint/PubKeySecp256k1",
                                        "value": "Avz04VhtKJh8ACCVzlI8aTosGy0ikFXKIVHQ3jKMrosH"
                                    },
                                    "account_number": "0",
                                    "sequence": "0"
                                }
                            }
                        }
                    },
                    "400": {
                        "description": "Invalid delegator address or redelegation request body"
                    },
                    "500": {
                        "description": "Internal Server Error"
                    }
                }
            }
        },
        "/staking/delegators/{delegatorAddr}/validators": {
            "get": {
                "description": "Query all validators that a delegator is bonded to",
                "operationId": "get-staking-delegators-delegatoraddr-validators",
                "summary": "Query all validators that a delegator is bonded to",
                "tags": [
                    "Staking"
                ],
                "parameters": [
                    {
                        "name": "delegatorAddr",
                        "in": "path",
                        "description": "Bech32 AccAddress of Delegator",
                        "required": true,
                        "type": "string"
                    }
                ],
                "produces": [
                    "application/json"
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "type": "object",
                                "properties": {
                                    "operator_address": {
                                        "description": "bech32 encoded address",
                                        "type": "string",
                                        "example": "cosmosvaloper16xyempempp92x9hyzz9wrgf94r6j9h5f2w4n2l"
                                    },
                                    "consensus_pubkey": {
                                        "type": "string",
                                        "example": "cosmosvalconspub1zcjduepq0vu2zgkgk49efa0nqwzndanq5m4c7pa3u4apz4g2r9gspqg6g9cs3k9cuf"
                                    },
                                    "jailed": {
                                        "type": "boolean"
                                    },
                                    "status": {
                                        "type": "integer"
                                    },
                                    "tokens": {
                                        "type": "string"
                                    },
                                    "delegator_shares": {
                                        "type": "string"
                                    },
                                    "description": {
                                        "type": "object",
                                        "properties": {
                                            "moniker": {
                                                "type": "string"
                                            },
                                            "identity": {
                                                "type": "string"
                                            },
                                            "website": {
                                                "type": "string"
                                            },
                                            "security_contact": {
                                                "type": "string"
                                            },
                                            "details": {
                                                "type": "string"
                                            }
                                        }
                                    },
                                    "bond_height": {
                                        "type": "string",
                                        "example": "0"
                                    },
                                    "bond_intra_tx_counter": {
                                        "type": "integer",
                                        "example": 0
                                    },
                                    "unbonding_height": {
                                        "type": "string",
                                        "example": "0"
                                    },
                                    "unbonding_time": {
                                        "type": "string",
                                        "example": "1970-01-01T00:00:00Z"
                                    },
                                    "commission": {
                                        "type": "object",
                                        "properties": {
                                            "rate": {
                                                "type": "string",
                                                "example": "0"
                                            },
                                            "max_rate": {
                                                "type": "string",
                                                "example": "0"
                                            },
                                            "max_change_rate": {
                                                "type": "string",
                                                "example": "0"
                                            },
                                            "update_time": {
                                                "type": "string",
                                                "example": "1970-01-01T00:00:00Z"
                                            }
                                        }
                                    }
                                }
                            }
                        },
                        "examples": {
                            "application/json": [
                                {
                                    "operator_address": "cosmosvaloper16xyempempp92x9hyzz9wrgf94r6j9h5f2w4n2l",
                                    "consensus_pubkey": "cosmosvalconspub1zcjduepq0vu2zgkgk49efa0nqwzndanq5m4c7pa3u4apz4g2r9gspqg6g9cs3k9cuf",
                                    "jailed": true,
                                    "status": 0,
                                    "tokens": "string",
                                    "delegator_shares": "string",
                                    "description": {
                                        "moniker": "string",
                                        "identity": "string",
                                        "website": "string",
                                        "security_contact": "string",
                                        "details": "string"
                                    },
                                    "bond_height": "0",
                                    "bond_intra_tx_counter": 0,
                                    "unbonding_height": "0",
                                    "unbonding_time": "1970-01-01T00:00:00+00:00",
                                    "commission": {
                                        "rate": "0",
                                        "max_rate": "0",
                                        "max_change_rate": "0",
                                        "update_time": "1970-01-01T00:00:00+00:00"
                                    }
                                }
                            ]
                        }
                    },
                    "400": {
                        "description": "Invalid delegator address"
                    },
                    "500": {
                        "description": "Internal Server Error"
                    }
                }
            }
        },
        "/staking/delegators/{delegatorAddr}/validators/{validatorAddr}": {
            "get": {
                "description": "Query a validator that a delegator is bonded to",
                "operationId": "get-staking-delegators-delegatoraddr-validators-validatoraddr",
                "summary": "Query a validator that a delegator is bonded to",
                "tags": [
                    "Staking"
                ],
                "parameters": [
                    {
                        "name": "delegatorAddr",
                        "in": "path",
                        "description": "Bech32 AccAddress of Delegator",
                        "required": true,
                        "type": "string"
                    },
                    {
                        "name": "validatorAddr",
                        "in": "path",
                        "description": "Bech32 ValAddress of Delegator",
                        "required": true,
                        "type": "string"
                    }
                ],
                "produces": [
                    "application/json"
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "operator_address": {
                                    "description": "bech32 encoded address",
                                    "type": "string",
                                    "example": "cosmosvaloper16xyempempp92x9hyzz9wrgf94r6j9h5f2w4n2l"
                                },
                                "consensus_pubkey": {
                                    "type": "string",
                                    "example": "cosmosvalconspub1zcjduepq0vu2zgkgk49efa0nqwzndanq5m4c7pa3u4apz4g2r9gspqg6g9cs3k9cuf"
                                },
                                "jailed": {
                                    "type": "boolean"
                                },
                                "status": {
                                    "type": "integer"
                                },
                                "tokens": {
                                    "type": "string"
                                },
                                "delegator_shares": {
                                    "type": "string"
                                },
                                "description": {
                                    "type": "object",
                                    "properties": {
                                        "moniker": {
                                            "type": "string"
                                        },
                                        "identity": {
                                            "type": "string"
                                        },
                                        "website": {
                                            "type": "string"
                                        },
                                        "security_contact": {
                                            "type": "string"
                                        },
                                        "details": {
                                            "type": "string"
                                        }
                                    }
                                },
                                "bond_height": {
                                    "type": "string",
                                    "example": "0"
                                },
                                "bond_intra_tx_counter": {
                                    "type": "integer",
                                    "example": 0
                                },
                                "unbonding_height": {
                                    "type": "string",
                                    "example": "0"
                                },
                                "unbonding_time": {
                                    "type": "string",
                                    "example": "1970-01-01T00:00:00Z"
                                },
                                "commission": {
                                    "type": "object",
                                    "properties": {
                                        "rate": {
                                            "type": "string",
                                            "example": "0"
                                        },
                                        "max_rate": {
                                            "type": "string",
                                            "example": "0"
                                        },
                                        "max_change_rate": {
                                            "type": "string",
                                            "example": "0"
                                        },
                                        "update_time": {
                                            "type": "string",
                                            "example": "1970-01-01T00:00:00Z"
                                        }
                                    }
                                }
                            }
                        },
                        "examples": {
                            "application/json": {
                                "operator_address": "cosmosvaloper16xyempempp92x9hyzz9wrgf94r6j9h5f2w4n2l",
                                "consensus_pubkey": "cosmosvalconspub1zcjduepq0vu2zgkgk49efa0nqwzndanq5m4c7pa3u4apz4g2r9gspqg6g9cs3k9cuf",
                                "jailed": true,
                                "status": 0,
                                "tokens": "string",
                                "delegator_shares": "string",
                                "description": {
                                    "moniker": "string",
                                    "identity": "string",
                                    "website": "string",
                                    "security_contact": "string",
                                    "details": "string"
                                },
                                "bond_height": "0",
                                "bond_intra_tx_counter": 0,
                                "unbonding_height": "0",
                                "unbonding_time": "1970-01-01T00:00:00+00:00",
                                "commission": {
                                    "rate": "0",
                                    "max_rate": "0",
                                    "max_change_rate": "0",
                                    "update_time": "1970-01-01T00:00:00+00:00"
                                }
                            }
                        }
                    },
                    "400": {
                        "description": "Invalid delegator address or validator address"
                    },
                    "500": {
                        "description": "Internal Server Error"
                    }
                }
            }
        },
        "/staking/validators": {
            "get": {
                "description": "Get all validator candidates. By default it returns only the bonded validators.",
                "operationId": "get-staking-validators",
                "summary": "Get all validator candidates. By default it returns only the bonded validators.",
                "tags": [
                    "Staking"
                ],
                "parameters": [
                    {
                        "name": "status",
                        "in": "query",
                        "description": "The validator bond status. Must be either 'bonded', 'unbonded', or 'unbonding'.",
                        "type": "string"
                    },
                    {
                        "name": "page",
                        "in": "query",
                        "description": "The page number.",
                        "type": "integer"
                    },
                    {
                        "name": "limit",
                        "in": "query",
                        "description": "The maximum number of items per page.",
                        "type": "integer"
                    }
                ],
                "produces": [
                    "application/json"
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "type": "object",
                                "properties": {
                                    "operator_address": {
                                        "description": "bech32 encoded address",
                                        "type": "string",
                                        "example": "cosmosvaloper16xyempempp92x9hyzz9wrgf94r6j9h5f2w4n2l"
                                    },
                                    "consensus_pubkey": {
                                        "type": "string",
                                        "example": "cosmosvalconspub1zcjduepq0vu2zgkgk49efa0nqwzndanq5m4c7pa3u4apz4g2r9gspqg6g9cs3k9cuf"
                                    },
                                    "jailed": {
                                        "type": "boolean"
                                    },
                                    "status": {
                                        "type": "integer"
                                    },
                                    "tokens": {
                                        "type": "string"
                                    },
                                    "delegator_shares": {
                                        "type": "string"
                                    },
                                    "description": {
                                        "type": "object",
                                        "properties": {
                                            "moniker": {
                                                "type": "string"
                                            },
                                            "identity": {
                                                "type": "string"
                                            },
                                            "website": {
                                                "type": "string"
                                            },
                                            "security_contact": {
                                                "type": "string"
                                            },
                                            "details": {
                                                "type": "string"
                                            }
                                        }
                                    },
                                    "bond_height": {
                                        "type": "string",
                                        "example": "0"
                                    },
                                    "bond_intra_tx_counter": {
                                        "type": "integer",
                                        "example": 0
                                    },
                                    "unbonding_height": {
                                        "type": "string",
                                        "example": "0"
                                    },
                                    "unbonding_time": {
                                        "type": "string",
                                        "example": "1970-01-01T00:00:00Z"
                                    },
                                    "commission": {
                                        "type": "object",
                                        "properties": {
                                            "rate": {
                                                "type": "string",
                                                "example": "0"
                                            },
                                            "max_rate": {
                                                "type": "string",
                                                "example": "0"
                                            },
                                            "max_change_rate": {
                                                "type": "string",
                                                "example": "0"
                                            },
                                            "update_time": {
                                                "type": "string",
                                                "example": "1970-01-01T00:00:00Z"
                                            }
                                        }
                                    }
                                }
                            }
                        },
                        "examples": {
                            "application/json": [
                                {
                                    "operator_address": "cosmosvaloper16xyempempp92x9hyzz9wrgf94r6j9h5f2w4n2l",
                                    "consensus_pubkey": "cosmosvalconspub1zcjduepq0vu2zgkgk49efa0nqwzndanq5m4c7pa3u4apz4g2r9gspqg6g9cs3k9cuf",
                                    "jailed": true,
                                    "status": 0,
                                    "tokens": "string",
                                    "delegator_shares": "string",
                                    "description": {
                                        "moniker": "string",
                                        "identity": "string",
                                        "website": "string",
                                        "security_contact": "string",
                                        "details": "string"
                                    },
                                    "bond_height": "0",
                                    "bond_intra_tx_counter": 0,
                                    "unbonding_height": "0",
                                    "unbonding_time": "1970-01-01T00:00:00+00:00",
                                    "commission": {
                                        "rate": "0",
                                        "max_rate": "0",
                                        "max_change_rate": "0",
                                        "update_time": "1970-01-01T00:00:00+00:00"
                                    }
                                }
                            ]
                        }
                    },
                    "500": {
                        "description": "Internal Server Error"
                    }
                }
            }
        },
        "/staking/validators/{validatorAddr}/delegations": {
            "get": {
                "description": "Get all delegations from a validator",
                "operationId": "get-staking-validators-validatoraddr-delegations",
                "summary": "Get all delegations from a validator",
                "tags": [
                    "Staking"
                ],
                "parameters": [
                    {
                        "name": "validatorAddr",
                        "in": "path",
                        "description": "Bech32 OperatorAddress of validator",
                        "required": true,
                        "type": "string"
                    }
                ],
                "produces": [
                    "application/json"
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "type": "object",
                                "properties": {
                                    "delegator_address": {
                                        "type": "string"
                                    },
                                    "validator_address": {
                                        "type": "string"
                                    },
                                    "shares": {
                                        "type": "string"
                                    },
                                    "balance": {
                                        "type": "object",
                                        "properties": {
                                            "denom": {
                                                "type": "string",
                                                "example": "stake"
                                            },
                                            "amount": {
                                                "type": "string",
                                                "example": "50"
                                            }
                                        }
                                    }
                                }
                            }
                        },
                        "examples": {
                            "application/json": [
                                {
                                    "delegator_address": "string",
                                    "validator_address": "string",
                                    "shares": "string",
                                    "balance": {
                                        "denom": "stake",
                                        "amount": "50"
                                    }
                                }
                            ]
                        }
                    },
                    "400": {
                        "description": "Invalid validator address"
                    },
                    "500": {
                        "description": "Internal Server Error"
                    }
                }
            }
        },
        "/staking/validators/{validatorAddr}/unbonding_delegations": {
            "get": {
                "description": "Get all unbonding delegations from a validator",
                "operationId": "get-staking-validators-validatoraddr-unbonding_delegations",
                "summary": "Get all unbonding delegations from a validator",
                "tags": [
                    "Staking"
                ],
                "parameters": [
                    {
                        "name": "validatorAddr",
                        "in": "path",
                        "description": "Bech32 OperatorAddress of validator",
                        "required": true,
                        "type": "string"
                    }
                ],
                "produces": [
                    "application/json"
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "type": "object",
                                "properties": {
                                    "delegator_address": {
                                        "type": "string"
                                    },
                                    "validator_address": {
                                        "type": "string"
                                    },
                                    "initial_balance": {
                                        "type": "string"
                                    },
                                    "balance": {
                                        "type": "string"
                                    },
                                    "creation_height": {
                                        "type": "integer"
                                    },
                                    "min_time": {
                                        "type": "integer"
                                    }
                                }
                            }
                        },
                        "examples": {
                            "application/json": [
                                {
                                    "delegator_address": "string",
                                    "validator_address": "string",
                                    "initial_balance": "string",
                                    "balance": "string",
                                    "creation_height": 0,
                                    "min_time": 0
                                }
                            ]
                        }
                    },
                    "400": {
                        "description": "Invalid validator address"
                    },
                    "500": {
                        "description": "Internal Server Error"
                    }
                }
            }
        },
        "/staking/pool": {
            "get": {
                "description": "Get the current state of the staking pool",
                "operationId": "get-staking-pool",
                "summary": "Get the current state of the staking pool",
                "tags": [
                    "Staking"
                ],
                "produces": [
                    "application/json"
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "height": {
                                  "type": "string"
                                },
                                "result": {
                                    "type": "object",
                                    "properties": {
                                        "not_bonded_tokens": {
                                            "type": "string"
                                        },
                                        "bonded_tokens": {
                                            "type": "string"
                                        },
                                        "loose_tokens": {
                                            "type": "string"
                                        },
                                        "inflation_last_time": {
                                            "type": "string"
                                        },
                                        "inflation": {
                                            "type": "string"
                                        },
                                        "date_last_commission_reset": {
                                            "type": "string"
                                        },
                                        "prev_bonded_shares": {
                                            "type": "string"
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "500": {
                        "description": "Internal Server Error"
                    }
                }
            }
        },
        "/staking/parameters": {
            "get": {
                "description": "Get the current staking parameter values",
                "operationId": "get-staking-parameters",
                "summary": "Get the current staking parameter values",
                "tags": [
                    "Staking"
                ],
                "produces": [
                    "application/json"
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "inflation_rate_change": {
                                    "type": "string"
                                },
                                "inflation_max": {
                                    "type": "string"
                                },
                                "inflation_min": {
                                    "type": "string"
                                },
                                "goal_bonded": {
                                    "type": "string"
                                },
                                "unbonding_time": {
                                    "type": "string"
                                },
                                "max_validators": {
                                    "type": "integer"
                                },
                                "bond_denom": {
                                    "type": "string"
                                }
                            }
                        },
                        "examples": {
                            "application/json": {
                                "inflation_rate_change": "string",
                                "inflation_max": "string",
                                "inflation_min": "string",
                                "goal_bonded": "string",
                                "unbonding_time": "string",
                                "max_validators": 0,
                                "bond_denom": "string"
                            }
                        }
                    },
                    "500": {
                        "description": "Internal Server Error"
                    }
                }
            }
        },
        "/slashing/signing_infos": {
            "get": {
                "description": "Get sign info of all validators",
                "operationId": "get-slashing-signing_infos-page-page-limit-limit",
                "summary": "Get sign info of given all validators",
                "tags": [
                    "Slashing"
                ],
                "parameters": [
                    {
                        "name": "page",
                        "in": "query",
                        "description": "Page number",
                        "required": true,
                        "type": "integer"
                    },
                    {
                        "name": "limit",
                        "in": "query",
                        "description": "Maximum number of items per page",
                        "required": true,
                        "type": "integer"
                    }
                ],
                "produces": [
                    "application/json"
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "type": "object",
                                "properties": {
                                    "start_height": {
                                        "type": "string"
                                    },
                                    "index_offset": {
                                        "type": "string"
                                    },
                                    "jailed_until": {
                                        "type": "string"
                                    },
                                    "missed_blocks_counter": {
                                        "type": "string"
                                    }
                                }
                            }
                        },
                        "examples": {
                            "application/json": [
                                {
                                    "start_height": "string",
                                    "index_offset": "string",
                                    "jailed_until": "string",
                                    "missed_blocks_counter": "string"
                                }
                            ]
                        }
                    },
                    "400": {
                        "description": "Invalid validator public key for one of the validators"
                    },
                    "500": {
                        "description": "Internal Server Error"
                    }
                }
            }
        },
        "/slashing/validators/{validatorAddr}/unjail": {
            "post": {
                "description": "Send transaction to unjail a jailed validator",
                "operationId": "post-slashing-validators-validatoraddr-unjail",
                "summary": "Unjail a jailed validator",
                "tags": [
                    "Slashing"
                ],
                "parameters": [
                    {
                        "name": "validatorAddr",
                        "in": "path",
                        "description": "Bech32 validator address",
                        "required": true,
                        "type": "string"
                    },
                    {
                        "name": "slashingValidators-validatorAddr-UnjailPostRequest-1",
                        "in": "body",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "base_req": {
                                    "type": "object",
                                    "properties": {
                                        "msg": {
                                            "type": "array",
                                            "items": {
                                                "type": "string"
                                            }
                                        },
                                        "fee": {
                                            "type": "object",
                                            "properties": {
                                                "gas": {
                                                    "type": "string"
                                                },
                                                "amount": {
                                                    "type": "array",
                                                    "items": {
                                                        "type": "object",
                                                        "properties": {
                                                            "denom": {
                                                                "type": "string",
                                                                "example": "stake"
                                                            },
                                                            "amount": {
                                                                "type": "string",
                                                                "example": "50"
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        },
                                        "memo": {
                                            "type": "string"
                                        },
                                        "signature": {
                                            "type": "object",
                                            "properties": {
                                                "signature": {
                                                    "type": "string",
                                                    "example": "MEUCIQD02fsDPra8MtbRsyB1w7bqTM55Wu138zQbFcWx4+CFyAIge5WNPfKIuvzBZ69MyqHsqD8S1IwiEp+iUb6VSdtlpgY="
                                                },
                                                "pub_key": {
                                                    "type": "object",
                                                    "properties": {
                                                        "type": {
                                                            "type": "string",
                                                            "example": "tendermint/PubKeySecp256k1"
                                                        },
                                                        "value": {
                                                            "type": "string",
                                                            "example": "Avz04VhtKJh8ACCVzlI8aTosGy0ikFXKIVHQ3jKMrosH"
                                                        }
                                                    }
                                                },
                                                "account_number": {
                                                    "type": "string",
                                                    "example": "0"
                                                },
                                                "sequence": {
                                                    "type": "string",
                                                    "example": "0"
                                                }
                                            }
                                        }
                                    }
                                }
                            },
                            "example": {
                                "base_req": {
                                    "msg": [
                                        "string"
                                    ],
                                    "fee": {
                                        "gas": "string",
                                        "amount": [
                                            {
                                                "denom": "stake",
                                                "amount": "50"
                                            }
                                        ]
                                    },
                                    "memo": "string",
                                    "signature": {
                                        "signature": "MEUCIQD02fsDPra8MtbRsyB1w7bqTM55Wu138zQbFcWx4+CFyAIge5WNPfKIuvzBZ69MyqHsqD8S1IwiEp+iUb6VSdtlpgY=",
                                        "pub_key": {
                                            "type": "tendermint/PubKeySecp256k1",
                                            "value": "Avz04VhtKJh8ACCVzlI8aTosGy0ikFXKIVHQ3jKMrosH"
                                        },
                                        "account_number": "0",
                                        "sequence": "0"
                                    }
                                }
                            }
                        }
                    }
                ],
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "responses": {
                    "200": {
                        "description": "Tx was succesfully generated",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "msg": {
                                    "type": "array",
                                    "items": {
                                        "type": "string"
                                    }
                                },
                                "fee": {
                                    "type": "object",
                                    "properties": {
                                        "gas": {
                                            "type": "string"
                                        },
                                        "amount": {
                                            "type": "array",
                                            "items": {
                                                "type": "object",
                                                "properties": {
                                                    "denom": {
                                                        "type": "string",
                                                        "example": "stake"
                                                    },
                                                    "amount": {
                                                        "type": "string",
                                                        "example": "50"
                                                    }
                                                }
                                            }
                                        }
                                    }
                                },
                                "memo": {
                                    "type": "string"
                                },
                                "signature": {
                                    "type": "object",
                                    "properties": {
                                        "signature": {
                                            "type": "string",
                                            "example": "MEUCIQD02fsDPra8MtbRsyB1w7bqTM55Wu138zQbFcWx4+CFyAIge5WNPfKIuvzBZ69MyqHsqD8S1IwiEp+iUb6VSdtlpgY="
                                        },
                                        "pub_key": {
                                            "type": "object",
                                            "properties": {
                                                "type": {
                                                    "type": "string",
                                                    "example": "tendermint/PubKeySecp256k1"
                                                },
                                                "value": {
                                                    "type": "string",
                                                    "example": "Avz04VhtKJh8ACCVzlI8aTosGy0ikFXKIVHQ3jKMrosH"
                                                }
                                            }
                                        },
                                        "account_number": {
                                            "type": "string",
                                            "example": "0"
                                        },
                                        "sequence": {
                                            "type": "string",
                                            "example": "0"
                                        }
                                    }
                                }
                            }
                        },
                        "examples": {
                            "application/json": {
                                "msg": [
                                    "string"
                                ],
                                "fee": {
                                    "gas": "string",
                                    "amount": [
                                        {
                                            "denom": "stake",
                                            "amount": "50"
                                        }
                                    ]
                                },
                                "memo": "string",
                                "signature": {
                                    "signature": "MEUCIQD02fsDPra8MtbRsyB1w7bqTM55Wu138zQbFcWx4+CFyAIge5WNPfKIuvzBZ69MyqHsqD8S1IwiEp+iUb6VSdtlpgY=",
                                    "pub_key": {
                                        "type": "tendermint/PubKeySecp256k1",
                                        "value": "Avz04VhtKJh8ACCVzlI8aTosGy0ikFXKIVHQ3jKMrosH"
                                    },
                                    "account_number": "0",
                                    "sequence": "0"
                                }
                            }
                        }
                    },
                    "400": {
                        "description": "Invalid validator address or base_req"
                    },
                    "500": {
                        "description": "Internal Server Error"
                    }
                }
            }
        },
        "/slashing/parameters": {
            "get": {
                "description": "Get the current slashing parameters",
                "operationId": "get-slashing-parameters",
                "summary": "Get the current slashing parameters",
                "tags": [
                    "Slashing"
                ],
                "produces": [
                    "application/json"
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "max_evidence_age": {
                                    "type": "string"
                                },
                                "signed_blocks_window": {
                                    "type": "string"
                                },
                                "min_signed_per_window": {
                                    "type": "string"
                                },
                                "double_sign_unbond_duration": {
                                    "type": "string"
                                },
                                "downtime_unbond_duration": {
                                    "type": "string"
                                },
                                "slash_fraction_double_sign": {
                                    "type": "string"
                                },
                                "slash_fraction_downtime": {
                                    "type": "string"
                                }
                            }
                        },
                        "examples": {
                            "application/json": {
                                "max_evidence_age": "string",
                                "signed_blocks_window": "string",
                                "min_signed_per_window": "string",
                                "double_sign_unbond_duration": "string",
                                "downtime_unbond_duration": "string",
                                "slash_fraction_double_sign": "string",
                                "slash_fraction_downtime": "string"
                            }
                        }
                    },
                    "500": {
                        "description": "Internal Server Error"
                    }
                }
            }
        },
        "/gov/proposals": {
            "post": {
                "description": "Send transaction to submit a proposal",
                "operationId": "post-gov-proposals",
                "summary": "Submit a proposal",
                "tags": [
                    "Governance"
                ],
                "parameters": [
                    {
                        "name": "govProposalsPostRequest",
                        "in": "body",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "base_req": {
                                    "type": "object",
                                    "properties": {
                                        "from": {
                                            "description": "Sender address or Keybase name to generate a transaction",
                                            "type": "string",
                                            "example": "cosmos1g9ahr6xhht5rmqven628nklxluzyv8z9jqjcmc"
                                        },
                                        "memo": {
                                            "type": "string",
                                            "example": "Sent via Cosmos Voyager ðŸš€"
                                        },
                                        "chain_id": {
                                            "type": "string",
                                            "example": "Cosmos-Hub"
                                        },
                                        "account_number": {
                                            "type": "string",
                                            "example": "0"
                                        },
                                        "sequence": {
                                            "type": "string",
                                            "example": "1"
                                        },
                                        "gas": {
                                            "type": "string",
                                            "example": "200000"
                                        },
                                        "gas_adjustment": {
                                            "type": "string",
                                            "example": "1.2"
                                        },
                                        "fees": {
                                            "type": "array",
                                            "items": {
                                                "type": "object",
                                                "properties": {
                                                    "denom": {
                                                        "type": "string",
                                                        "example": "stake"
                                                    },
                                                    "amount": {
                                                        "type": "string",
                                                        "example": "50"
                                                    }
                                                }
                                            }
                                        },
                                        "simulate": {
                                            "description": "Estimate gas for a transaction (cannot be used in conjunction with generate_only)",
                                            "type": "boolean",
                                            "example": false
                                        }
                                    }
                                },
                                "title": {
                                    "type": "string"
                                },
                                "description": {
                                    "type": "string"
                                },
                                "proposal_type": {
                                    "type": "string",
                                    "example": "text"
                                },
                                "proposer": {
                                    "description": "bech32 encoded address",
                                    "type": "string",
                                    "example": "cosmos1depk54cuajgkzea6zpgkq36tnjwdzv4afc3d27"
                                },
                                "initial_deposit": {
                                    "type": "array",
                                    "items": {
                                        "type": "object",
                                        "properties": {
                                            "denom": {
                                                "type": "string",
                                                "example": "stake"
                                            },
                                            "amount": {
                                                "type": "string",
                                                "example": "50"
                                            }
                                        }
                                    }
                                }
                            },
                            "example": {
                                "base_req": {
                                    "from": "cosmos1g9ahr6xhht5rmqven628nklxluzyv8z9jqjcmc",
                                    "memo": "Sent via Cosmos Voyager ðŸš€",
                                    "chain_id": "Cosmos-Hub",
                                    "account_number": "0",
                                    "sequence": "1",
                                    "gas": "200000",
                                    "gas_adjustment": "2022-01-02",
                                    "fees": [
                                        {
                                            "denom": "stake",
                                            "amount": "50"
                                        }
                                    ],
                                    "simulate": false
                                },
                                "title": "string",
                                "description": "string",
                                "proposal_type": "text",
                                "proposer": "cosmos1depk54cuajgkzea6zpgkq36tnjwdzv4afc3d27",
                                "initial_deposit": [
                                    {
                                        "denom": "stake",
                                        "amount": "50"
                                    }
                                ]
                            }
                        },
                        "description": "valid value of `\"proposal_type\"` can be `\"text\"`, `\"parameter_change\"`, `\"software_upgrade\"`"
                    }
                ],
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "responses": {
                    "200": {
                        "description": "Tx was succesfully generated",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "msg": {
                                    "type": "array",
                                    "items": {
                                        "type": "string"
                                    }
                                },
                                "fee": {
                                    "type": "object",
                                    "properties": {
                                        "gas": {
                                            "type": "string"
                                        },
                                        "amount": {
                                            "type": "array",
                                            "items": {
                                                "type": "object",
                                                "properties": {
                                                    "denom": {
                                                        "type": "string",
                                                        "example": "stake"
                                                    },
                                                    "amount": {
                                                        "type": "string",
                                                        "example": "50"
                                                    }
                                                }
                                            }
                                        }
                                    }
                                },
                                "memo": {
                                    "type": "string"
                                },
                                "signature": {
                                    "type": "object",
                                    "properties": {
                                        "signature": {
                                            "type": "string",
                                            "example": "MEUCIQD02fsDPra8MtbRsyB1w7bqTM55Wu138zQbFcWx4+CFyAIge5WNPfKIuvzBZ69MyqHsqD8S1IwiEp+iUb6VSdtlpgY="
                                        },
                                        "pub_key": {
                                            "type": "object",
                                            "properties": {
                                                "type": {
                                                    "type": "string",
                                                    "example": "tendermint/PubKeySecp256k1"
                                                },
                                                "value": {
                                                    "type": "string",
                                                    "example": "Avz04VhtKJh8ACCVzlI8aTosGy0ikFXKIVHQ3jKMrosH"
                                                }
                                            }
                                        },
                                        "account_number": {
                                            "type": "string",
                                            "example": "0"
                                        },
                                        "sequence": {
                                            "type": "string",
                                            "example": "0"
                                        }
                                    }
                                }
                            }
                        },
                        "examples": {
                            "application/json": {
                                "msg": [
                                    "string"
                                ],
                                "fee": {
                                    "gas": "string",
                                    "amount": [
                                        {
                                            "denom": "stake",
                                            "amount": "50"
                                        }
                                    ]
                                },
                                "memo": "string",
                                "signature": {
                                    "signature": "MEUCIQD02fsDPra8MtbRsyB1w7bqTM55Wu138zQbFcWx4+CFyAIge5WNPfKIuvzBZ69MyqHsqD8S1IwiEp+iUb6VSdtlpgY=",
                                    "pub_key": {
                                        "type": "tendermint/PubKeySecp256k1",
                                        "value": "Avz04VhtKJh8ACCVzlI8aTosGy0ikFXKIVHQ3jKMrosH"
                                    },
                                    "account_number": "0",
                                    "sequence": "0"
                                }
                            }
                        }
                    },
                    "400": {
                        "description": "Invalid proposal body"
                    },
                    "500": {
                        "description": "Internal Server Error"
                    }
                }
            },
            "get": {
                "description": "Query proposals information with parameters",
                "operationId": "get-gov-proposals",
                "summary": "Query proposals",
                "tags": [
                    "Governance"
                ],
                "parameters": [
                    {
                        "name": "voter",
                        "in": "query",
                        "description": "voter address",
                        "type": "string"
                    },
                    {
                        "name": "depositor",
                        "in": "query",
                        "description": "depositor address",
                        "type": "string"
                    },
                    {
                        "name": "status",
                        "in": "query",
                        "description": "proposal status, valid values can be `\"deposit_period\"`, `\"voting_period\"`, `\"passed\"`, `\"rejected\"`",
                        "type": "string"
                    }
                ],
                "produces": [
                    "application/json"
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "type": "object",
                                "properties": {
                                    "proposal_id": {
                                        "type": "integer"
                                    },
                                    "title": {
                                        "type": "string"
                                    },
                                    "description": {
                                        "type": "string"
                                    },
                                    "proposal_type": {
                                        "type": "string"
                                    },
                                    "proposal_status": {
                                        "type": "string"
                                    },
                                    "final_tally_result": {
                                        "type": "object",
                                        "properties": {
                                            "yes": {
                                                "type": "string",
                                                "example": "0.0000000000"
                                            },
                                            "abstain": {
                                                "type": "string",
                                                "example": "0.0000000000"
                                            },
                                            "no": {
                                                "type": "string",
                                                "example": "0.0000000000"
                                            },
                                            "no_with_veto": {
                                                "type": "string",
                                                "example": "0.0000000000"
                                            }
                                        }
                                    },
                                    "submit_time": {
                                        "type": "string"
                                    },
                                    "total_deposit": {
                                        "type": "array",
                                        "items": {
                                            "type": "object",
                                            "properties": {
                                                "denom": {
                                                    "type": "string",
                                                    "example": "stake"
                                                },
                                                "amount": {
                                                    "type": "string",
                                                    "example": "50"
                                                }
                                            }
                                        }
                                    },
                                    "voting_start_time": {
                                        "type": "string"
                                    }
                                }
                            }
                        },
                        "examples": {
                            "application/json": [
                                {
                                    "proposal_id": 0,
                                    "title": "string",
                                    "description": "string",
                                    "proposal_type": "string",
                                    "proposal_status": "string",
                                    "final_tally_result": {
                                        "yes": "0.0000000000",
                                        "abstain": "0.0000000000",
                                        "no": "0.0000000000",
                                        "no_with_veto": "0.0000000000"
                                    },
                                    "submit_time": "string",
                                    "total_deposit": [
                                        {
                                            "denom": "stake",
                                            "amount": "50"
                                        }
                                    ],
                                    "voting_start_time": "string"
                                }
                            ]
                        }
                    },
                    "400": {
                        "description": "Invalid query parameters"
                    },
                    "500": {
                        "description": "Internal Server Error"
                    }
                }
            }
        },
        "/gov/proposals/param_change": {
            "post": {
                "description": "Generate a parameter change proposal transaction",
                "operationId": "post-gov-proposals-param_change",
                "summary": "Generate a parameter change proposal transaction",
                "tags": [
                    "Governance"
                ],
                "parameters": [
                    {
                        "name": "govProposalsParam_changePostRequest",
                        "in": "body",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "base_req": {
                                    "type": "object",
                                    "properties": {
                                        "from": {
                                            "description": "Sender address or Keybase name to generate a transaction",
                                            "type": "string",
                                            "example": "cosmos1g9ahr6xhht5rmqven628nklxluzyv8z9jqjcmc"
                                        },
                                        "memo": {
                                            "type": "string",
                                            "example": "Sent via Cosmos Voyager ðŸš€"
                                        },
                                        "chain_id": {
                                            "type": "string",
                                            "example": "Cosmos-Hub"
                                        },
                                        "account_number": {
                                            "type": "string",
                                            "example": "0"
                                        },
                                        "sequence": {
                                            "type": "string",
                                            "example": "1"
                                        },
                                        "gas": {
                                            "type": "string",
                                            "example": "200000"
                                        },
                                        "gas_adjustment": {
                                            "type": "string",
                                            "example": "1.2"
                                        },
                                        "fees": {
                                            "type": "array",
                                            "items": {
                                                "type": "object",
                                                "properties": {
                                                    "denom": {
                                                        "type": "string",
                                                        "example": "stake"
                                                    },
                                                    "amount": {
                                                        "type": "string",
                                                        "example": "50"
                                                    }
                                                }
                                            }
                                        },
                                        "simulate": {
                                            "description": "Estimate gas for a transaction (cannot be used in conjunction with generate_only)",
                                            "type": "boolean",
                                            "example": false
                                        }
                                    }
                                },
                                "title": {
                                    "type": "string"
                                },
                                "description": {
                                    "type": "string"
                                },
                                "proposer": {
                                    "description": "bech32 encoded address",
                                    "type": "string",
                                    "example": "cosmos1depk54cuajgkzea6zpgkq36tnjwdzv4afc3d27"
                                },
                                "deposit": {
                                    "type": "array",
                                    "items": {
                                        "type": "object",
                                        "properties": {
                                            "denom": {
                                                "type": "string",
                                                "example": "stake"
                                            },
                                            "amount": {
                                                "type": "string",
                                                "example": "50"
                                            }
                                        }
                                    }
                                },
                                "changes": {
                                    "type": "array",
                                    "items": {
                                        "type": "object",
                                        "properties": {
                                            "subspace": {
                                                "type": "string",
                                                "example": "staking"
                                            },
                                            "key": {
                                                "type": "string",
                                                "example": "MaxValidators"
                                            },
                                            "subkey": {
                                                "type": "string",
                                                "example": ""
                                            },
                                            "value": {
                                                "type": "object"
                                            }
                                        }
                                    }
                                }
                            },
                            "example": {
                                "base_req": {
                                    "from": "cosmos1g9ahr6xhht5rmqven628nklxluzyv8z9jqjcmc",
                                    "memo": "Sent via Cosmos Voyager ðŸš€",
                                    "chain_id": "Cosmos-Hub",
                                    "account_number": "0",
                                    "sequence": "1",
                                    "gas": "200000",
                                    "gas_adjustment": "2022-01-02",
                                    "fees": [
                                        {
                                            "denom": "stake",
                                            "amount": "50"
                                        }
                                    ],
                                    "simulate": false
                                },
                                "title": "string",
                                "description": "string",
                                "proposer": "cosmos1depk54cuajgkzea6zpgkq36tnjwdzv4afc3d27",
                                "deposit": [
                                    {
                                        "denom": "stake",
                                        "amount": "50"
                                    }
                                ],
                                "changes": [
                                    {
                                        "subspace": "staking",
                                        "key": "MaxValidators",
                                        "subkey": "",
                                        "value": {}
                                    }
                                ]
                            }
                        },
                        "description": "The parameter change proposal body that contains all parameter changes"
                    }
                ],
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "responses": {
                    "200": {
                        "description": "The transaction was succesfully generated",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "msg": {
                                    "type": "array",
                                    "items": {
                                        "type": "string"
                                    }
                                },
                                "fee": {
                                    "type": "object",
                                    "properties": {
                                        "gas": {
                                            "type": "string"
                                        },
                                        "amount": {
                                            "type": "array",
                                            "items": {
                                                "type": "object",
                                                "properties": {
                                                    "denom": {
                                                        "type": "string",
                                                        "example": "stake"
                                                    },
                                                    "amount": {
                                                        "type": "string",
                                                        "example": "50"
                                                    }
                                                }
                                            }
                                        }
                                    }
                                },
                                "memo": {
                                    "type": "string"
                                },
                                "signature": {
                                    "type": "object",
                                    "properties": {
                                        "signature": {
                                            "type": "string",
                                            "example": "MEUCIQD02fsDPra8MtbRsyB1w7bqTM55Wu138zQbFcWx4+CFyAIge5WNPfKIuvzBZ69MyqHsqD8S1IwiEp+iUb6VSdtlpgY="
                                        },
                                        "pub_key": {
                                            "type": "object",
                                            "properties": {
                                                "type": {
                                                    "type": "string",
                                                    "example": "tendermint/PubKeySecp256k1"
                                                },
                                                "value": {
                                                    "type": "string",
                                                    "example": "Avz04VhtKJh8ACCVzlI8aTosGy0ikFXKIVHQ3jKMrosH"
                                                }
                                            }
                                        },
                                        "account_number": {
                                            "type": "string",
                                            "example": "0"
                                        },
                                        "sequence": {
                                            "type": "string",
                                            "example": "0"
                                        }
                                    }
                                }
                            }
                        },
                        "examples": {
                            "application/json": {
                                "msg": [
                                    "string"
                                ],
                                "fee": {
                                    "gas": "string",
                                    "amount": [
                                        {
                                            "denom": "stake",
                                            "amount": "50"
                                        }
                                    ]
                                },
                                "memo": "string",
                                "signature": {
                                    "signature": "MEUCIQD02fsDPra8MtbRsyB1w7bqTM55Wu138zQbFcWx4+CFyAIge5WNPfKIuvzBZ69MyqHsqD8S1IwiEp+iUb6VSdtlpgY=",
                                    "pub_key": {
                                        "type": "tendermint/PubKeySecp256k1",
                                        "value": "Avz04VhtKJh8ACCVzlI8aTosGy0ikFXKIVHQ3jKMrosH"
                                    },
                                    "account_number": "0",
                                    "sequence": "0"
                                }
                            }
                        }
                    },
                    "400": {
                        "description": "Invalid proposal body"
                    },
                    "500": {
                        "description": "Internal Server Error"
                    }
                }
            }
        },
        "/gov/proposals/{proposalId}": {
            "get": {
                "description": "Query a proposal by id",
                "operationId": "get-gov-proposals-proposalid",
                "summary": "Query a proposal",
                "tags": [
                    "Governance"
                ],
                "parameters": [
                    {
                        "name": "proposalId",
                        "in": "path",
                        "required": true,
                        "type": "string"
                    }
                ],
                "produces": [
                    "application/json"
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "proposal_id": {
                                    "type": "integer"
                                },
                                "title": {
                                    "type": "string"
                                },
                                "description": {
                                    "type": "string"
                                },
                                "proposal_type": {
                                    "type": "string"
                                },
                                "proposal_status": {
                                    "type": "string"
                                },
                                "final_tally_result": {
                                    "type": "object",
                                    "properties": {
                                        "yes": {
                                            "type": "string",
                                            "example": "0.0000000000"
                                        },
                                        "abstain": {
                                            "type": "string",
                                            "example": "0.0000000000"
                                        },
                                        "no": {
                                            "type": "string",
                                            "example": "0.0000000000"
                                        },
                                        "no_with_veto": {
                                            "type": "string",
                                            "example": "0.0000000000"
                                        }
                                    }
                                },
                                "submit_time": {
                                    "type": "string"
                                },
                                "total_deposit": {
                                    "type": "array",
                                    "items": {
                                        "type": "object",
                                        "properties": {
                                            "denom": {
                                                "type": "string",
                                                "example": "stake"
                                            },
                                            "amount": {
                                                "type": "string",
                                                "example": "50"
                                            }
                                        }
                                    }
                                },
                                "voting_start_time": {
                                    "type": "string"
                                }
                            }
                        },
                        "examples": {
                            "application/json": {
                                "proposal_id": 0,
                                "title": "string",
                                "description": "string",
                                "proposal_type": "string",
                                "proposal_status": "string",
                                "final_tally_result": {
                                    "yes": "0.0000000000",
                                    "abstain": "0.0000000000",
                                    "no": "0.0000000000",
                                    "no_with_veto": "0.0000000000"
                                },
                                "submit_time": "string",
                                "total_deposit": [
                                    {
                                        "denom": "stake",
                                        "amount": "50"
                                    }
                                ],
                                "voting_start_time": "string"
                            }
                        }
                    },
                    "400": {
                        "description": "Invalid proposal id"
                    },
                    "500": {
                        "description": "Internal Server Error"
                    }
                }
            }
        },
        "/gov/proposals/{proposalId}/deposits": {
            "get": {
                "description": "Query deposits by proposalId",
                "operationId": "get-gov-proposals-proposalid-deposits",
                "summary": "Query deposits",
                "tags": [
                    "Governance"
                ],
                "parameters": [
                    {
                        "name": "proposalId",
                        "in": "path",
                        "required": true,
                        "type": "string"
                    }
                ],
                "produces": [
                    "application/json"
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "type": "object",
                                "properties": {
                                    "amount": {
                                        "type": "array",
                                        "items": {
                                            "type": "object",
                                            "properties": {
                                                "denom": {
                                                    "type": "string",
                                                    "example": "stake"
                                                },
                                                "amount": {
                                                    "type": "string",
                                                    "example": "50"
                                                }
                                            }
                                        }
                                    },
                                    "proposal_id": {
                                        "type": "string"
                                    },
                                    "depositor": {
                                        "description": "bech32 encoded address",
                                        "type": "string",
                                        "example": "cosmos1depk54cuajgkzea6zpgkq36tnjwdzv4afc3d27"
                                    }
                                }
                            }
                        },
                        "examples": {
                            "application/json": [
                                {
                                    "amount": [
                                        {
                                            "denom": "stake",
                                            "amount": "50"
                                        }
                                    ],
                                    "proposal_id": "string",
                                    "depositor": "cosmos1depk54cuajgkzea6zpgkq36tnjwdzv4afc3d27"
                                }
                            ]
                        }
                    },
                    "400": {
                        "description": "Invalid proposal id"
                    },
                    "500": {
                        "description": "Internal Server Error"
                    }
                }
            },
            "post": {
                "description": "Send transaction to deposit tokens to a proposal",
                "operationId": "post-gov-proposals-proposalid-deposits",
                "summary": "Deposit tokens to a proposal",
                "tags": [
                    "Governance"
                ],
                "parameters": [
                    {
                        "name": "proposalId",
                        "in": "path",
                        "description": "proposal id",
                        "required": true,
                        "type": "string"
                    },
                    {
                        "name": "govProposals-proposalId-DepositsPostRequest-1",
                        "in": "body",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "base_req": {
                                    "type": "object",
                                    "properties": {
                                        "from": {
                                            "description": "Sender address or Keybase name to generate a transaction",
                                            "type": "string",
                                            "example": "cosmos1g9ahr6xhht5rmqven628nklxluzyv8z9jqjcmc"
                                        },
                                        "memo": {
                                            "type": "string",
                                            "example": "Sent via Cosmos Voyager ðŸš€"
                                        },
                                        "chain_id": {
                                            "type": "string",
                                            "example": "Cosmos-Hub"
                                        },
                                        "account_number": {
                                            "type": "string",
                                            "example": "0"
                                        },
                                        "sequence": {
                                            "type": "string",
                                            "example": "1"
                                        },
                                        "gas": {
                                            "type": "string",
                                            "example": "200000"
                                        },
                                        "gas_adjustment": {
                                            "type": "string",
                                            "example": "1.2"
                                        },
                                        "fees": {
                                            "type": "array",
                                            "items": {
                                                "type": "object",
                                                "properties": {
                                                    "denom": {
                                                        "type": "string",
                                                        "example": "stake"
                                                    },
                                                    "amount": {
                                                        "type": "string",
                                                        "example": "50"
                                                    }
                                                }
                                            }
                                        },
                                        "simulate": {
                                            "description": "Estimate gas for a transaction (cannot be used in conjunction with generate_only)",
                                            "type": "boolean",
                                            "example": false
                                        }
                                    }
                                },
                                "depositor": {
                                    "description": "bech32 encoded address",
                                    "type": "string",
                                    "example": "cosmos1depk54cuajgkzea6zpgkq36tnjwdzv4afc3d27"
                                },
                                "amount": {
                                    "type": "array",
                                    "items": {
                                        "type": "object",
                                        "properties": {
                                            "denom": {
                                                "type": "string",
                                                "example": "stake"
                                            },
                                            "amount": {
                                                "type": "string",
                                                "example": "50"
                                            }
                                        }
                                    }
                                }
                            },
                            "example": {
                                "base_req": {
                                    "from": "cosmos1g9ahr6xhht5rmqven628nklxluzyv8z9jqjcmc",
                                    "memo": "Sent via Cosmos Voyager ðŸš€",
                                    "chain_id": "Cosmos-Hub",
                                    "account_number": "0",
                                    "sequence": "1",
                                    "gas": "200000",
                                    "gas_adjustment": "2022-01-02",
                                    "fees": [
                                        {
                                            "denom": "stake",
                                            "amount": "50"
                                        }
                                    ],
                                    "simulate": false
                                },
                                "depositor": "cosmos1depk54cuajgkzea6zpgkq36tnjwdzv4afc3d27",
                                "amount": [
                                    {
                                        "denom": "stake",
                                        "amount": "50"
                                    }
                                ]
                            }
                        }
                    }
                ],
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "msg": {
                                    "type": "array",
                                    "items": {
                                        "type": "string"
                                    }
                                },
                                "fee": {
                                    "type": "object",
                                    "properties": {
                                        "gas": {
                                            "type": "string"
                                        },
                                        "amount": {
                                            "type": "array",
                                            "items": {
                                                "type": "object",
                                                "properties": {
                                                    "denom": {
                                                        "type": "string",
                                                        "example": "stake"
                                                    },
                                                    "amount": {
                                                        "type": "string",
                                                        "example": "50"
                                                    }
                                                }
                                            }
                                        }
                                    }
                                },
                                "memo": {
                                    "type": "string"
                                },
                                "signature": {
                                    "type": "object",
                                    "properties": {
                                        "signature": {
                                            "type": "string",
                                            "example": "MEUCIQD02fsDPra8MtbRsyB1w7bqTM55Wu138zQbFcWx4+CFyAIge5WNPfKIuvzBZ69MyqHsqD8S1IwiEp+iUb6VSdtlpgY="
                                        },
                                        "pub_key": {
                                            "type": "object",
                                            "properties": {
                                                "type": {
                                                    "type": "string",
                                                    "example": "tendermint/PubKeySecp256k1"
                                                },
                                                "value": {
                                                    "type": "string",
                                                    "example": "Avz04VhtKJh8ACCVzlI8aTosGy0ikFXKIVHQ3jKMrosH"
                                                }
                                            }
                                        },
                                        "account_number": {
                                            "type": "string",
                                            "example": "0"
                                        },
                                        "sequence": {
                                            "type": "string",
                                            "example": "0"
                                        }
                                    }
                                }
                            }
                        },
                        "examples": {
                            "application/json": {
                                "msg": [
                                    "string"
                                ],
                                "fee": {
                                    "gas": "string",
                                    "amount": [
                                        {
                                            "denom": "stake",
                                            "amount": "50"
                                        }
                                    ]
                                },
                                "memo": "string",
                                "signature": {
                                    "signature": "MEUCIQD02fsDPra8MtbRsyB1w7bqTM55Wu138zQbFcWx4+CFyAIge5WNPfKIuvzBZ69MyqHsqD8S1IwiEp+iUb6VSdtlpgY=",
                                    "pub_key": {
                                        "type": "tendermint/PubKeySecp256k1",
                                        "value": "Avz04VhtKJh8ACCVzlI8aTosGy0ikFXKIVHQ3jKMrosH"
                                    },
                                    "account_number": "0",
                                    "sequence": "0"
                                }
                            }
                        }
                    },
                    "400": {
                        "description": "Invalid proposal id or deposit body"
                    },
                    "401": {
                        "description": "Key password is wrong"
                    },
                    "500": {
                        "description": "Internal Server Error"
                    }
                }
            }
        },
        "/gov/proposals/{proposalId}/deposits/{depositor}": {
            "get": {
                "description": "Query deposit by proposalId and depositor address",
                "operationId": "get-gov-proposals-proposalid-deposits-depositor",
                "summary": "Query deposit",
                "tags": [
                    "Governance"
                ],
                "parameters": [
                    {
                        "name": "proposalId",
                        "in": "path",
                        "description": "proposal id",
                        "required": true,
                        "type": "string"
                    },
                    {
                        "name": "depositor",
                        "in": "path",
                        "description": "Bech32 depositor address",
                        "required": true,
                        "type": "string"
                    }
                ],
                "produces": [
                    "application/json"
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "amount": {
                                    "type": "array",
                                    "items": {
                                        "type": "object",
                                        "properties": {
                                            "denom": {
                                                "type": "string",
                                                "example": "stake"
                                            },
                                            "amount": {
                                                "type": "string",
                                                "example": "50"
                                            }
                                        }
                                    }
                                },
                                "proposal_id": {
                                    "type": "string"
                                },
                                "depositor": {
                                    "description": "bech32 encoded address",
                                    "type": "string",
                                    "example": "cosmos1depk54cuajgkzea6zpgkq36tnjwdzv4afc3d27"
                                }
                            }
                        },
                        "examples": {
                            "application/json": {
                                "amount": [
                                    {
                                        "denom": "stake",
                                        "amount": "50"
                                    }
                                ],
                                "proposal_id": "string",
                                "depositor": "cosmos1depk54cuajgkzea6zpgkq36tnjwdzv4afc3d27"
                            }
                        }
                    },
                    "400": {
                        "description": "Invalid proposal id or depositor address"
                    },
                    "404": {
                        "description": "Found no deposit"
                    },
                    "500": {
                        "description": "Internal Server Error"
                    }
                }
            }
        },
        "/gov/proposals/{proposalId}/votes": {
            "get": {
                "description": "Query voters information by proposalId",
                "operationId": "get-gov-proposals-proposalid-votes",
                "summary": "Query voters",
                "tags": [
                    "Governance"
                ],
                "parameters": [
                    {
                        "name": "proposalId",
                        "in": "path",
                        "description": "proposal id",
                        "required": true,
                        "type": "string"
                    }
                ],
                "produces": [
                    "application/json"
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "type": "object",
                                "properties": {
                                    "voter": {
                                        "type": "string"
                                    },
                                    "proposal_id": {
                                        "type": "string"
                                    },
                                    "option": {
                                        "type": "string"
                                    }
                                }
                            }
                        },
                        "examples": {
                            "application/json": [
                                {
                                    "voter": "string",
                                    "proposal_id": "string",
                                    "option": "string"
                                }
                            ]
                        }
                    },
                    "400": {
                        "description": "Invalid proposal id"
                    },
                    "500": {
                        "description": "Internal Server Error"
                    }
                }
            },
            "post": {
                "description": "Send transaction to vote a proposal",
                "operationId": "post-gov-proposals-proposalid-votes",
                "summary": "Vote a proposal",
                "tags": [
                    "Governance"
                ],
                "parameters": [
                    {
                        "name": "proposalId",
                        "in": "path",
                        "description": "proposal id",
                        "required": true,
                        "type": "string"
                    },
                    {
                        "name": "govProposals-proposalId-VotesPostRequest-1",
                        "in": "body",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "base_req": {
                                    "type": "object",
                                    "properties": {
                                        "from": {
                                            "description": "Sender address or Keybase name to generate a transaction",
                                            "type": "string",
                                            "example": "cosmos1g9ahr6xhht5rmqven628nklxluzyv8z9jqjcmc"
                                        },
                                        "memo": {
                                            "type": "string",
                                            "example": "Sent via Cosmos Voyager ðŸš€"
                                        },
                                        "chain_id": {
                                            "type": "string",
                                            "example": "Cosmos-Hub"
                                        },
                                        "account_number": {
                                            "type": "string",
                                            "example": "0"
                                        },
                                        "sequence": {
                                            "type": "string",
                                            "example": "1"
                                        },
                                        "gas": {
                                            "type": "string",
                                            "example": "200000"
                                        },
                                        "gas_adjustment": {
                                            "type": "string",
                                            "example": "1.2"
                                        },
                                        "fees": {
                                            "type": "array",
                                            "items": {
                                                "type": "object",
                                                "properties": {
                                                    "denom": {
                                                        "type": "string",
                                                        "example": "stake"
                                                    },
                                                    "amount": {
                                                        "type": "string",
                                                        "example": "50"
                                                    }
                                                }
                                            }
                                        },
                                        "simulate": {
                                            "description": "Estimate gas for a transaction (cannot be used in conjunction with generate_only)",
                                            "type": "boolean",
                                            "example": false
                                        }
                                    }
                                },
                                "voter": {
                                    "description": "bech32 encoded address",
                                    "type": "string",
                                    "example": "cosmos1depk54cuajgkzea6zpgkq36tnjwdzv4afc3d27"
                                },
                                "option": {
                                    "type": "string",
                                    "example": "yes"
                                }
                            },
                            "example": {
                                "base_req": {
                                    "from": "cosmos1g9ahr6xhht5rmqven628nklxluzyv8z9jqjcmc",
                                    "memo": "Sent via Cosmos Voyager ðŸš€",
                                    "chain_id": "Cosmos-Hub",
                                    "account_number": "0",
                                    "sequence": "1",
                                    "gas": "200000",
                                    "gas_adjustment": "2022-01-02",
                                    "fees": [
                                        {
                                            "denom": "stake",
                                            "amount": "50"
                                        }
                                    ],
                                    "simulate": false
                                },
                                "voter": "cosmos1depk54cuajgkzea6zpgkq36tnjwdzv4afc3d27",
                                "option": "yes"
                            }
                        },
                        "description": "valid value of `\"option\"` field can be `\"yes\"`, `\"no\"`, `\"no_with_veto\"` and `\"abstain\"`"
                    }
                ],
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "msg": {
                                    "type": "array",
                                    "items": {
                                        "type": "string"
                                    }
                                },
                                "fee": {
                                    "type": "object",
                                    "properties": {
                                        "gas": {
                                            "type": "string"
                                        },
                                        "amount": {
                                            "type": "array",
                                            "items": {
                                                "type": "object",
                                                "properties": {
                                                    "denom": {
                                                        "type": "string",
                                                        "example": "stake"
                                                    },
                                                    "amount": {
                                                        "type": "string",
                                                        "example": "50"
                                                    }
                                                }
                                            }
                                        }
                                    }
                                },
                                "memo": {
                                    "type": "string"
                                },
                                "signature": {
                                    "type": "object",
                                    "properties": {
                                        "signature": {
                                            "type": "string",
                                            "example": "MEUCIQD02fsDPra8MtbRsyB1w7bqTM55Wu138zQbFcWx4+CFyAIge5WNPfKIuvzBZ69MyqHsqD8S1IwiEp+iUb6VSdtlpgY="
                                        },
                                        "pub_key": {
                                            "type": "object",
                                            "properties": {
                                                "type": {
                                                    "type": "string",
                                                    "example": "tendermint/PubKeySecp256k1"
                                                },
                                                "value": {
                                                    "type": "string",
                                                    "example": "Avz04VhtKJh8ACCVzlI8aTosGy0ikFXKIVHQ3jKMrosH"
                                                }
                                            }
                                        },
                                        "account_number": {
                                            "type": "string",
                                            "example": "0"
                                        },
                                        "sequence": {
                                            "type": "string",
                                            "example": "0"
                                        }
                                    }
                                }
                            }
                        },
                        "examples": {
                            "application/json": {
                                "msg": [
                                    "string"
                                ],
                                "fee": {
                                    "gas": "string",
                                    "amount": [
                                        {
                                            "denom": "stake",
                                            "amount": "50"
                                        }
                                    ]
                                },
                                "memo": "string",
                                "signature": {
                                    "signature": "MEUCIQD02fsDPra8MtbRsyB1w7bqTM55Wu138zQbFcWx4+CFyAIge5WNPfKIuvzBZ69MyqHsqD8S1IwiEp+iUb6VSdtlpgY=",
                                    "pub_key": {
                                        "type": "tendermint/PubKeySecp256k1",
                                        "value": "Avz04VhtKJh8ACCVzlI8aTosGy0ikFXKIVHQ3jKMrosH"
                                    },
                                    "account_number": "0",
                                    "sequence": "0"
                                }
                            }
                        }
                    },
                    "400": {
                        "description": "Invalid proposal id or vote body"
                    },
                    "401": {
                        "description": "Key password is wrong"
                    },
                    "500": {
                        "description": "Internal Server Error"
                    }
                }
            }
        },
        "/gov/proposals/{proposalId}/votes/{voter}": {
            "get": {
                "description": "Query vote information by proposal Id and voter address",
                "operationId": "get-gov-proposals-proposalid-votes-voter",
                "summary": "Query vote",
                "tags": [
                    "Governance"
                ],
                "parameters": [
                    {
                        "name": "proposalId",
                        "in": "path",
                        "description": "proposal id",
                        "required": true,
                        "type": "string"
                    },
                    {
                        "name": "voter",
                        "in": "path",
                        "description": "Bech32 voter address",
                        "required": true,
                        "type": "string"
                    }
                ],
                "produces": [
                    "application/json"
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "voter": {
                                    "type": "string"
                                },
                                "proposal_id": {
                                    "type": "string"
                                },
                                "option": {
                                    "type": "string"
                                }
                            }
                        },
                        "examples": {
                            "application/json": {
                                "voter": "string",
                                "proposal_id": "string",
                                "option": "string"
                            }
                        }
                    },
                    "400": {
                        "description": "Invalid proposal id or voter address"
                    },
                    "404": {
                        "description": "Found no vote"
                    },
                    "500": {
                        "description": "Internal Server Error"
                    }
                }
            }
        },
        "/gov/parameters/deposit": {
            "get": {
                "description": "Query governance deposit parameters. The max_deposit_period units are in nanoseconds.",
                "operationId": "get-gov-parameters-deposit",
                "summary": "Query governance deposit parameters",
                "tags": [
                    "Governance"
                ],
                "produces": [
                    "application/json"
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "min_deposit": {
                                    "type": "array",
                                    "items": {
                                        "type": "object",
                                        "properties": {
                                            "denom": {
                                                "type": "string",
                                                "example": "stake"
                                            },
                                            "amount": {
                                                "type": "string",
                                                "example": "50"
                                            }
                                        }
                                    }
                                },
                                "max_deposit_period": {
                                    "type": "string",
                                    "example": "86400000000000"
                                }
                            }
                        },
                        "examples": {
                            "application/json": {
                                "min_deposit": [
                                    {
                                        "denom": "stake",
                                        "amount": "50"
                                    }
                                ],
                                "max_deposit_period": "86400000000000"
                            }
                        }
                    },
                    "400": {
                        "description": "<other_path> is not a valid query request path"
                    },
                    "404": {
                        "description": "Found no deposit parameters"
                    },
                    "500": {
                        "description": "Internal Server Error"
                    }
                }
            }
        },
        "/gov/parameters/voting": {
            "get": {
                "description": "Query governance voting parameters. The voting_period units are in nanoseconds.",
                "operationId": "get-gov-parameters-voting",
                "summary": "Query governance voting parameters",
                "tags": [
                    "Governance"
                ],
                "produces": [
                    "application/json"
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object"
                        },
                        "examples": {
                            "application/json": {}
                        }
                    },
                    "400": {
                        "description": "<other_path> is not a valid query request path"
                    },
                    "404": {
                        "description": "Found no voting parameters"
                    },
                    "500": {
                        "description": "Internal Server Error"
                    }
                }
            }
        },
        "/distribution/delegators/{delegatorAddr}/rewards": {
            "get": {
                "description": "Get the sum of all the rewards earned by delegations by a single delegator",
                "operationId": "get-distribution-delegators-delegatoraddr-rewards",
                "summary": "Get the total rewards balance from all delegations",
                "tags": [
                    "Distribution"
                ],
                "parameters": [
                    {
                        "name": "delegatorAddr",
                        "in": "path",
                        "description": "Bech32 AccAddress of Delegator",
                        "required": true,
                        "type": "string"
                    }
                ],
                "produces": [
                    "application/json"
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "rewards": {
                                    "type": "array",
                                    "items": {
                                        "type": "object",
                                        "properties": {
                                            "validator_address": {
                                                "description": "bech32 encoded address",
                                                "type": "string",
                                                "example": "cosmosvaloper16xyempempp92x9hyzz9wrgf94r6j9h5f2w4n2l"
                                            },
                                            "reward": {
                                                "type": "array",
                                                "items": {
                                                    "type": "object",
                                                    "properties": {
                                                        "denom": {
                                                            "type": "string",
                                                            "example": "stake"
                                                        },
                                                        "amount": {
                                                            "type": "string",
                                                            "example": "50"
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                },
                                "total": {
                                    "type": "array",
                                    "items": {
                                        "type": "object",
                                        "properties": {
                                            "denom": {
                                                "type": "string",
                                                "example": "stake"
                                            },
                                            "amount": {
                                                "type": "string",
                                                "example": "50"
                                            }
                                        }
                                    }
                                }
                            }
                        },
                        "examples": {
                            "application/json": {
                                "rewards": [
                                    {
                                        "validator_address": "cosmosvaloper16xyempempp92x9hyzz9wrgf94r6j9h5f2w4n2l",
                                        "reward": [
                                            {
                                                "denom": "stake",
                                                "amount": "50"
                                            }
                                        ]
                                    }
                                ],
                                "total": [
                                    {
                                        "denom": "stake",
                                        "amount": "50"
                                    }
                                ]
                            }
                        }
                    },
                    "400": {
                        "description": "Invalid delegator address"
                    },
                    "500": {
                        "description": "Internal Server Error"
                    }
                }
            },
            "post": {
                "description": "Withdraw all the delegator's delegation rewards",
                "operationId": "post-distribution-delegators-delegatoraddr-rewards",
                "summary": "Withdraw all the delegator's delegation rewards",
                "tags": [
                    "Distribution"
                ],
                "parameters": [
                    {
                        "name": "delegatorAddr",
                        "in": "path",
                        "description": "Bech32 AccAddress of Delegator",
                        "required": true,
                        "type": "string"
                    },
                    {
                        "name": "distributionDelegators-delegatorAddr-RewardsPostRequest-1",
                        "in": "body",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "base_req": {
                                    "type": "object",
                                    "properties": {
                                        "from": {
                                            "description": "Sender address or Keybase name to generate a transaction",
                                            "type": "string",
                                            "example": "cosmos1g9ahr6xhht5rmqven628nklxluzyv8z9jqjcmc"
                                        },
                                        "memo": {
                                            "type": "string",
                                            "example": "Sent via Cosmos Voyager ðŸš€"
                                        },
                                        "chain_id": {
                                            "type": "string",
                                            "example": "Cosmos-Hub"
                                        },
                                        "account_number": {
                                            "type": "string",
                                            "example": "0"
                                        },
                                        "sequence": {
                                            "type": "string",
                                            "example": "1"
                                        },
                                        "gas": {
                                            "type": "string",
                                            "example": "200000"
                                        },
                                        "gas_adjustment": {
                                            "type": "string",
                                            "example": "1.2"
                                        },
                                        "fees": {
                                            "type": "array",
                                            "items": {
                                                "type": "object",
                                                "properties": {
                                                    "denom": {
                                                        "type": "string",
                                                        "example": "stake"
                                                    },
                                                    "amount": {
                                                        "type": "string",
                                                        "example": "50"
                                                    }
                                                }
                                            }
                                        },
                                        "simulate": {
                                            "description": "Estimate gas for a transaction (cannot be used in conjunction with generate_only)",
                                            "type": "boolean",
                                            "example": false
                                        }
                                    }
                                }
                            },
                            "example": {
                                "base_req": {
                                    "from": "cosmos1g9ahr6xhht5rmqven628nklxluzyv8z9jqjcmc",
                                    "memo": "Sent via Cosmos Voyager ðŸš€",
                                    "chain_id": "Cosmos-Hub",
                                    "account_number": "0",
                                    "sequence": "1",
                                    "gas": "200000",
                                    "gas_adjustment": "2022-01-02",
                                    "fees": [
                                        {
                                            "denom": "stake",
                                            "amount": "50"
                                        }
                                    ],
                                    "simulate": false
                                }
                            }
                        }
                    }
                ],
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "msg": {
                                    "type": "array",
                                    "items": {
                                        "type": "string"
                                    }
                                },
                                "fee": {
                                    "type": "object",
                                    "properties": {
                                        "gas": {
                                            "type": "string"
                                        },
                                        "amount": {
                                            "type": "array",
                                            "items": {
                                                "type": "object",
                                                "properties": {
                                                    "denom": {
                                                        "type": "string",
                                                        "example": "stake"
                                                    },
                                                    "amount": {
                                                        "type": "string",
                                                        "example": "50"
                                                    }
                                                }
                                            }
                                        }
                                    }
                                },
                                "memo": {
                                    "type": "string"
                                },
                                "signature": {
                                    "type": "object",
                                    "properties": {
                                        "signature": {
                                            "type": "string",
                                            "example": "MEUCIQD02fsDPra8MtbRsyB1w7bqTM55Wu138zQbFcWx4+CFyAIge5WNPfKIuvzBZ69MyqHsqD8S1IwiEp+iUb6VSdtlpgY="
                                        },
                                        "pub_key": {
                                            "type": "object",
                                            "properties": {
                                                "type": {
                                                    "type": "string",
                                                    "example": "tendermint/PubKeySecp256k1"
                                                },
                                                "value": {
                                                    "type": "string",
                                                    "example": "Avz04VhtKJh8ACCVzlI8aTosGy0ikFXKIVHQ3jKMrosH"
                                                }
                                            }
                                        },
                                        "account_number": {
                                            "type": "string",
                                            "example": "0"
                                        },
                                        "sequence": {
                                            "type": "string",
                                            "example": "0"
                                        }
                                    }
                                }
                            }
                        },
                        "examples": {
                            "application/json": {
                                "msg": [
                                    "string"
                                ],
                                "fee": {
                                    "gas": "string",
                                    "amount": [
                                        {
                                            "denom": "stake",
                                            "amount": "50"
                                        }
                                    ]
                                },
                                "memo": "string",
                                "signature": {
                                    "signature": "MEUCIQD02fsDPra8MtbRsyB1w7bqTM55Wu138zQbFcWx4+CFyAIge5WNPfKIuvzBZ69MyqHsqD8S1IwiEp+iUb6VSdtlpgY=",
                                    "pub_key": {
                                        "type": "tendermint/PubKeySecp256k1",
                                        "value": "Avz04VhtKJh8ACCVzlI8aTosGy0ikFXKIVHQ3jKMrosH"
                                    },
                                    "account_number": "0",
                                    "sequence": "0"
                                }
                            }
                        }
                    },
                    "400": {
                        "description": "Invalid delegator address"
                    },
                    "401": {
                        "description": "Key password is wrong"
                    },
                    "500": {
                        "description": "Internal Server Error"
                    }
                }
            }
        },
        "/distribution/delegators/{delegatorAddr}/rewards/{validatorAddr}": {
            "get": {
                "description": "Query a single delegation reward by a delegator",
                "operationId": "get-distribution-delegators-delegatoraddr-rewards-validatoraddr",
                "summary": "Query a delegation reward",
                "tags": [
                    "Distribution"
                ],
                "parameters": [
                    {
                        "name": "delegatorAddr",
                        "in": "path",
                        "description": "Bech32 AccAddress of Delegator",
                        "required": true,
                        "type": "string"
                    },
                    {
                        "name": "validatorAddr",
                        "in": "path",
                        "description": "Bech32 OperatorAddress of validator",
                        "required": true,
                        "type": "string"
                    }
                ],
                "produces": [
                    "application/json"
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "type": "object",
                                "properties": {
                                    "denom": {
                                        "type": "string",
                                        "example": "stake"
                                    },
                                    "amount": {
                                        "type": "string",
                                        "example": "50"
                                    }
                                }
                            }
                        },
                        "examples": {
                            "application/json": [
                                {
                                    "denom": "stake",
                                    "amount": "50"
                                }
                            ]
                        }
                    },
                    "400": {
                        "description": "Invalid delegator address"
                    },
                    "500": {
                        "description": "Internal Server Error"
                    }
                }
            },
            "post": {
                "description": "Withdraw a delegator's delegation reward from a single validator",
                "operationId": "post-distribution-delegators-delegatoraddr-rewards-validatoraddr",
                "summary": "Withdraw a delegation reward",
                "tags": [
                    "Distribution"
                ],
                "parameters": [
                    {
                        "name": "delegatorAddr",
                        "in": "path",
                        "description": "Bech32 AccAddress of Delegator",
                        "required": true,
                        "type": "string"
                    },
                    {
                        "name": "validatorAddr",
                        "in": "path",
                        "description": "Bech32 OperatorAddress of validator",
                        "required": true,
                        "type": "string"
                    },
                    {
                        "name": "distributionDelegators-delegatorAddr-Rewards-validatorAddr-PostRequest-2",
                        "in": "body",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "base_req": {
                                    "type": "object",
                                    "properties": {
                                        "from": {
                                            "description": "Sender address or Keybase name to generate a transaction",
                                            "type": "string",
                                            "example": "cosmos1g9ahr6xhht5rmqven628nklxluzyv8z9jqjcmc"
                                        },
                                        "memo": {
                                            "type": "string",
                                            "example": "Sent via Cosmos Voyager ðŸš€"
                                        },
                                        "chain_id": {
                                            "type": "string",
                                            "example": "Cosmos-Hub"
                                        },
                                        "account_number": {
                                            "type": "string",
                                            "example": "0"
                                        },
                                        "sequence": {
                                            "type": "string",
                                            "example": "1"
                                        },
                                        "gas": {
                                            "type": "string",
                                            "example": "200000"
                                        },
                                        "gas_adjustment": {
                                            "type": "string",
                                            "example": "1.2"
                                        },
                                        "fees": {
                                            "type": "array",
                                            "items": {
                                                "type": "object",
                                                "properties": {
                                                    "denom": {
                                                        "type": "string",
                                                        "example": "stake"
                                                    },
                                                    "amount": {
                                                        "type": "string",
                                                        "example": "50"
                                                    }
                                                }
                                            }
                                        },
                                        "simulate": {
                                            "description": "Estimate gas for a transaction (cannot be used in conjunction with generate_only)",
                                            "type": "boolean",
                                            "example": false
                                        }
                                    }
                                }
                            },
                            "example": {
                                "base_req": {
                                    "from": "cosmos1g9ahr6xhht5rmqven628nklxluzyv8z9jqjcmc",
                                    "memo": "Sent via Cosmos Voyager ðŸš€",
                                    "chain_id": "Cosmos-Hub",
                                    "account_number": "0",
                                    "sequence": "1",
                                    "gas": "200000",
                                    "gas_adjustment": "2022-01-02",
                                    "fees": [
                                        {
                                            "denom": "stake",
                                            "amount": "50"
                                        }
                                    ],
                                    "simulate": false
                                }
                            }
                        }
                    }
                ],
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "msg": {
                                    "type": "array",
                                    "items": {
                                        "type": "string"
                                    }
                                },
                                "fee": {
                                    "type": "object",
                                    "properties": {
                                        "gas": {
                                            "type": "string"
                                        },
                                        "amount": {
                                            "type": "array",
                                            "items": {
                                                "type": "object",
                                                "properties": {
                                                    "denom": {
                                                        "type": "string",
                                                        "example": "stake"
                                                    },
                                                    "amount": {
                                                        "type": "string",
                                                        "example": "50"
                                                    }
                                                }
                                            }
                                        }
                                    }
                                },
                                "memo": {
                                    "type": "string"
                                },
                                "signature": {
                                    "type": "object",
                                    "properties": {
                                        "signature": {
                                            "type": "string",
                                            "example": "MEUCIQD02fsDPra8MtbRsyB1w7bqTM55Wu138zQbFcWx4+CFyAIge5WNPfKIuvzBZ69MyqHsqD8S1IwiEp+iUb6VSdtlpgY="
                                        },
                                        "pub_key": {
                                            "type": "object",
                                            "properties": {
                                                "type": {
                                                    "type": "string",
                                                    "example": "tendermint/PubKeySecp256k1"
                                                },
                                                "value": {
                                                    "type": "string",
                                                    "example": "Avz04VhtKJh8ACCVzlI8aTosGy0ikFXKIVHQ3jKMrosH"
                                                }
                                            }
                                        },
                                        "account_number": {
                                            "type": "string",
                                            "example": "0"
                                        },
                                        "sequence": {
                                            "type": "string",
                                            "example": "0"
                                        }
                                    }
                                }
                            }
                        },
                        "examples": {
                            "application/json": {
                                "msg": [
                                    "string"
                                ],
                                "fee": {
                                    "gas": "string",
                                    "amount": [
                                        {
                                            "denom": "stake",
                                            "amount": "50"
                                        }
                                    ]
                                },
                                "memo": "string",
                                "signature": {
                                    "signature": "MEUCIQD02fsDPra8MtbRsyB1w7bqTM55Wu138zQbFcWx4+CFyAIge5WNPfKIuvzBZ69MyqHsqD8S1IwiEp+iUb6VSdtlpgY=",
                                    "pub_key": {
                                        "type": "tendermint/PubKeySecp256k1",
                                        "value": "Avz04VhtKJh8ACCVzlI8aTosGy0ikFXKIVHQ3jKMrosH"
                                    },
                                    "account_number": "0",
                                    "sequence": "0"
                                }
                            }
                        }
                    },
                    "400": {
                        "description": "Invalid delegator address or delegation body"
                    },
                    "401": {
                        "description": "Key password is wrong"
                    },
                    "500": {
                        "description": "Internal Server Error"
                    }
                }
            }
        },
        "/distribution/delegators/{delegatorAddr}/withdraw_address": {
            "get": {
                "description": "Get the delegations' rewards withdrawal address. This is the address in which the user will receive the reward funds",
                "operationId": "get-distribution-delegators-delegatoraddr-withdraw_address",
                "summary": "Get the rewards withdrawal address",
                "tags": [
                    "Distribution"
                ],
                "parameters": [
                    {
                        "name": "delegatorAddr",
                        "in": "path",
                        "description": "Bech32 AccAddress of Delegator",
                        "required": true,
                        "type": "string"
                    }
                ],
                "produces": [
                    "application/json"
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "description": "bech32 encoded address",
                            "type": "string",
                            "example": "cosmos1depk54cuajgkzea6zpgkq36tnjwdzv4afc3d27"
                        },
                        "examples": {
                            "application/json": "cosmos1depk54cuajgkzea6zpgkq36tnjwdzv4afc3d27"
                        }
                    },
                    "400": {
                        "description": "Invalid delegator address"
                    },
                    "500": {
                        "description": "Internal Server Error"
                    }
                }
            },
            "post": {
                "description": "Replace the delegations' rewards withdrawal address for a new one.",
                "operationId": "post-distribution-delegators-delegatoraddr-withdraw_address",
                "summary": "Replace the rewards withdrawal address",
                "tags": [
                    "Distribution"
                ],
                "parameters": [
                    {
                        "name": "delegatorAddr",
                        "in": "path",
                        "description": "Bech32 AccAddress of Delegator",
                        "required": true,
                        "type": "string"
                    },
                    {
                        "name": "distributionDelegators-delegatorAddr-Withdraw_addressPostRequest-1",
                        "in": "body",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "base_req": {
                                    "type": "object",
                                    "properties": {
                                        "from": {
                                            "description": "Sender address or Keybase name to generate a transaction",
                                            "type": "string",
                                            "example": "cosmos1g9ahr6xhht5rmqven628nklxluzyv8z9jqjcmc"
                                        },
                                        "memo": {
                                            "type": "string",
                                            "example": "Sent via Cosmos Voyager ðŸš€"
                                        },
                                        "chain_id": {
                                            "type": "string",
                                            "example": "Cosmos-Hub"
                                        },
                                        "account_number": {
                                            "type": "string",
                                            "example": "0"
                                        },
                                        "sequence": {
                                            "type": "string",
                                            "example": "1"
                                        },
                                        "gas": {
                                            "type": "string",
                                            "example": "200000"
                                        },
                                        "gas_adjustment": {
                                            "type": "string",
                                            "example": "1.2"
                                        },
                                        "fees": {
                                            "type": "array",
                                            "items": {
                                                "type": "object",
                                                "properties": {
                                                    "denom": {
                                                        "type": "string",
                                                        "example": "stake"
                                                    },
                                                    "amount": {
                                                        "type": "string",
                                                        "example": "50"
                                                    }
                                                }
                                            }
                                        },
                                        "simulate": {
                                            "description": "Estimate gas for a transaction (cannot be used in conjunction with generate_only)",
                                            "type": "boolean",
                                            "example": false
                                        }
                                    }
                                },
                                "withdraw_address": {
                                    "description": "bech32 encoded address",
                                    "type": "string",
                                    "example": "cosmos1depk54cuajgkzea6zpgkq36tnjwdzv4afc3d27"
                                }
                            },
                            "example": {
                                "base_req": {
                                    "from": "cosmos1g9ahr6xhht5rmqven628nklxluzyv8z9jqjcmc",
                                    "memo": "Sent via Cosmos Voyager ðŸš€",
                                    "chain_id": "Cosmos-Hub",
                                    "account_number": "0",
                                    "sequence": "1",
                                    "gas": "200000",
                                    "gas_adjustment": "2022-01-02",
                                    "fees": [
                                        {
                                            "denom": "stake",
                                            "amount": "50"
                                        }
                                    ],
                                    "simulate": false
                                },
                                "withdraw_address": "cosmos1depk54cuajgkzea6zpgkq36tnjwdzv4afc3d27"
                            }
                        }
                    }
                ],
                "consumes": [
                    "application/json"
                ],
                "produces": [
                    "application/json"
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "msg": {
                                    "type": "array",
                                    "items": {
                                        "type": "string"
                                    }
                                },
                                "fee": {
                                    "type": "object",
                                    "properties": {
                                        "gas": {
                                            "type": "string"
                                        },
                                        "amount": {
                                            "type": "array",
                                            "items": {
                                                "type": "object",
                                                "properties": {
                                                    "denom": {
                                                        "type": "string",
                                                        "example": "stake"
                                                    },
                                                    "amount": {
                                                        "type": "string",
                                                        "example": "50"
                                                    }
                                                }
                                            }
                                        }
                                    }
                                },
                                "memo": {
                                    "type": "string"
                                },
                                "signature": {
                                    "type": "object",
                                    "properties": {
                                        "signature": {
                                            "type": "string",
                                            "example": "MEUCIQD02fsDPra8MtbRsyB1w7bqTM55Wu138zQbFcWx4+CFyAIge5WNPfKIuvzBZ69MyqHsqD8S1IwiEp+iUb6VSdtlpgY="
                                        },
                                        "pub_key": {
                                            "type": "object",
                                            "properties": {
                                                "type": {
                                                    "type": "string",
                                                    "example": "tendermint/PubKeySecp256k1"
                                                },
                                                "value": {
                                                    "type": "string",
                                                    "example": "Avz04VhtKJh8ACCVzlI8aTosGy0ikFXKIVHQ3jKMrosH"
                                                }
                                            }
                                        },
                                        "account_number": {
                                            "type": "string",
                                            "example": "0"
                                        },
                                        "sequence": {
                                            "type": "string",
                                            "example": "0"
                                        }
                                    }
                                }
                            }
                        },
                        "examples": {
                            "application/json": {
                                "msg": [
                                    "string"
                                ],
                                "fee": {
                                    "gas": "string",
                                    "amount": [
                                        {
                                            "denom": "stake",
                                            "amount": "50"
                                        }
                                    ]
                                },
                                "memo": "string",
                                "signature": {
                                    "signature": "MEUCIQD02fsDPra8MtbRsyB1w7bqTM55Wu138zQbFcWx4+CFyAIge5WNPfKIuvzBZ69MyqHsqD8S1IwiEp+iUb6VSdtlpgY=",
                                    "pub_key": {
                                        "type": "tendermint/PubKeySecp256k1",
                                        "value": "Avz04VhtKJh8ACCVzlI8aTosGy0ikFXKIVHQ3jKMrosH"
                                    },
                                    "account_number": "0",
                                    "sequence": "0"
                                }
                            }
                        }
                    },
                    "400": {
                        "description": "Invalid delegator or withdraw address"
                    },
                    "401": {
                        "description": "Key password is wrong"
                    },
                    "500": {
                        "description": "Internal Server Error"
                    }
                }
            }
        },
        "/distribution/validators/{validatorAddr}": {
            "get": {
                "description": "Query the distribution information of a single validator",
                "operationId": "get-distribution-validators-validatoraddr",
                "summary": "Validator distribution information",
                "tags": [
                    "Distribution"
                ],
                "parameters": [
                    {
                        "name": "validatorAddr",
                        "in": "path",
                        "description": "Bech32 OperatorAddress of validator",
                        "required": true,
                        "type": "string"
                    }
                ],
                "produces": [
                    "application/json"
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "operator_address": {
                                    "description": "bech32 encoded address",
                                    "type": "string",
                                    "example": "cosmosvaloper16xyempempp92x9hyzz9wrgf94r6j9h5f2w4n2l"
                                },
                                "self_bond_rewards": {
                                    "type": "array",
                                    "items": {
                                        "type": "object",
                                        "properties": {
                                            "denom": {
                                                "type": "string",
                                                "example": "stake"
                                            },
                                            "amount": {
                                                "type": "string",
                                                "example": "50"
                                            }
                                        }
                                    }
                                },
                                "val_commission": {
                                    "type": "array",
                                    "items": {
                                        "type": "object",
                                        "properties": {
                                            "denom": {
                                                "type": "string",
                                                "example": "stake"
                                            },
                                            "amount": {
                                                "type": "string",
                                                "example": "50"
                                            }
                                        }
                                    }
                                }
                            }
                        },
                        "examples": {
                            "application/json": {
                                "operator_address": "cosmosvaloper16xyempempp92x9hyzz9wrgf94r6j9h5f2w4n2l",
                                "self_bond_rewards": [
                                    {
                                        "denom": "stake",
                                        "amount": "50"
                                    }
                                ],
                                "val_commission": [
                                    {
                                        "denom": "stake",
                                        "amount": "50"
                                    }
                                ]
                            }
                        }
                    },
                    "400": {
                        "description": "Invalid validator address"
                    },
                    "500": {
                        "description": "Internal Server Error"
                    }
                }
            }
        },
        "/distribution/validators/{validatorAddr}/outstanding_rewards": {
            "get": {
                "description": "Fee distribution outstanding rewards of a single validator",
                "operationId": "get-distribution-validators-validatoraddr-outstanding_rewards",
                "summary": "Fee distribution outstanding rewards of a single validator",
                "tags": [
                    "Distribution"
                ],
                "parameters": [
                    {
                        "name": "validatorAddr",
                        "in": "path",
                        "description": "Bech32 OperatorAddress of validator",
                        "required": true,
                        "type": "string"
                    }
                ],
                "produces": [
                    "application/json"
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "array",
                            "items": {
                                "type": "object",
                                "properties": {
                                    "denom": {
                                        "type": "string",
                                        "example": "stake"
                                    },
                                    "amount": {
                                        "type": "string",
                                        "example": "50"
                                    }
                                }
                            }
                        },
                        "examples": {
                            "application/json": [
                                {
                                    "denom": "stake",
                                    "amount": "50"
                                }
                            ]
                        }
                    },
                    "500": {
                        "description": "Internal Server Error"
                    }
                }
            }
        },
        "/distribution/parameters": {
            "get": {
                "description": "Fee distribution parameters",
                "operationId": "get-distribution-parameters",
                "summary": "Fee distribution parameters",
                "tags": [
                    "Distribution"
                ],
                "produces": [
                    "application/json"
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object"
                        },
                        "examples": {
                            "application/json": {}
                        }
                    },
                    "500": {
                        "description": "Internal Server Error"
                    }
                }
            }
        },
        "/minting/parameters": {
            "get": {
                "description": "Minting module parameters",
                "operationId": "get-minting-parameters",
                "summary": "Minting module parameters",
                "tags": [
                    "Mint"
                ],
                "produces": [
                    "application/json"
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object"
                        },
                        "examples": {
                            "application/json": {}
                        }
                    },
                    "500": {
                        "description": "Internal Server Error"
                    }
                }
            }
        },
        "/minting/inflation": {
            "get": {
                "description": "Current minting inflation value",
                "operationId": "get-minting-inflation",
                "summary": "Current minting inflation value",
                "tags": [
                    "Mint"
                ],
                "produces": [
                    "application/json"
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "string"
                        },
                        "examples": {
                            "application/json": "string"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error"
                    }
                }
            }
        },
        "/minting/annual-provisions": {
            "get": {
                "description": "Current minting annual provisions value",
                "operationId": "get-minting-annual-provisions",
                "summary": "Current minting annual provisions value",
                "tags": [
                    "Mint"
                ],
                "produces": [
                    "application/json"
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "string"
                        },
                        "examples": {
                            "application/json": "string"
                        }
                    },
                    "500": {
                        "description": "Internal Server Error"
                    }
                }
            }
        },
        "/wasm/code": {
            "post": {
                "description": "Generate wasm store code message",
                "operationId": "post-wasm-code",
                "summary": "Generate wasm store code message",
                "tags": [
                    "Wasm"
                ],
                "parameters": [
                    {
                        "name": "wasmCodePostRequest",
                        "in": "body",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "base_req": {
                                    "type": "object",
                                    "properties": {
                                        "from": {
                                            "description": "Sender address or Keybase name to generate a transaction",
                                            "type": "string",
                                            "example": "cosmos1g9ahr6xhht5rmqven628nklxluzyv8z9jqjcmc"
                                        },
                                        "memo": {
                                            "type": "string",
                                            "example": "Sent via Cosmos Voyager ðŸš€"
                                        },
                                        "chain_id": {
                                            "type": "string",
                                            "example": "Cosmos-Hub"
                                        },
                                        "account_number": {
                                            "type": "string",
                                            "example": "0"
                                        },
                                        "sequence": {
                                            "type": "string",
                                            "example": "1"
                                        },
                                        "gas": {
                                            "type": "string",
                                            "example": "200000"
                                        },
                                        "gas_adjustment": {
                                            "type": "string",
                                            "example": "1.2"
                                        },
                                        "fees": {
                                            "type": "array",
                                            "items": {
                                                "type": "object",
                                                "properties": {
                                                    "denom": {
                                                        "type": "string",
                                                        "example": "stake"
                                                    },
                                                    "amount": {
                                                        "type": "string",
                                                        "example": "50"
                                                    }
                                                }
                                            }
                                        },
                                        "simulate": {
                                            "description": "Estimate gas for a transaction (cannot be used in conjunction with generate_only)",
                                            "type": "boolean",
                                            "example": false
                                        }
                                    }
                                },
                                "wasm_bytes": {
                                    "type": "string",
                                    "example": "Avz04VhtKJh8ACCVzlI8aTosGy0ikFXKIVHQ3jKMrosH"
                                }
                            }
                        }
                    }
                ],
                "consumes": [
                    "*/*"
                ],
                "produces": [
                    "application/json"
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "msg": {
                                    "type": "array",
                                    "items": {
                                        "type": "string"
                                    }
                                },
                                "fee": {
                                    "type": "object",
                                    "properties": {
                                        "gas": {
                                            "type": "string"
                                        },
                                        "amount": {
                                            "type": "array",
                                            "items": {
                                                "type": "object",
                                                "properties": {
                                                    "denom": {
                                                        "type": "string",
                                                        "example": "stake"
                                                    },
                                                    "amount": {
                                                        "type": "string",
                                                        "example": "50"
                                                    }
                                                }
                                            }
                                        }
                                    }
                                },
                                "memo": {
                                    "type": "string"
                                },
                                "signature": {
                                    "type": "object",
                                    "properties": {
                                        "signature": {
                                            "type": "string",
                                            "example": "MEUCIQD02fsDPra8MtbRsyB1w7bqTM55Wu138zQbFcWx4+CFyAIge5WNPfKIuvzBZ69MyqHsqD8S1IwiEp+iUb6VSdtlpgY="
                                        },
                                        "pub_key": {
                                            "type": "object",
                                            "properties": {
                                                "type": {
                                                    "type": "string",
                                                    "example": "tendermint/PubKeySecp256k1"
                                                },
                                                "value": {
                                                    "type": "string",
                                                    "example": "Avz04VhtKJh8ACCVzlI8aTosGy0ikFXKIVHQ3jKMrosH"
                                                }
                                            }
                                        },
                                        "account_number": {
                                            "type": "string",
                                            "example": "0"
                                        },
                                        "sequence": {
                                            "type": "string",
                                            "example": "0"
                                        }
                                    }
                                }
                            }
                        },
                        "examples": {
                            "application/json": {
                                "msg": [
                                    "string"
                                ],
                                "fee": {
                                    "gas": "string",
                                    "amount": [
                                        {
                                            "denom": "stake",
                                            "amount": "50"
                                        }
                                    ]
                                },
                                "memo": "string",
                                "signature": {
                                    "signature": "MEUCIQD02fsDPra8MtbRsyB1w7bqTM55Wu138zQbFcWx4+CFyAIge5WNPfKIuvzBZ69MyqHsqD8S1IwiEp+iUb6VSdtlpgY=",
                                    "pub_key": {
                                        "type": "tendermint/PubKeySecp256k1",
                                        "value": "Avz04VhtKJh8ACCVzlI8aTosGy0ikFXKIVHQ3jKMrosH"
                                    },
                                    "account_number": "0",
                                    "sequence": "0"
                                }
                            }
                        }
                    },
                    "400": {
                        "description": "Bad request"
                    },
                    "500": {
                        "description": "Internal Server Error"
                    }
                }
            },
            "get": {
                "description": "List code info",
                "operationId": "get-wasm-code",
                "summary": "List code info",
                "tags": [
                    "Wasm"
                ],
                "produces": [
                    "application/json"
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "height": {
                                    "type": "string"
                                },
                                "result": {
                                    "type": "object",
                                    "properties": {
                                        "height": {
                                            "type": "string"
                                        },
                                        "result": {
                                            "type": "array",
                                            "items": {
                                                "type": "object",
                                                "properties": {
                                                    "id": {
                                                        "type": "number"
                                                    },
                                                    "creator": {
                                                        "type": "string"
                                                    },
                                                    "data_hash": {
                                                        "type": "string"
                                                    },
                                                    "source": {
                                                        "type": "string"
                                                    },
                                                    "builder": {
                                                        "type": "string"
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        },
                        "examples": {
                            "application/json": {
                                "height": "string",
                                "result": {
                                    "height": "string",
                                    "result": [
                                        {
                                            "id": 0,
                                            "creator": "string",
                                            "data_hash": "string",
                                            "source": "string",
                                            "builder": "string"
                                        }
                                    ]
                                }
                            }
                        }
                    }
                }
            }
        },
        "/wasm/code/{codeID}/contracts": {
            "get": {
                "description": "Get info about all contracts deployed with a code ID",
                "operationId": "get-wasm-code-codeid-contracts",
                "summary": "Get info about all contracts deployed with a code ID",
                "tags": [
                    "Wasm"
                ],
                "parameters": [
                    {
                        "name": "codeID",
                        "in": "path",
                        "description": "code ID you want to query",
                        "required": true,
                        "type": "number"
                    }
                ],
                "produces": [
                    "application/json"
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "height": {
                                    "type": "string"
                                },
                                "result": {
                                    "type": "object",
                                    "properties": {
                                        "height": {
                                            "type": "string"
                                        },
                                        "result": {
                                            "type": "array",
                                            "items": {
                                                "type": "object",
                                                "properties": {
                                                    "code-id": {
                                                        "type": "number"
                                                    },
                                                    "creator": {
                                                        "type": "string"
                                                    },
                                                    "label": {
                                                        "type": "string"
                                                    },
                                                    "address": {
                                                        "type": "string"
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        },
                        "examples": {
                            "application/json": {
                                "height": "string",
                                "result": {
                                    "height": "string",
                                    "result": [
                                        {
                                            "code-id": 0,
                                            "creator": "string",
                                            "label": "string",
                                            "address": "string"
                                        }
                                    ]
                                }
                            }
                        }
                    }
                }
            }
        },
        "/wasm/contract/{contractAddress}": {
            "post": {
                "description": "Execute wasm contract message",
                "operationId": "post-wasm-contract-contractaddress",
                "summary": "Execute wasm contract message",
                "tags": [
                    "Wasm"
                ],
                "parameters": [
                    {
                        "name": "contractAddress",
                        "in": "path",
                        "description": "contract address you want to execute",
                        "required": true,
                        "type": "string"
                    },
                    {
                        "name": "wasmContract-contractAddress-PostRequest-1",
                        "in": "body",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "base_req": {
                                    "type": "object",
                                    "properties": {
                                        "from": {
                                            "description": "Sender address or Keybase name to generate a transaction",
                                            "type": "string",
                                            "example": "cosmos1g9ahr6xhht5rmqven628nklxluzyv8z9jqjcmc"
                                        },
                                        "memo": {
                                            "type": "string",
                                            "example": "Sent via Cosmos Voyager ðŸš€"
                                        },
                                        "chain_id": {
                                            "type": "string",
                                            "example": "Cosmos-Hub"
                                        },
                                        "account_number": {
                                            "type": "string",
                                            "example": "0"
                                        },
                                        "sequence": {
                                            "type": "string",
                                            "example": "1"
                                        },
                                        "gas": {
                                            "type": "string",
                                            "example": "200000"
                                        },
                                        "gas_adjustment": {
                                            "type": "string",
                                            "example": "1.2"
                                        },
                                        "fees": {
                                            "type": "array",
                                            "items": {
                                                "type": "object",
                                                "properties": {
                                                    "denom": {
                                                        "type": "string",
                                                        "example": "stake"
                                                    },
                                                    "amount": {
                                                        "type": "string",
                                                        "example": "50"
                                                    }
                                                }
                                            }
                                        },
                                        "simulate": {
                                            "description": "Estimate gas for a transaction (cannot be used in conjunction with generate_only)",
                                            "type": "boolean",
                                            "example": false
                                        }
                                    }
                                },
                                "coins": {
                                    "type": "array",
                                    "items": {
                                        "type": "object",
                                        "properties": {
                                            "denom": {
                                                "type": "string",
                                                "example": "stake"
                                            },
                                            "amount": {
                                                "type": "string",
                                                "example": "50"
                                            }
                                        }
                                    }
                                },
                                "exec_msg": {
                                    "type": "string",
                                    "example": "{}"
                                }
                            }
                        }
                    }
                ],
                "consumes": [
                    "*/*"
                ],
                "produces": [
                    "application/json"
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "msg": {
                                    "type": "array",
                                    "items": {
                                        "type": "string"
                                    }
                                },
                                "fee": {
                                    "type": "object",
                                    "properties": {
                                        "gas": {
                                            "type": "string"
                                        },
                                        "amount": {
                                            "type": "array",
                                            "items": {
                                                "type": "object",
                                                "properties": {
                                                    "denom": {
                                                        "type": "string",
                                                        "example": "stake"
                                                    },
                                                    "amount": {
                                                        "type": "string",
                                                        "example": "50"
                                                    }
                                                }
                                            }
                                        }
                                    }
                                },
                                "memo": {
                                    "type": "string"
                                },
                                "signature": {
                                    "type": "object",
                                    "properties": {
                                        "signature": {
                                            "type": "string",
                                            "example": "MEUCIQD02fsDPra8MtbRsyB1w7bqTM55Wu138zQbFcWx4+CFyAIge5WNPfKIuvzBZ69MyqHsqD8S1IwiEp+iUb6VSdtlpgY="
                                        },
                                        "pub_key": {
                                            "type": "object",
                                            "properties": {
                                                "type": {
                                                    "type": "string",
                                                    "example": "tendermint/PubKeySecp256k1"
                                                },
                                                "value": {
                                                    "type": "string",
                                                    "example": "Avz04VhtKJh8ACCVzlI8aTosGy0ikFXKIVHQ3jKMrosH"
                                                }
                                            }
                                        },
                                        "account_number": {
                                            "type": "string",
                                            "example": "0"
                                        },
                                        "sequence": {
                                            "type": "string",
                                            "example": "0"
                                        }
                                    }
                                }
                            }
                        },
                        "examples": {
                            "application/json": {
                                "msg": [
                                    "string"
                                ],
                                "fee": {
                                    "gas": "string",
                                    "amount": [
                                        {
                                            "denom": "stake",
                                            "amount": "50"
                                        }
                                    ]
                                },
                                "memo": "string",
                                "signature": {
                                    "signature": "MEUCIQD02fsDPra8MtbRsyB1w7bqTM55Wu138zQbFcWx4+CFyAIge5WNPfKIuvzBZ69MyqHsqD8S1IwiEp+iUb6VSdtlpgY=",
                                    "pub_key": {
                                        "type": "tendermint/PubKeySecp256k1",
                                        "value": "Avz04VhtKJh8ACCVzlI8aTosGy0ikFXKIVHQ3jKMrosH"
                                    },
                                    "account_number": "0",
                                    "sequence": "0"
                                }
                            }
                        }
                    },
                    "400": {
                        "description": "Bad request"
                    },
                    "500": {
                        "description": "Internal Server Error"
                    }
                }
            }
        },
        "/bank/balances/{address}": {
            "get": {
                "description": "Get the account balances",
                "operationId": "get-bank-balances-address",
                "summary": "Get the account balances",
                "tags": [
                    "Bank"
                ],
                "parameters": [
                    {
                        "name": "address",
                        "in": "path",
                        "description": "Account address in bech32 format",
                        "required": true,
                        "type": "string"
                    }
                ],
                "produces": [
                    "application/json"
                ],
                "responses": {
                    "200": {
                        "description": "Account balances",
                        "schema": {
                            "type": "array",
                            "items": {
                                "type": "object",
                                "properties": {
                                    "denom": {
                                        "type": "string",
                                        "example": "stake"
                                    },
                                    "amount": {
                                        "type": "string",
                                        "example": "50"
                                    }
                                }
                            }
                        },
                        "examples": {
                            "application/json": [
                                {
                                    "denom": "stake",
                                    "amount": "50"
                                }
                            ]
                        }
                    },
                    "500": {
                        "description": "Server internal error"
                    }
                }
            }
        },
        "/auth/accounts/{address}": {
            "get": {
                "description": "Get the account information on blockchain",
                "operationId": "get-auth-accounts-address",
                "summary": "Get the account information on blockchain",
                "tags": [
                    "Auth"
                ],
                "parameters": [
                    {
                        "name": "address",
                        "in": "path",
                        "description": "Account address",
                        "required": true,
                        "type": "string"
                    }
                ],
                "produces": [
                    "application/json"
                ],
                "responses": {
                    "200": {
                        "description": "Account information on the blockchain",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "type": {
                                    "type": "string"
                                },
                                "value": {
                                    "type": "object",
                                    "properties": {
                                        "account_number": {
                                            "type": "string"
                                        },
                                        "address": {
                                            "type": "string"
                                        },
                                        "coins": {
                                            "type": "array",
                                            "items": {
                                                "type": "object",
                                                "properties": {
                                                    "denom": {
                                                        "type": "string",
                                                        "example": "stake"
                                                    },
                                                    "amount": {
                                                        "type": "string",
                                                        "example": "50"
                                                    }
                                                }
                                            }
                                        },
                                        "public_key": {
                                            "type": "object",
                                            "properties": {
                                                "type": {
                                                    "type": "string"
                                                },
                                                "value": {
                                                    "type": "string"
                                                }
                                            }
                                        },
                                        "sequence": {
                                            "type": "string"
                                        }
                                    }
                                }
                            }
                        },
                        "examples": {
                            "application/json": {
                                "type": "string",
                                "value": {
                                    "account_number": "string",
                                    "address": "string",
                                    "coins": [
                                        {
                                            "denom": "stake",
                                            "amount": "50"
                                        }
                                    ],
                                    "public_key": {
                                        "type": "string",
                                        "value": "string"
                                    },
                                    "sequence": "string"
                                }
                            }
                        }
                    },
                    "500": {
                        "description": "Server internel error"
                    }
                }
            }
        },
        "/wasm/contract/{contractAddress}/code-hash": {
            "get": {
                "description": "Get stored contract-hash information",
                "operationId": "get-wasm-contract-contractaddress-code-hash-query_msg-query_msg",
                "summary": "Get stored contract-hash information",
                "tags": [
                    "Wasm"
                ],
                "parameters": [
                    {
                        "name": "contractAddress",
                        "in": "path",
                        "description": "contract address you want to lookup",
                        "required": true,
                        "type": "string"
                    }
                ],
                "produces": [
                    "application/json"
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "height": {
                                    "type": "string"
                                },
                                "result": {
                                    "type": "string"
                                }
                            }
                        },
                        "examples": {
                            "application/json": {
                                "height": "string",
                                "result": "string"
                            }
                        }
                    }
                }
            }
        },
        "/bank/total": {
            "get": {
                "description": "Total supply of coins in the chain",
                "operationId": "get-bank-total",
                "summary": "Total supply of coins in the chain",
                "tags": [
                    "Bank"
                ],
                "produces": [
                    "application/json"
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "total": {
                                    "type": "array",
                                    "items": {
                                        "type": "object",
                                        "properties": {
                                            "denom": {
                                                "type": "string",
                                                "example": "stake"
                                            },
                                            "amount": {
                                                "type": "string",
                                                "example": "50"
                                            }
                                        }
                                    }
                                }
                            }
                        },
                        "examples": {
                            "application/json": {
                                "total": [
                                    {
                                        "denom": "stake",
                                        "amount": "50"
                                    }
                                ]
                            }
                        }
                    },
                    "500": {
                        "description": "Internal Server Error"
                    }
                }
            }
        },
        "/bank/total/{denomination}": {
            "get": {
                "description": "Total supply of a single coin denomination",
                "operationId": "get-bank-total-denomination",
                "summary": "Total supply of a single coin denomination",
                "tags": [
                    "Bank"
                ],
                "parameters": [
                    {
                        "name": "denomination",
                        "in": "path",
                        "description": "Coin denomination",
                        "required": true,
                        "type": "string"
                    }
                ],
                "produces": [
                    "application/json"
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "string"
                        },
                        "examples": {
                            "application/json": "string"
                        }
                    },
                    "400": {
                        "description": "Invalid coin denomination"
                    },
                    "500": {
                        "description": "Internal Server Error"
                    }
                }
            }
        },
        "/reg/registration-key": {
            "get": {
                "description": "Gets the network's registration key, which is used to derive a key for a new node during the registration process",
                "operationId": "RegistrationKey",
                "summary": "Get Network Registration Key",
                "tags": [
                    "Reg"
                ],
                "produces": [
                    "*/*"
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "height": {
                                    "type": "string"
                                },
                                "result": {
                                    "type": "object",
                                    "properties": {
                                        "RegistrationKey": {
                                            "type": "string"
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        },
        "/cosmos/auth/v1beta1/accounts": {
            "get": {
                "description": "Accounts returns all the existing accounts",
                "operationId": "Accounts",
                "summary": "Accounts returns all the existing accounts",
                "tags": [
                    "Query"
                ],
                "parameters": [
                    {
                        "name": "pagination.key",
                        "in": "query",
                        "description": "Format - byte. Format - byte. Format - byte. key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
                        "type": "string",
                        "format": "byte"
                    },
                    {
                        "name": "pagination.offset",
                        "in": "query",
                        "description": "Format - uint64. Format - uint64. Format - uint64. offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
                        "type": "string",
                        "format": "uint64"
                    },
                    {
                        "name": "pagination.limit",
                        "in": "query",
                        "description": "Format - uint64. Format - uint64. Format - uint64. limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
                        "type": "string",
                        "format": "uint64"
                    },
                    {
                        "name": "pagination.count_total",
                        "in": "query",
                        "description": "Format - boolean. Format - boolean. Format - boolean. count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
                        "type": "boolean",
                        "format": "boolean"
                    },
                    {
                        "name": "pagination.reverse",
                        "in": "query",
                        "description": "Format - boolean. Format - boolean. Format - boolean. reverse is set to true if results are to be returned in the descending order.",
                        "type": "boolean",
                        "format": "boolean"
                    }
                ],
                "produces": [
                    "*/*"
                ],
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "description": "QueryAccountsResponse is the response type for the Query/Accounts RPC method.",
                            "type": "object",
                            "properties": {
                                "accounts": {
                                    "title": "accounts are the existing accounts",
                                    "type": "array",
                                    "items": {
                                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                },
                                "pagination": {
                                    "description": "pagination defines the pagination in the response.",
                                    "type": "object",
                                    "properties": {
                                        "next_key": {
                                            "format": "byte",
                                            "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently",
                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                            "type": "string"
                                        },
                                        "total": {
                                            "format": "uint64",
                                            "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                                            "type": "string"
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "400": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "500": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        },
        "/cosmos/auth/v1beta1/accounts/{address}": {
            "get": {
                "description": "Account returns account details based on address.",
                "operationId": "Account",
                "summary": "Account returns account details based on address.",
                "tags": [
                    "Query"
                ],
                "parameters": [
                    {
                        "name": "address",
                        "in": "path",
                        "description": "address defines the address to query for.",
                        "required": true,
                        "type": "string"
                    }
                ],
                "produces": [
                    "*/*"
                ],
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "description": "QueryAccountResponse is the response type for the Query/Account RPC method.",
                            "type": "object",
                            "properties": {
                                "account": {
                                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                    "type": "object",
                                    "properties": {
                                        "type_url": {
                                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                            "type": "string"
                                        },
                                        "value": {
                                            "format": "byte",
                                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                            "type": "string"
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "400": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "500": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        },
        "/cosmos/auth/v1beta1/params": {
            "get": {
                "description": "Params queries all parameters.",
                "operationId": "AuthParams",
                "summary": "Params queries all parameters.",
                "tags": [
                    "Query"
                ],
                "produces": [
                    "*/*"
                ],
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "description": "QueryParamsResponse is the response type for the Query/Params RPC method.",
                            "type": "object",
                            "properties": {
                                "params": {
                                    "description": "params defines the parameters of the module.",
                                    "type": "object",
                                    "properties": {
                                        "max_memo_characters": {
                                            "format": "uint64",
                                            "type": "string"
                                        },
                                        "tx_sig_limit": {
                                            "format": "uint64",
                                            "type": "string"
                                        },
                                        "tx_size_cost_per_byte": {
                                            "format": "uint64",
                                            "type": "string"
                                        },
                                        "sig_verify_cost_ed25519": {
                                            "format": "uint64",
                                            "type": "string"
                                        },
                                        "sig_verify_cost_secp256k1": {
                                            "format": "uint64",
                                            "type": "string"
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "400": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "500": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        },
        "/cosmos/bank/v1beta1/balances/{address}": {
            "get": {
                "description": "AllBalances queries the balance of all coins for a single account.",
                "operationId": "AllBalances",
                "summary": "AllBalances queries the balance of all coins for a single account.",
                "tags": [
                    "Query"
                ],
                "parameters": [
                    {
                        "name": "address",
                        "in": "path",
                        "description": "address is the address to query balances for.",
                        "required": true,
                        "type": "string"
                    },
                    {
                        "name": "pagination.key",
                        "in": "query",
                        "description": "Format - byte. Format - byte. Format - byte. key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
                        "type": "string",
                        "format": "byte"
                    },
                    {
                        "name": "pagination.offset",
                        "in": "query",
                        "description": "Format - uint64. Format - uint64. Format - uint64. offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
                        "type": "string",
                        "format": "uint64"
                    },
                    {
                        "name": "pagination.limit",
                        "in": "query",
                        "description": "Format - uint64. Format - uint64. Format - uint64. limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
                        "type": "string",
                        "format": "uint64"
                    },
                    {
                        "name": "pagination.count_total",
                        "in": "query",
                        "description": "Format - boolean. Format - boolean. Format - boolean. count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
                        "type": "boolean",
                        "format": "boolean"
                    },
                    {
                        "name": "pagination.reverse",
                        "in": "query",
                        "description": "Format - boolean. Format - boolean. Format - boolean. reverse is set to true if results are to be returned in the descending order.",
                        "type": "boolean",
                        "format": "boolean"
                    }
                ],
                "produces": [
                    "*/*"
                ],
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "description": "QueryAllBalancesResponse is the response type for the Query/AllBalances RPC\nmethod.",
                            "type": "object",
                            "properties": {
                                "balances": {
                                    "description": "balances is the balances of all the coins.",
                                    "type": "array",
                                    "items": {
                                        "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto.",
                                        "type": "object",
                                        "properties": {
                                            "denom": {
                                                "type": "string"
                                            },
                                            "amount": {
                                                "type": "string"
                                            }
                                        }
                                    }
                                },
                                "pagination": {
                                    "description": "pagination defines the pagination in the response.",
                                    "type": "object",
                                    "properties": {
                                        "next_key": {
                                            "format": "byte",
                                            "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently",
                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                            "type": "string"
                                        },
                                        "total": {
                                            "format": "uint64",
                                            "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                                            "type": "string"
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "400": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "500": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        },
        "/cosmos/bank/v1beta1/balances/{address}/{denom}": {
            "get": {
                "description": "Balance queries the balance of a single coin for a single account.",
                "operationId": "Balance",
                "summary": "Balance queries the balance of a single coin for a single account.",
                "tags": [
                    "Query"
                ],
                "parameters": [
                    {
                        "name": "address",
                        "in": "path",
                        "description": "address is the address to query balances for.",
                        "required": true,
                        "type": "string"
                    },
                    {
                        "name": "denom",
                        "in": "path",
                        "description": "denom is the coin denom to query balances for.",
                        "required": true,
                        "type": "string"
                    }
                ],
                "produces": [
                    "*/*"
                ],
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "description": "QueryBalanceResponse is the response type for the Query/Balance RPC method.",
                            "type": "object",
                            "properties": {
                                "balance": {
                                    "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto.",
                                    "type": "object",
                                    "properties": {
                                        "denom": {
                                            "type": "string"
                                        },
                                        "amount": {
                                            "type": "string"
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "400": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "500": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        },
        "/cosmos/bank/v1beta1/denoms_metadata": {
            "get": {
                "description": "DenomsMetadata queries the client metadata for all registered coin denominations.",
                "operationId": "DenomsMetadata",
                "summary": "DenomsMetadata queries the client metadata for all registered coin denominations.",
                "tags": [
                    "Query"
                ],
                "parameters": [
                    {
                        "name": "pagination.key",
                        "in": "query",
                        "description": "Format - byte. Format - byte. Format - byte. key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
                        "type": "string",
                        "format": "byte"
                    },
                    {
                        "name": "pagination.offset",
                        "in": "query",
                        "description": "Format - uint64. Format - uint64. Format - uint64. offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
                        "type": "string",
                        "format": "uint64"
                    },
                    {
                        "name": "pagination.limit",
                        "in": "query",
                        "description": "Format - uint64. Format - uint64. Format - uint64. limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
                        "type": "string",
                        "format": "uint64"
                    },
                    {
                        "name": "pagination.count_total",
                        "in": "query",
                        "description": "Format - boolean. Format - boolean. Format - boolean. count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
                        "type": "boolean",
                        "format": "boolean"
                    },
                    {
                        "name": "pagination.reverse",
                        "in": "query",
                        "description": "Format - boolean. Format - boolean. Format - boolean. reverse is set to true if results are to be returned in the descending order.",
                        "type": "boolean",
                        "format": "boolean"
                    }
                ],
                "produces": [
                    "*/*"
                ],
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "description": "QueryDenomsMetadataResponse is the response type for the Query/DenomsMetadata RPC\nmethod.",
                            "type": "object",
                            "properties": {
                                "metadatas": {
                                    "description": "metadata provides the client information for all the registered tokens.",
                                    "type": "array",
                                    "items": {
                                        "description": "Metadata represents a struct that describes\na basic token.",
                                        "type": "object",
                                        "properties": {
                                            "description": {
                                                "type": "string"
                                            },
                                            "denom_units": {
                                                "title": "denom_units represents the list of DenomUnit's for a given coin",
                                                "type": "array",
                                                "items": {
                                                    "description": "DenomUnit represents a struct that describes a given\ndenomination unit of the basic token.",
                                                    "type": "object",
                                                    "properties": {
                                                        "denom": {
                                                            "description": "denom represents the string name of the given denom unit (e.g uatom).",
                                                            "type": "string"
                                                        },
                                                        "exponent": {
                                                            "format": "int64",
                                                            "description": "exponent represents power of 10 exponent that one must\nraise the base_denom to in order to equal the given DenomUnit's denom\n1 denom = 1^exponent base_denom\n(e.g. with a base_denom of uatom, one can create a DenomUnit of 'atom' with\nexponent = 6, thus: 1 atom = 10^6 uatom).",
                                                            "type": "integer"
                                                        },
                                                        "aliases": {
                                                            "title": "aliases is a list of string aliases for the given denom",
                                                            "type": "array",
                                                            "items": {
                                                                "type": "string"
                                                            }
                                                        }
                                                    }
                                                }
                                            },
                                            "base": {
                                                "description": "base represents the base denom (should be the DenomUnit with exponent = 0).",
                                                "type": "string"
                                            },
                                            "display": {
                                                "description": "display indicates the suggested denom that should be\ndisplayed in clients.",
                                                "type": "string"
                                            },
                                            "name": {
                                                "title": "name defines the name of the token (eg: Cosmos Atom)",
                                                "type": "string"
                                            },
                                            "symbol": {
                                                "description": "symbol is the token symbol usually shown on exchanges (eg: ATOM). This can\nbe the same as the display.",
                                                "type": "string"
                                            }
                                        }
                                    }
                                },
                                "pagination": {
                                    "description": "pagination defines the pagination in the response.",
                                    "type": "object",
                                    "properties": {
                                        "next_key": {
                                            "format": "byte",
                                            "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently",
                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                            "type": "string"
                                        },
                                        "total": {
                                            "format": "uint64",
                                            "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                                            "type": "string"
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "400": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "500": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        },
        "/cosmos/bank/v1beta1/denoms_metadata/{denom}": {
            "get": {
                "description": "DenomsMetadata queries the client metadata of a given coin denomination.",
                "operationId": "DenomMetadata",
                "summary": "DenomsMetadata queries the client metadata of a given coin denomination.",
                "tags": [
                    "Query"
                ],
                "parameters": [
                    {
                        "name": "denom",
                        "in": "path",
                        "description": "denom is the coin denom to query the metadata for.",
                        "required": true,
                        "type": "string"
                    }
                ],
                "produces": [
                    "*/*"
                ],
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "description": "QueryDenomMetadataResponse is the response type for the Query/DenomMetadata RPC\nmethod.",
                            "type": "object",
                            "properties": {
                                "metadata": {
                                    "description": "Metadata represents a struct that describes\na basic token.",
                                    "type": "object",
                                    "properties": {
                                        "description": {
                                            "type": "string"
                                        },
                                        "denom_units": {
                                            "title": "denom_units represents the list of DenomUnit's for a given coin",
                                            "type": "array",
                                            "items": {
                                                "description": "DenomUnit represents a struct that describes a given\ndenomination unit of the basic token.",
                                                "type": "object",
                                                "properties": {
                                                    "denom": {
                                                        "description": "denom represents the string name of the given denom unit (e.g uatom).",
                                                        "type": "string"
                                                    },
                                                    "exponent": {
                                                        "format": "int64",
                                                        "description": "exponent represents power of 10 exponent that one must\nraise the base_denom to in order to equal the given DenomUnit's denom\n1 denom = 1^exponent base_denom\n(e.g. with a base_denom of uatom, one can create a DenomUnit of 'atom' with\nexponent = 6, thus: 1 atom = 10^6 uatom).",
                                                        "type": "integer"
                                                    },
                                                    "aliases": {
                                                        "title": "aliases is a list of string aliases for the given denom",
                                                        "type": "array",
                                                        "items": {
                                                            "type": "string"
                                                        }
                                                    }
                                                }
                                            }
                                        },
                                        "base": {
                                            "description": "base represents the base denom (should be the DenomUnit with exponent = 0).",
                                            "type": "string"
                                        },
                                        "display": {
                                            "description": "display indicates the suggested denom that should be\ndisplayed in clients.",
                                            "type": "string"
                                        },
                                        "name": {
                                            "title": "name defines the name of the token (eg: Cosmos Atom)",
                                            "type": "string"
                                        },
                                        "symbol": {
                                            "description": "symbol is the token symbol usually shown on exchanges (eg: ATOM). This can\nbe the same as the display.",
                                            "type": "string"
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "400": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "500": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        },
        "/cosmos/bank/v1beta1/params": {
            "get": {
                "description": "Params queries the parameters of x/bank module.",
                "operationId": "BankParams",
                "summary": "Params queries the parameters of x/bank module.",
                "tags": [
                    "Query"
                ],
                "produces": [
                    "*/*"
                ],
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "description": "QueryParamsResponse defines the response type for querying x/bank parameters.",
                            "type": "object",
                            "properties": {
                                "params": {
                                    "description": "Params defines the parameters for the bank module.",
                                    "type": "object",
                                    "properties": {
                                        "send_enabled": {
                                            "type": "array",
                                            "items": {
                                                "description": "SendEnabled maps coin denom to a send_enabled status (whether a denom is\nsendable).",
                                                "type": "object",
                                                "properties": {
                                                    "denom": {
                                                        "type": "string"
                                                    },
                                                    "enabled": {
                                                        "format": "boolean",
                                                        "type": "boolean"
                                                    }
                                                }
                                            }
                                        },
                                        "default_send_enabled": {
                                            "format": "boolean",
                                            "type": "boolean"
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "400": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "500": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        },
        "/cosmos/bank/v1beta1/supply": {
            "get": {
                "description": "TotalSupply queries the total supply of all coins.",
                "operationId": "TotalSupply",
                "summary": "TotalSupply queries the total supply of all coins.",
                "tags": [
                    "Query"
                ],
                "parameters": [
                    {
                        "name": "pagination.key",
                        "in": "query",
                        "description": "Format - byte. Format - byte. Format - byte. key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
                        "type": "string",
                        "format": "byte"
                    },
                    {
                        "name": "pagination.offset",
                        "in": "query",
                        "description": "Format - uint64. Format - uint64. Format - uint64. offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
                        "type": "string",
                        "format": "uint64"
                    },
                    {
                        "name": "pagination.limit",
                        "in": "query",
                        "description": "Format - uint64. Format - uint64. Format - uint64. limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
                        "type": "string",
                        "format": "uint64"
                    },
                    {
                        "name": "pagination.count_total",
                        "in": "query",
                        "description": "Format - boolean. Format - boolean. Format - boolean. count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
                        "type": "boolean",
                        "format": "boolean"
                    },
                    {
                        "name": "pagination.reverse",
                        "in": "query",
                        "description": "Format - boolean. Format - boolean. Format - boolean. reverse is set to true if results are to be returned in the descending order.",
                        "type": "boolean",
                        "format": "boolean"
                    }
                ],
                "produces": [
                    "*/*"
                ],
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "title": "QueryTotalSupplyResponse is the response type for the Query/TotalSupply RPC\nmethod",
                            "type": "object",
                            "properties": {
                                "supply": {
                                    "title": "supply is the supply of the coins",
                                    "type": "array",
                                    "items": {
                                        "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto.",
                                        "type": "object",
                                        "properties": {
                                            "denom": {
                                                "type": "string"
                                            },
                                            "amount": {
                                                "type": "string"
                                            }
                                        }
                                    }
                                },
                                "pagination": {
                                    "description": "pagination defines the pagination in the response.",
                                    "type": "object",
                                    "properties": {
                                        "next_key": {
                                            "format": "byte",
                                            "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently",
                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                            "type": "string"
                                        },
                                        "total": {
                                            "format": "uint64",
                                            "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                                            "type": "string"
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "400": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "500": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        },
        "/cosmos/bank/v1beta1/supply/{denom}": {
            "get": {
                "description": "SupplyOf queries the supply of a single coin.",
                "operationId": "SupplyOf",
                "summary": "SupplyOf queries the supply of a single coin.",
                "tags": [
                    "Query"
                ],
                "parameters": [
                    {
                        "name": "denom",
                        "in": "path",
                        "description": "denom is the coin denom to query balances for.",
                        "required": true,
                        "type": "string"
                    }
                ],
                "produces": [
                    "*/*"
                ],
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "description": "QuerySupplyOfResponse is the response type for the Query/SupplyOf RPC method.",
                            "type": "object",
                            "properties": {
                                "amount": {
                                    "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto.",
                                    "type": "object",
                                    "properties": {
                                        "denom": {
                                            "type": "string"
                                        },
                                        "amount": {
                                            "type": "string"
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "400": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "500": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        },
        "/cosmos/base/tendermint/v1beta1/blocks/latest": {
            "get": {
                "description": "GetLatestBlock returns the latest block.",
                "operationId": "GetLatestBlock",
                "summary": "GetLatestBlock returns the latest block.",
                "tags": [
                    "Service"
                ],
                "produces": [
                    "*/*"
                ],
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "description": "GetLatestBlockResponse is the response type for the Query/GetLatestBlock RPC method.",
                            "type": "object",
                            "properties": {
                                "block_id": {
                                    "title": "BlockID",
                                    "type": "object",
                                    "properties": {
                                        "hash": {
                                            "format": "byte",
                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                            "type": "string"
                                        },
                                        "part_set_header": {
                                            "title": "PartsetHeader",
                                            "type": "object",
                                            "properties": {
                                                "total": {
                                                    "format": "int64",
                                                    "type": "integer"
                                                },
                                                "hash": {
                                                    "format": "byte",
                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                    "type": "string"
                                                }
                                            }
                                        }
                                    }
                                },
                                "block": {
                                    "type": "object",
                                    "properties": {
                                        "header": {
                                            "description": "Header defines the structure of a Tendermint block header.",
                                            "type": "object",
                                            "properties": {
                                                "version": {
                                                    "title": "basic block info",
                                                    "description": "Consensus captures the consensus rules for processing a block in the blockchain,\nincluding all blockchain data structures and the rules of the application's\nstate transition machine.",
                                                    "type": "object",
                                                    "properties": {
                                                        "block": {
                                                            "format": "uint64",
                                                            "type": "string"
                                                        },
                                                        "app": {
                                                            "format": "uint64",
                                                            "type": "string"
                                                        }
                                                    }
                                                },
                                                "chain_id": {
                                                    "type": "string"
                                                },
                                                "height": {
                                                    "format": "int64",
                                                    "type": "string"
                                                },
                                                "time": {
                                                    "format": "date-time",
                                                    "type": "string"
                                                },
                                                "last_block_id": {
                                                    "title": "BlockID",
                                                    "type": "object",
                                                    "properties": {
                                                        "hash": {
                                                            "format": "byte",
                                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                            "type": "string"
                                                        },
                                                        "part_set_header": {
                                                            "title": "PartsetHeader",
                                                            "type": "object",
                                                            "properties": {
                                                                "total": {
                                                                    "format": "int64",
                                                                    "type": "integer"
                                                                },
                                                                "hash": {
                                                                    "format": "byte",
                                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                    "type": "string"
                                                                }
                                                            }
                                                        }
                                                    }
                                                },
                                                "last_commit_hash": {
                                                    "format": "byte",
                                                    "title": "hashes of block data",
                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                    "type": "string"
                                                },
                                                "data_hash": {
                                                    "format": "byte",
                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                    "type": "string"
                                                },
                                                "validators_hash": {
                                                    "format": "byte",
                                                    "title": "hashes from the app output from the prev block",
                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                    "type": "string"
                                                },
                                                "next_validators_hash": {
                                                    "format": "byte",
                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                    "type": "string"
                                                },
                                                "consensus_hash": {
                                                    "format": "byte",
                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                    "type": "string"
                                                },
                                                "app_hash": {
                                                    "format": "byte",
                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                    "type": "string"
                                                },
                                                "last_results_hash": {
                                                    "format": "byte",
                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                    "type": "string"
                                                },
                                                "evidence_hash": {
                                                    "format": "byte",
                                                    "title": "consensus info",
                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                    "type": "string"
                                                },
                                                "proposer_address": {
                                                    "format": "byte",
                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                    "type": "string"
                                                }
                                            }
                                        },
                                        "data": {
                                            "title": "Data contains the set of transactions included in the block",
                                            "type": "object",
                                            "properties": {
                                                "txs": {
                                                    "description": "Txs that will be applied by state @ block.Height+1.\nNOTE: not all txs here are valid.  We're just agreeing on the order first.\nThis means that block.AppHash does not include these txs.",
                                                    "type": "array",
                                                    "items": {
                                                        "format": "byte",
                                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                        "type": "string"
                                                    }
                                                }
                                            }
                                        },
                                        "evidence": {
                                            "type": "object",
                                            "properties": {
                                                "evidence": {
                                                    "type": "array",
                                                    "items": {
                                                        "type": "object",
                                                        "properties": {
                                                            "duplicate_vote_evidence": {
                                                                "description": "DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes.",
                                                                "type": "object",
                                                                "properties": {
                                                                    "vote_a": {
                                                                        "description": "Vote represents a prevote, precommit, or commit vote from validators for\nconsensus.",
                                                                        "type": "object",
                                                                        "properties": {
                                                                            "type": {
                                                                                "description": "SignedMsgType is a type of signed message in the consensus.\n\n - SIGNED_MSG_TYPE_PREVOTE: Votes\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals",
                                                                                "default": "SIGNED_MSG_TYPE_UNKNOWN",
                                                                                "enum": [
                                                                                    "SIGNED_MSG_TYPE_UNKNOWN",
                                                                                    "SIGNED_MSG_TYPE_PREVOTE",
                                                                                    "SIGNED_MSG_TYPE_PRECOMMIT",
                                                                                    "SIGNED_MSG_TYPE_PROPOSAL"
                                                                                ],
                                                                                "type": "string"
                                                                            },
                                                                            "height": {
                                                                                "format": "int64",
                                                                                "type": "string"
                                                                            },
                                                                            "round": {
                                                                                "format": "int32",
                                                                                "type": "integer"
                                                                            },
                                                                            "block_id": {
                                                                                "title": "BlockID",
                                                                                "type": "object",
                                                                                "properties": {
                                                                                    "hash": {
                                                                                        "format": "byte",
                                                                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                        "type": "string"
                                                                                    },
                                                                                    "part_set_header": {
                                                                                        "title": "PartsetHeader",
                                                                                        "type": "object",
                                                                                        "properties": {
                                                                                            "total": {
                                                                                                "format": "int64",
                                                                                                "type": "integer"
                                                                                            },
                                                                                            "hash": {
                                                                                                "format": "byte",
                                                                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                                "type": "string"
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            },
                                                                            "timestamp": {
                                                                                "format": "date-time",
                                                                                "type": "string"
                                                                            },
                                                                            "validator_address": {
                                                                                "format": "byte",
                                                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                "type": "string"
                                                                            },
                                                                            "validator_index": {
                                                                                "format": "int32",
                                                                                "type": "integer"
                                                                            },
                                                                            "signature": {
                                                                                "format": "byte",
                                                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                "type": "string"
                                                                            }
                                                                        }
                                                                    },
                                                                    "vote_b": {
                                                                        "description": "Vote represents a prevote, precommit, or commit vote from validators for\nconsensus.",
                                                                        "type": "object",
                                                                        "properties": {
                                                                            "type": {
                                                                                "description": "SignedMsgType is a type of signed message in the consensus.\n\n - SIGNED_MSG_TYPE_PREVOTE: Votes\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals",
                                                                                "default": "SIGNED_MSG_TYPE_UNKNOWN",
                                                                                "enum": [
                                                                                    "SIGNED_MSG_TYPE_UNKNOWN",
                                                                                    "SIGNED_MSG_TYPE_PREVOTE",
                                                                                    "SIGNED_MSG_TYPE_PRECOMMIT",
                                                                                    "SIGNED_MSG_TYPE_PROPOSAL"
                                                                                ],
                                                                                "type": "string"
                                                                            },
                                                                            "height": {
                                                                                "format": "int64",
                                                                                "type": "string"
                                                                            },
                                                                            "round": {
                                                                                "format": "int32",
                                                                                "type": "integer"
                                                                            },
                                                                            "block_id": {
                                                                                "title": "BlockID",
                                                                                "type": "object",
                                                                                "properties": {
                                                                                    "hash": {
                                                                                        "format": "byte",
                                                                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                        "type": "string"
                                                                                    },
                                                                                    "part_set_header": {
                                                                                        "title": "PartsetHeader",
                                                                                        "type": "object",
                                                                                        "properties": {
                                                                                            "total": {
                                                                                                "format": "int64",
                                                                                                "type": "integer"
                                                                                            },
                                                                                            "hash": {
                                                                                                "format": "byte",
                                                                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                                "type": "string"
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            },
                                                                            "timestamp": {
                                                                                "format": "date-time",
                                                                                "type": "string"
                                                                            },
                                                                            "validator_address": {
                                                                                "format": "byte",
                                                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                "type": "string"
                                                                            },
                                                                            "validator_index": {
                                                                                "format": "int32",
                                                                                "type": "integer"
                                                                            },
                                                                            "signature": {
                                                                                "format": "byte",
                                                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                "type": "string"
                                                                            }
                                                                        }
                                                                    },
                                                                    "total_voting_power": {
                                                                        "format": "int64",
                                                                        "type": "string"
                                                                    },
                                                                    "validator_power": {
                                                                        "format": "int64",
                                                                        "type": "string"
                                                                    },
                                                                    "timestamp": {
                                                                        "format": "date-time",
                                                                        "type": "string"
                                                                    }
                                                                }
                                                            },
                                                            "light_client_attack_evidence": {
                                                                "description": "LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client.",
                                                                "type": "object",
                                                                "properties": {
                                                                    "conflicting_block": {
                                                                        "type": "object",
                                                                        "properties": {
                                                                            "signed_header": {
                                                                                "type": "object",
                                                                                "properties": {
                                                                                    "header": {
                                                                                        "description": "Header defines the structure of a Tendermint block header.",
                                                                                        "type": "object",
                                                                                        "properties": {
                                                                                            "version": {
                                                                                                "title": "basic block info",
                                                                                                "description": "Consensus captures the consensus rules for processing a block in the blockchain,\nincluding all blockchain data structures and the rules of the application's\nstate transition machine.",
                                                                                                "type": "object",
                                                                                                "properties": {
                                                                                                    "block": {
                                                                                                        "format": "uint64",
                                                                                                        "type": "string"
                                                                                                    },
                                                                                                    "app": {
                                                                                                        "format": "uint64",
                                                                                                        "type": "string"
                                                                                                    }
                                                                                                }
                                                                                            },
                                                                                            "chain_id": {
                                                                                                "type": "string"
                                                                                            },
                                                                                            "height": {
                                                                                                "format": "int64",
                                                                                                "type": "string"
                                                                                            },
                                                                                            "time": {
                                                                                                "format": "date-time",
                                                                                                "type": "string"
                                                                                            },
                                                                                            "last_block_id": {
                                                                                                "title": "BlockID",
                                                                                                "type": "object",
                                                                                                "properties": {
                                                                                                    "hash": {
                                                                                                        "format": "byte",
                                                                                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                                        "type": "string"
                                                                                                    },
                                                                                                    "part_set_header": {
                                                                                                        "title": "PartsetHeader",
                                                                                                        "type": "object",
                                                                                                        "properties": {
                                                                                                            "total": {
                                                                                                                "format": "int64",
                                                                                                                "type": "integer"
                                                                                                            },
                                                                                                            "hash": {
                                                                                                                "format": "byte",
                                                                                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                                                "type": "string"
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            },
                                                                                            "last_commit_hash": {
                                                                                                "format": "byte",
                                                                                                "title": "hashes of block data",
                                                                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                                "type": "string"
                                                                                            },
                                                                                            "data_hash": {
                                                                                                "format": "byte",
                                                                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                                "type": "string"
                                                                                            },
                                                                                            "validators_hash": {
                                                                                                "format": "byte",
                                                                                                "title": "hashes from the app output from the prev block",
                                                                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                                "type": "string"
                                                                                            },
                                                                                            "next_validators_hash": {
                                                                                                "format": "byte",
                                                                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                                "type": "string"
                                                                                            },
                                                                                            "consensus_hash": {
                                                                                                "format": "byte",
                                                                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                                "type": "string"
                                                                                            },
                                                                                            "app_hash": {
                                                                                                "format": "byte",
                                                                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                                "type": "string"
                                                                                            },
                                                                                            "last_results_hash": {
                                                                                                "format": "byte",
                                                                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                                "type": "string"
                                                                                            },
                                                                                            "evidence_hash": {
                                                                                                "format": "byte",
                                                                                                "title": "consensus info",
                                                                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                                "type": "string"
                                                                                            },
                                                                                            "proposer_address": {
                                                                                                "format": "byte",
                                                                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                                "type": "string"
                                                                                            }
                                                                                        }
                                                                                    },
                                                                                    "commit": {
                                                                                        "description": "Commit contains the evidence that a block was committed by a set of validators.",
                                                                                        "type": "object",
                                                                                        "properties": {
                                                                                            "height": {
                                                                                                "format": "int64",
                                                                                                "type": "string"
                                                                                            },
                                                                                            "round": {
                                                                                                "format": "int32",
                                                                                                "type": "integer"
                                                                                            },
                                                                                            "block_id": {
                                                                                                "title": "BlockID",
                                                                                                "type": "object",
                                                                                                "properties": {
                                                                                                    "hash": {
                                                                                                        "format": "byte",
                                                                                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                                        "type": "string"
                                                                                                    },
                                                                                                    "part_set_header": {
                                                                                                        "title": "PartsetHeader",
                                                                                                        "type": "object",
                                                                                                        "properties": {
                                                                                                            "total": {
                                                                                                                "format": "int64",
                                                                                                                "type": "integer"
                                                                                                            },
                                                                                                            "hash": {
                                                                                                                "format": "byte",
                                                                                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                                                "type": "string"
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            },
                                                                                            "signatures": {
                                                                                                "type": "array",
                                                                                                "items": {
                                                                                                    "description": "CommitSig is a part of the Vote included in a Commit.",
                                                                                                    "type": "object",
                                                                                                    "properties": {
                                                                                                        "block_id_flag": {
                                                                                                            "title": "BlockIdFlag indicates which BlcokID the signature is for",
                                                                                                            "default": "BLOCK_ID_FLAG_UNKNOWN",
                                                                                                            "enum": [
                                                                                                                "BLOCK_ID_FLAG_UNKNOWN",
                                                                                                                "BLOCK_ID_FLAG_ABSENT",
                                                                                                                "BLOCK_ID_FLAG_COMMIT",
                                                                                                                "BLOCK_ID_FLAG_NIL"
                                                                                                            ],
                                                                                                            "type": "string"
                                                                                                        },
                                                                                                        "validator_address": {
                                                                                                            "format": "byte",
                                                                                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                                            "type": "string"
                                                                                                        },
                                                                                                        "timestamp": {
                                                                                                            "format": "date-time",
                                                                                                            "type": "string"
                                                                                                        },
                                                                                                        "signature": {
                                                                                                            "format": "byte",
                                                                                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                                            "type": "string"
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            },
                                                                            "validator_set": {
                                                                                "type": "object",
                                                                                "properties": {
                                                                                    "validators": {
                                                                                        "type": "array",
                                                                                        "items": {
                                                                                            "type": "object",
                                                                                            "properties": {
                                                                                                "address": {
                                                                                                    "format": "byte",
                                                                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                                    "type": "string"
                                                                                                },
                                                                                                "pub_key": {
                                                                                                    "title": "PublicKey defines the keys available for use with Tendermint Validators",
                                                                                                    "type": "object",
                                                                                                    "properties": {
                                                                                                        "ed25519": {
                                                                                                            "format": "byte",
                                                                                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                                            "type": "string"
                                                                                                        },
                                                                                                        "secp256k1": {
                                                                                                            "format": "byte",
                                                                                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                                            "type": "string"
                                                                                                        }
                                                                                                    }
                                                                                                },
                                                                                                "voting_power": {
                                                                                                    "format": "int64",
                                                                                                    "type": "string"
                                                                                                },
                                                                                                "proposer_priority": {
                                                                                                    "format": "int64",
                                                                                                    "type": "string"
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    },
                                                                                    "proposer": {
                                                                                        "type": "object",
                                                                                        "properties": {
                                                                                            "address": {
                                                                                                "format": "byte",
                                                                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                                "type": "string"
                                                                                            },
                                                                                            "pub_key": {
                                                                                                "title": "PublicKey defines the keys available for use with Tendermint Validators",
                                                                                                "type": "object",
                                                                                                "properties": {
                                                                                                    "ed25519": {
                                                                                                        "format": "byte",
                                                                                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                                        "type": "string"
                                                                                                    },
                                                                                                    "secp256k1": {
                                                                                                        "format": "byte",
                                                                                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                                        "type": "string"
                                                                                                    }
                                                                                                }
                                                                                            },
                                                                                            "voting_power": {
                                                                                                "format": "int64",
                                                                                                "type": "string"
                                                                                            },
                                                                                            "proposer_priority": {
                                                                                                "format": "int64",
                                                                                                "type": "string"
                                                                                            }
                                                                                        }
                                                                                    },
                                                                                    "total_voting_power": {
                                                                                        "format": "int64",
                                                                                        "type": "string"
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    },
                                                                    "common_height": {
                                                                        "format": "int64",
                                                                        "type": "string"
                                                                    },
                                                                    "byzantine_validators": {
                                                                        "type": "array",
                                                                        "items": {
                                                                            "type": "object",
                                                                            "properties": {
                                                                                "address": {
                                                                                    "format": "byte",
                                                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                    "type": "string"
                                                                                },
                                                                                "pub_key": {
                                                                                    "title": "PublicKey defines the keys available for use with Tendermint Validators",
                                                                                    "type": "object",
                                                                                    "properties": {
                                                                                        "ed25519": {
                                                                                            "format": "byte",
                                                                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                            "type": "string"
                                                                                        },
                                                                                        "secp256k1": {
                                                                                            "format": "byte",
                                                                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                            "type": "string"
                                                                                        }
                                                                                    }
                                                                                },
                                                                                "voting_power": {
                                                                                    "format": "int64",
                                                                                    "type": "string"
                                                                                },
                                                                                "proposer_priority": {
                                                                                    "format": "int64",
                                                                                    "type": "string"
                                                                                }
                                                                            }
                                                                        }
                                                                    },
                                                                    "total_voting_power": {
                                                                        "format": "int64",
                                                                        "type": "string"
                                                                    },
                                                                    "timestamp": {
                                                                        "format": "date-time",
                                                                        "type": "string"
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        },
                                        "last_commit": {
                                            "description": "Commit contains the evidence that a block was committed by a set of validators.",
                                            "type": "object",
                                            "properties": {
                                                "height": {
                                                    "format": "int64",
                                                    "type": "string"
                                                },
                                                "round": {
                                                    "format": "int32",
                                                    "type": "integer"
                                                },
                                                "block_id": {
                                                    "title": "BlockID",
                                                    "type": "object",
                                                    "properties": {
                                                        "hash": {
                                                            "format": "byte",
                                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                            "type": "string"
                                                        },
                                                        "part_set_header": {
                                                            "title": "PartsetHeader",
                                                            "type": "object",
                                                            "properties": {
                                                                "total": {
                                                                    "format": "int64",
                                                                    "type": "integer"
                                                                },
                                                                "hash": {
                                                                    "format": "byte",
                                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                    "type": "string"
                                                                }
                                                            }
                                                        }
                                                    }
                                                },
                                                "signatures": {
                                                    "type": "array",
                                                    "items": {
                                                        "description": "CommitSig is a part of the Vote included in a Commit.",
                                                        "type": "object",
                                                        "properties": {
                                                            "block_id_flag": {
                                                                "title": "BlockIdFlag indicates which BlcokID the signature is for",
                                                                "default": "BLOCK_ID_FLAG_UNKNOWN",
                                                                "enum": [
                                                                    "BLOCK_ID_FLAG_UNKNOWN",
                                                                    "BLOCK_ID_FLAG_ABSENT",
                                                                    "BLOCK_ID_FLAG_COMMIT",
                                                                    "BLOCK_ID_FLAG_NIL"
                                                                ],
                                                                "type": "string"
                                                            },
                                                            "validator_address": {
                                                                "format": "byte",
                                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                "type": "string"
                                                            },
                                                            "timestamp": {
                                                                "format": "date-time",
                                                                "type": "string"
                                                            },
                                                            "signature": {
                                                                "format": "byte",
                                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                "type": "string"
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "400": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "500": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        },
        "/cosmos/base/tendermint/v1beta1/blocks/{height}": {
            "get": {
                "description": "GetBlockByHeight queries block for given height.",
                "operationId": "GetBlockByHeight",
                "summary": "GetBlockByHeight queries block for given height.",
                "tags": [
                    "Service"
                ],
                "parameters": [
                    {
                        "name": "height",
                        "in": "path",
                        "description": "Format - int64. Format - int64. Format - int64.",
                        "required": true,
                        "type": "string",
                        "format": "int64"
                    }
                ],
                "produces": [
                    "*/*"
                ],
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "description": "GetBlockByHeightResponse is the response type for the Query/GetBlockByHeight RPC method.",
                            "type": "object",
                            "properties": {
                                "block_id": {
                                    "title": "BlockID",
                                    "type": "object",
                                    "properties": {
                                        "hash": {
                                            "format": "byte",
                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                            "type": "string"
                                        },
                                        "part_set_header": {
                                            "title": "PartsetHeader",
                                            "type": "object",
                                            "properties": {
                                                "total": {
                                                    "format": "int64",
                                                    "type": "integer"
                                                },
                                                "hash": {
                                                    "format": "byte",
                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                    "type": "string"
                                                }
                                            }
                                        }
                                    }
                                },
                                "block": {
                                    "type": "object",
                                    "properties": {
                                        "header": {
                                            "description": "Header defines the structure of a Tendermint block header.",
                                            "type": "object",
                                            "properties": {
                                                "version": {
                                                    "title": "basic block info",
                                                    "description": "Consensus captures the consensus rules for processing a block in the blockchain,\nincluding all blockchain data structures and the rules of the application's\nstate transition machine.",
                                                    "type": "object",
                                                    "properties": {
                                                        "block": {
                                                            "format": "uint64",
                                                            "type": "string"
                                                        },
                                                        "app": {
                                                            "format": "uint64",
                                                            "type": "string"
                                                        }
                                                    }
                                                },
                                                "chain_id": {
                                                    "type": "string"
                                                },
                                                "height": {
                                                    "format": "int64",
                                                    "type": "string"
                                                },
                                                "time": {
                                                    "format": "date-time",
                                                    "type": "string"
                                                },
                                                "last_block_id": {
                                                    "title": "BlockID",
                                                    "type": "object",
                                                    "properties": {
                                                        "hash": {
                                                            "format": "byte",
                                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                            "type": "string"
                                                        },
                                                        "part_set_header": {
                                                            "title": "PartsetHeader",
                                                            "type": "object",
                                                            "properties": {
                                                                "total": {
                                                                    "format": "int64",
                                                                    "type": "integer"
                                                                },
                                                                "hash": {
                                                                    "format": "byte",
                                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                    "type": "string"
                                                                }
                                                            }
                                                        }
                                                    }
                                                },
                                                "last_commit_hash": {
                                                    "format": "byte",
                                                    "title": "hashes of block data",
                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                    "type": "string"
                                                },
                                                "data_hash": {
                                                    "format": "byte",
                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                    "type": "string"
                                                },
                                                "validators_hash": {
                                                    "format": "byte",
                                                    "title": "hashes from the app output from the prev block",
                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                    "type": "string"
                                                },
                                                "next_validators_hash": {
                                                    "format": "byte",
                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                    "type": "string"
                                                },
                                                "consensus_hash": {
                                                    "format": "byte",
                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                    "type": "string"
                                                },
                                                "app_hash": {
                                                    "format": "byte",
                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                    "type": "string"
                                                },
                                                "last_results_hash": {
                                                    "format": "byte",
                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                    "type": "string"
                                                },
                                                "evidence_hash": {
                                                    "format": "byte",
                                                    "title": "consensus info",
                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                    "type": "string"
                                                },
                                                "proposer_address": {
                                                    "format": "byte",
                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                    "type": "string"
                                                }
                                            }
                                        },
                                        "data": {
                                            "title": "Data contains the set of transactions included in the block",
                                            "type": "object",
                                            "properties": {
                                                "txs": {
                                                    "description": "Txs that will be applied by state @ block.Height+1.\nNOTE: not all txs here are valid.  We're just agreeing on the order first.\nThis means that block.AppHash does not include these txs.",
                                                    "type": "array",
                                                    "items": {
                                                        "format": "byte",
                                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                        "type": "string"
                                                    }
                                                }
                                            }
                                        },
                                        "evidence": {
                                            "type": "object",
                                            "properties": {
                                                "evidence": {
                                                    "type": "array",
                                                    "items": {
                                                        "type": "object",
                                                        "properties": {
                                                            "duplicate_vote_evidence": {
                                                                "description": "DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes.",
                                                                "type": "object",
                                                                "properties": {
                                                                    "vote_a": {
                                                                        "description": "Vote represents a prevote, precommit, or commit vote from validators for\nconsensus.",
                                                                        "type": "object",
                                                                        "properties": {
                                                                            "type": {
                                                                                "description": "SignedMsgType is a type of signed message in the consensus.\n\n - SIGNED_MSG_TYPE_PREVOTE: Votes\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals",
                                                                                "default": "SIGNED_MSG_TYPE_UNKNOWN",
                                                                                "enum": [
                                                                                    "SIGNED_MSG_TYPE_UNKNOWN",
                                                                                    "SIGNED_MSG_TYPE_PREVOTE",
                                                                                    "SIGNED_MSG_TYPE_PRECOMMIT",
                                                                                    "SIGNED_MSG_TYPE_PROPOSAL"
                                                                                ],
                                                                                "type": "string"
                                                                            },
                                                                            "height": {
                                                                                "format": "int64",
                                                                                "type": "string"
                                                                            },
                                                                            "round": {
                                                                                "format": "int32",
                                                                                "type": "integer"
                                                                            },
                                                                            "block_id": {
                                                                                "title": "BlockID",
                                                                                "type": "object",
                                                                                "properties": {
                                                                                    "hash": {
                                                                                        "format": "byte",
                                                                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                        "type": "string"
                                                                                    },
                                                                                    "part_set_header": {
                                                                                        "title": "PartsetHeader",
                                                                                        "type": "object",
                                                                                        "properties": {
                                                                                            "total": {
                                                                                                "format": "int64",
                                                                                                "type": "integer"
                                                                                            },
                                                                                            "hash": {
                                                                                                "format": "byte",
                                                                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                                "type": "string"
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            },
                                                                            "timestamp": {
                                                                                "format": "date-time",
                                                                                "type": "string"
                                                                            },
                                                                            "validator_address": {
                                                                                "format": "byte",
                                                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                "type": "string"
                                                                            },
                                                                            "validator_index": {
                                                                                "format": "int32",
                                                                                "type": "integer"
                                                                            },
                                                                            "signature": {
                                                                                "format": "byte",
                                                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                "type": "string"
                                                                            }
                                                                        }
                                                                    },
                                                                    "vote_b": {
                                                                        "description": "Vote represents a prevote, precommit, or commit vote from validators for\nconsensus.",
                                                                        "type": "object",
                                                                        "properties": {
                                                                            "type": {
                                                                                "description": "SignedMsgType is a type of signed message in the consensus.\n\n - SIGNED_MSG_TYPE_PREVOTE: Votes\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals",
                                                                                "default": "SIGNED_MSG_TYPE_UNKNOWN",
                                                                                "enum": [
                                                                                    "SIGNED_MSG_TYPE_UNKNOWN",
                                                                                    "SIGNED_MSG_TYPE_PREVOTE",
                                                                                    "SIGNED_MSG_TYPE_PRECOMMIT",
                                                                                    "SIGNED_MSG_TYPE_PROPOSAL"
                                                                                ],
                                                                                "type": "string"
                                                                            },
                                                                            "height": {
                                                                                "format": "int64",
                                                                                "type": "string"
                                                                            },
                                                                            "round": {
                                                                                "format": "int32",
                                                                                "type": "integer"
                                                                            },
                                                                            "block_id": {
                                                                                "title": "BlockID",
                                                                                "type": "object",
                                                                                "properties": {
                                                                                    "hash": {
                                                                                        "format": "byte",
                                                                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                        "type": "string"
                                                                                    },
                                                                                    "part_set_header": {
                                                                                        "title": "PartsetHeader",
                                                                                        "type": "object",
                                                                                        "properties": {
                                                                                            "total": {
                                                                                                "format": "int64",
                                                                                                "type": "integer"
                                                                                            },
                                                                                            "hash": {
                                                                                                "format": "byte",
                                                                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                                "type": "string"
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            },
                                                                            "timestamp": {
                                                                                "format": "date-time",
                                                                                "type": "string"
                                                                            },
                                                                            "validator_address": {
                                                                                "format": "byte",
                                                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                "type": "string"
                                                                            },
                                                                            "validator_index": {
                                                                                "format": "int32",
                                                                                "type": "integer"
                                                                            },
                                                                            "signature": {
                                                                                "format": "byte",
                                                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                "type": "string"
                                                                            }
                                                                        }
                                                                    },
                                                                    "total_voting_power": {
                                                                        "format": "int64",
                                                                        "type": "string"
                                                                    },
                                                                    "validator_power": {
                                                                        "format": "int64",
                                                                        "type": "string"
                                                                    },
                                                                    "timestamp": {
                                                                        "format": "date-time",
                                                                        "type": "string"
                                                                    }
                                                                }
                                                            },
                                                            "light_client_attack_evidence": {
                                                                "description": "LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client.",
                                                                "type": "object",
                                                                "properties": {
                                                                    "conflicting_block": {
                                                                        "type": "object",
                                                                        "properties": {
                                                                            "signed_header": {
                                                                                "type": "object",
                                                                                "properties": {
                                                                                    "header": {
                                                                                        "description": "Header defines the structure of a Tendermint block header.",
                                                                                        "type": "object",
                                                                                        "properties": {
                                                                                            "version": {
                                                                                                "title": "basic block info",
                                                                                                "description": "Consensus captures the consensus rules for processing a block in the blockchain,\nincluding all blockchain data structures and the rules of the application's\nstate transition machine.",
                                                                                                "type": "object",
                                                                                                "properties": {
                                                                                                    "block": {
                                                                                                        "format": "uint64",
                                                                                                        "type": "string"
                                                                                                    },
                                                                                                    "app": {
                                                                                                        "format": "uint64",
                                                                                                        "type": "string"
                                                                                                    }
                                                                                                }
                                                                                            },
                                                                                            "chain_id": {
                                                                                                "type": "string"
                                                                                            },
                                                                                            "height": {
                                                                                                "format": "int64",
                                                                                                "type": "string"
                                                                                            },
                                                                                            "time": {
                                                                                                "format": "date-time",
                                                                                                "type": "string"
                                                                                            },
                                                                                            "last_block_id": {
                                                                                                "title": "BlockID",
                                                                                                "type": "object",
                                                                                                "properties": {
                                                                                                    "hash": {
                                                                                                        "format": "byte",
                                                                                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                                        "type": "string"
                                                                                                    },
                                                                                                    "part_set_header": {
                                                                                                        "title": "PartsetHeader",
                                                                                                        "type": "object",
                                                                                                        "properties": {
                                                                                                            "total": {
                                                                                                                "format": "int64",
                                                                                                                "type": "integer"
                                                                                                            },
                                                                                                            "hash": {
                                                                                                                "format": "byte",
                                                                                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                                                "type": "string"
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            },
                                                                                            "last_commit_hash": {
                                                                                                "format": "byte",
                                                                                                "title": "hashes of block data",
                                                                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                                "type": "string"
                                                                                            },
                                                                                            "data_hash": {
                                                                                                "format": "byte",
                                                                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                                "type": "string"
                                                                                            },
                                                                                            "validators_hash": {
                                                                                                "format": "byte",
                                                                                                "title": "hashes from the app output from the prev block",
                                                                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                                "type": "string"
                                                                                            },
                                                                                            "next_validators_hash": {
                                                                                                "format": "byte",
                                                                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                                "type": "string"
                                                                                            },
                                                                                            "consensus_hash": {
                                                                                                "format": "byte",
                                                                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                                "type": "string"
                                                                                            },
                                                                                            "app_hash": {
                                                                                                "format": "byte",
                                                                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                                "type": "string"
                                                                                            },
                                                                                            "last_results_hash": {
                                                                                                "format": "byte",
                                                                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                                "type": "string"
                                                                                            },
                                                                                            "evidence_hash": {
                                                                                                "format": "byte",
                                                                                                "title": "consensus info",
                                                                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                                "type": "string"
                                                                                            },
                                                                                            "proposer_address": {
                                                                                                "format": "byte",
                                                                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                                "type": "string"
                                                                                            }
                                                                                        }
                                                                                    },
                                                                                    "commit": {
                                                                                        "description": "Commit contains the evidence that a block was committed by a set of validators.",
                                                                                        "type": "object",
                                                                                        "properties": {
                                                                                            "height": {
                                                                                                "format": "int64",
                                                                                                "type": "string"
                                                                                            },
                                                                                            "round": {
                                                                                                "format": "int32",
                                                                                                "type": "integer"
                                                                                            },
                                                                                            "block_id": {
                                                                                                "title": "BlockID",
                                                                                                "type": "object",
                                                                                                "properties": {
                                                                                                    "hash": {
                                                                                                        "format": "byte",
                                                                                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                                        "type": "string"
                                                                                                    },
                                                                                                    "part_set_header": {
                                                                                                        "title": "PartsetHeader",
                                                                                                        "type": "object",
                                                                                                        "properties": {
                                                                                                            "total": {
                                                                                                                "format": "int64",
                                                                                                                "type": "integer"
                                                                                                            },
                                                                                                            "hash": {
                                                                                                                "format": "byte",
                                                                                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                                                "type": "string"
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            },
                                                                                            "signatures": {
                                                                                                "type": "array",
                                                                                                "items": {
                                                                                                    "description": "CommitSig is a part of the Vote included in a Commit.",
                                                                                                    "type": "object",
                                                                                                    "properties": {
                                                                                                        "block_id_flag": {
                                                                                                            "title": "BlockIdFlag indicates which BlcokID the signature is for",
                                                                                                            "default": "BLOCK_ID_FLAG_UNKNOWN",
                                                                                                            "enum": [
                                                                                                                "BLOCK_ID_FLAG_UNKNOWN",
                                                                                                                "BLOCK_ID_FLAG_ABSENT",
                                                                                                                "BLOCK_ID_FLAG_COMMIT",
                                                                                                                "BLOCK_ID_FLAG_NIL"
                                                                                                            ],
                                                                                                            "type": "string"
                                                                                                        },
                                                                                                        "validator_address": {
                                                                                                            "format": "byte",
                                                                                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                                            "type": "string"
                                                                                                        },
                                                                                                        "timestamp": {
                                                                                                            "format": "date-time",
                                                                                                            "type": "string"
                                                                                                        },
                                                                                                        "signature": {
                                                                                                            "format": "byte",
                                                                                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                                            "type": "string"
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            },
                                                                            "validator_set": {
                                                                                "type": "object",
                                                                                "properties": {
                                                                                    "validators": {
                                                                                        "type": "array",
                                                                                        "items": {
                                                                                            "type": "object",
                                                                                            "properties": {
                                                                                                "address": {
                                                                                                    "format": "byte",
                                                                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                                    "type": "string"
                                                                                                },
                                                                                                "pub_key": {
                                                                                                    "title": "PublicKey defines the keys available for use with Tendermint Validators",
                                                                                                    "type": "object",
                                                                                                    "properties": {
                                                                                                        "ed25519": {
                                                                                                            "format": "byte",
                                                                                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                                            "type": "string"
                                                                                                        },
                                                                                                        "secp256k1": {
                                                                                                            "format": "byte",
                                                                                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                                            "type": "string"
                                                                                                        }
                                                                                                    }
                                                                                                },
                                                                                                "voting_power": {
                                                                                                    "format": "int64",
                                                                                                    "type": "string"
                                                                                                },
                                                                                                "proposer_priority": {
                                                                                                    "format": "int64",
                                                                                                    "type": "string"
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    },
                                                                                    "proposer": {
                                                                                        "type": "object",
                                                                                        "properties": {
                                                                                            "address": {
                                                                                                "format": "byte",
                                                                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                                "type": "string"
                                                                                            },
                                                                                            "pub_key": {
                                                                                                "title": "PublicKey defines the keys available for use with Tendermint Validators",
                                                                                                "type": "object",
                                                                                                "properties": {
                                                                                                    "ed25519": {
                                                                                                        "format": "byte",
                                                                                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                                        "type": "string"
                                                                                                    },
                                                                                                    "secp256k1": {
                                                                                                        "format": "byte",
                                                                                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                                        "type": "string"
                                                                                                    }
                                                                                                }
                                                                                            },
                                                                                            "voting_power": {
                                                                                                "format": "int64",
                                                                                                "type": "string"
                                                                                            },
                                                                                            "proposer_priority": {
                                                                                                "format": "int64",
                                                                                                "type": "string"
                                                                                            }
                                                                                        }
                                                                                    },
                                                                                    "total_voting_power": {
                                                                                        "format": "int64",
                                                                                        "type": "string"
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    },
                                                                    "common_height": {
                                                                        "format": "int64",
                                                                        "type": "string"
                                                                    },
                                                                    "byzantine_validators": {
                                                                        "type": "array",
                                                                        "items": {
                                                                            "type": "object",
                                                                            "properties": {
                                                                                "address": {
                                                                                    "format": "byte",
                                                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                    "type": "string"
                                                                                },
                                                                                "pub_key": {
                                                                                    "title": "PublicKey defines the keys available for use with Tendermint Validators",
                                                                                    "type": "object",
                                                                                    "properties": {
                                                                                        "ed25519": {
                                                                                            "format": "byte",
                                                                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                            "type": "string"
                                                                                        },
                                                                                        "secp256k1": {
                                                                                            "format": "byte",
                                                                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                            "type": "string"
                                                                                        }
                                                                                    }
                                                                                },
                                                                                "voting_power": {
                                                                                    "format": "int64",
                                                                                    "type": "string"
                                                                                },
                                                                                "proposer_priority": {
                                                                                    "format": "int64",
                                                                                    "type": "string"
                                                                                }
                                                                            }
                                                                        }
                                                                    },
                                                                    "total_voting_power": {
                                                                        "format": "int64",
                                                                        "type": "string"
                                                                    },
                                                                    "timestamp": {
                                                                        "format": "date-time",
                                                                        "type": "string"
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        },
                                        "last_commit": {
                                            "description": "Commit contains the evidence that a block was committed by a set of validators.",
                                            "type": "object",
                                            "properties": {
                                                "height": {
                                                    "format": "int64",
                                                    "type": "string"
                                                },
                                                "round": {
                                                    "format": "int32",
                                                    "type": "integer"
                                                },
                                                "block_id": {
                                                    "title": "BlockID",
                                                    "type": "object",
                                                    "properties": {
                                                        "hash": {
                                                            "format": "byte",
                                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                            "type": "string"
                                                        },
                                                        "part_set_header": {
                                                            "title": "PartsetHeader",
                                                            "type": "object",
                                                            "properties": {
                                                                "total": {
                                                                    "format": "int64",
                                                                    "type": "integer"
                                                                },
                                                                "hash": {
                                                                    "format": "byte",
                                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                    "type": "string"
                                                                }
                                                            }
                                                        }
                                                    }
                                                },
                                                "signatures": {
                                                    "type": "array",
                                                    "items": {
                                                        "description": "CommitSig is a part of the Vote included in a Commit.",
                                                        "type": "object",
                                                        "properties": {
                                                            "block_id_flag": {
                                                                "title": "BlockIdFlag indicates which BlcokID the signature is for",
                                                                "default": "BLOCK_ID_FLAG_UNKNOWN",
                                                                "enum": [
                                                                    "BLOCK_ID_FLAG_UNKNOWN",
                                                                    "BLOCK_ID_FLAG_ABSENT",
                                                                    "BLOCK_ID_FLAG_COMMIT",
                                                                    "BLOCK_ID_FLAG_NIL"
                                                                ],
                                                                "type": "string"
                                                            },
                                                            "validator_address": {
                                                                "format": "byte",
                                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                "type": "string"
                                                            },
                                                            "timestamp": {
                                                                "format": "date-time",
                                                                "type": "string"
                                                            },
                                                            "signature": {
                                                                "format": "byte",
                                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                "type": "string"
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "400": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "500": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        },
        "/cosmos/base/tendermint/v1beta1/node_info": {
            "get": {
                "description": "GetNodeInfo queries the current node info.",
                "operationId": "GetNodeInfo",
                "summary": "GetNodeInfo queries the current node info.",
                "tags": [
                    "Service"
                ],
                "produces": [
                    "*/*"
                ],
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "description": "GetNodeInfoResponse is the request type for the Query/GetNodeInfo RPC method.",
                            "type": "object",
                            "properties": {
                                "default_node_info": {
                                    "type": "object",
                                    "properties": {
                                        "protocol_version": {
                                            "type": "object",
                                            "properties": {
                                                "p2p": {
                                                    "format": "uint64",
                                                    "type": "string"
                                                },
                                                "block": {
                                                    "format": "uint64",
                                                    "type": "string"
                                                },
                                                "app": {
                                                    "format": "uint64",
                                                    "type": "string"
                                                }
                                            }
                                        },
                                        "default_node_id": {
                                            "type": "string"
                                        },
                                        "listen_addr": {
                                            "type": "string"
                                        },
                                        "network": {
                                            "type": "string"
                                        },
                                        "version": {
                                            "type": "string"
                                        },
                                        "channels": {
                                            "format": "byte",
                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                            "type": "string"
                                        },
                                        "moniker": {
                                            "type": "string"
                                        },
                                        "other": {
                                            "type": "object",
                                            "properties": {
                                                "tx_index": {
                                                    "type": "string"
                                                },
                                                "rpc_address": {
                                                    "type": "string"
                                                }
                                            }
                                        }
                                    }
                                },
                                "application_version": {
                                    "description": "VersionInfo is the type for the GetNodeInfoResponse message.",
                                    "type": "object",
                                    "properties": {
                                        "name": {
                                            "type": "string"
                                        },
                                        "app_name": {
                                            "type": "string"
                                        },
                                        "version": {
                                            "type": "string"
                                        },
                                        "git_commit": {
                                            "type": "string"
                                        },
                                        "build_tags": {
                                            "type": "string"
                                        },
                                        "go_version": {
                                            "type": "string"
                                        },
                                        "build_deps": {
                                            "type": "array",
                                            "items": {
                                                "title": "Module is the type for VersionInfo",
                                                "type": "object",
                                                "properties": {
                                                    "path": {
                                                        "title": "module path",
                                                        "type": "string"
                                                    },
                                                    "version": {
                                                        "title": "module version",
                                                        "type": "string"
                                                    },
                                                    "sum": {
                                                        "title": "checksum",
                                                        "type": "string"
                                                    }
                                                }
                                            }
                                        },
                                        "cosmos_sdk_version": {
                                            "type": "string"
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "400": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "500": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        },
        "/cosmos/base/tendermint/v1beta1/syncing": {
            "get": {
                "description": "GetSyncing queries node syncing.",
                "operationId": "GetSyncing",
                "summary": "GetSyncing queries node syncing.",
                "tags": [
                    "Service"
                ],
                "produces": [
                    "*/*"
                ],
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "description": "GetSyncingResponse is the response type for the Query/GetSyncing RPC method.",
                            "type": "object",
                            "properties": {
                                "syncing": {
                                    "format": "boolean",
                                    "type": "boolean"
                                }
                            }
                        }
                    },
                    "400": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "500": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        },
        "/cosmos/base/tendermint/v1beta1/validatorsets/latest": {
            "get": {
                "description": "GetLatestValidatorSet queries latest validator-set.",
                "operationId": "GetLatestValidatorSet",
                "summary": "GetLatestValidatorSet queries latest validator-set.",
                "tags": [
                    "Service"
                ],
                "parameters": [
                    {
                        "name": "pagination.key",
                        "in": "query",
                        "description": "Format - byte. Format - byte. Format - byte. key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
                        "type": "string",
                        "format": "byte"
                    },
                    {
                        "name": "pagination.offset",
                        "in": "query",
                        "description": "Format - uint64. Format - uint64. Format - uint64. offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
                        "type": "string",
                        "format": "uint64"
                    },
                    {
                        "name": "pagination.limit",
                        "in": "query",
                        "description": "Format - uint64. Format - uint64. Format - uint64. limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
                        "type": "string",
                        "format": "uint64"
                    },
                    {
                        "name": "pagination.count_total",
                        "in": "query",
                        "description": "Format - boolean. Format - boolean. Format - boolean. count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
                        "type": "boolean",
                        "format": "boolean"
                    },
                    {
                        "name": "pagination.reverse",
                        "in": "query",
                        "description": "Format - boolean. Format - boolean. Format - boolean. reverse is set to true if results are to be returned in the descending order.",
                        "type": "boolean",
                        "format": "boolean"
                    }
                ],
                "produces": [
                    "*/*"
                ],
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "description": "GetLatestValidatorSetResponse is the response type for the Query/GetValidatorSetByHeight RPC method.",
                            "type": "object",
                            "properties": {
                                "block_height": {
                                    "format": "int64",
                                    "type": "string"
                                },
                                "validators": {
                                    "type": "array",
                                    "items": {
                                        "description": "Validator is the type for the validator-set.",
                                        "type": "object",
                                        "properties": {
                                            "address": {
                                                "type": "string"
                                            },
                                            "pub_key": {
                                                "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                                "type": "object",
                                                "properties": {
                                                    "type_url": {
                                                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                        "type": "string"
                                                    },
                                                    "value": {
                                                        "format": "byte",
                                                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                        "type": "string"
                                                    }
                                                }
                                            },
                                            "voting_power": {
                                                "format": "int64",
                                                "type": "string"
                                            },
                                            "proposer_priority": {
                                                "format": "int64",
                                                "type": "string"
                                            }
                                        }
                                    }
                                },
                                "pagination": {
                                    "description": "pagination defines an pagination for the response.",
                                    "type": "object",
                                    "properties": {
                                        "next_key": {
                                            "format": "byte",
                                            "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently",
                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                            "type": "string"
                                        },
                                        "total": {
                                            "format": "uint64",
                                            "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                                            "type": "string"
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "400": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "500": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        },
        "/cosmos/base/tendermint/v1beta1/validatorsets/{height}": {
            "get": {
                "description": "GetValidatorSetByHeight queries validator-set at a given height.",
                "operationId": "GetValidatorSetByHeight",
                "summary": "GetValidatorSetByHeight queries validator-set at a given height.",
                "tags": [
                    "Service"
                ],
                "parameters": [
                    {
                        "name": "height",
                        "in": "path",
                        "description": "Format - int64. Format - int64. Format - int64.",
                        "required": true,
                        "type": "string",
                        "format": "int64"
                    },
                    {
                        "name": "pagination.key",
                        "in": "query",
                        "description": "Format - byte. Format - byte. Format - byte. key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
                        "type": "string",
                        "format": "byte"
                    },
                    {
                        "name": "pagination.offset",
                        "in": "query",
                        "description": "Format - uint64. Format - uint64. Format - uint64. offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
                        "type": "string",
                        "format": "uint64"
                    },
                    {
                        "name": "pagination.limit",
                        "in": "query",
                        "description": "Format - uint64. Format - uint64. Format - uint64. limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
                        "type": "string",
                        "format": "uint64"
                    },
                    {
                        "name": "pagination.count_total",
                        "in": "query",
                        "description": "Format - boolean. Format - boolean. Format - boolean. count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
                        "type": "boolean",
                        "format": "boolean"
                    },
                    {
                        "name": "pagination.reverse",
                        "in": "query",
                        "description": "Format - boolean. Format - boolean. Format - boolean. reverse is set to true if results are to be returned in the descending order.",
                        "type": "boolean",
                        "format": "boolean"
                    }
                ],
                "produces": [
                    "*/*"
                ],
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "description": "GetValidatorSetByHeightResponse is the response type for the Query/GetValidatorSetByHeight RPC method.",
                            "type": "object",
                            "properties": {
                                "block_height": {
                                    "format": "int64",
                                    "type": "string"
                                },
                                "validators": {
                                    "type": "array",
                                    "items": {
                                        "description": "Validator is the type for the validator-set.",
                                        "type": "object",
                                        "properties": {
                                            "address": {
                                                "type": "string"
                                            },
                                            "pub_key": {
                                                "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                                "type": "object",
                                                "properties": {
                                                    "type_url": {
                                                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                        "type": "string"
                                                    },
                                                    "value": {
                                                        "format": "byte",
                                                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                        "type": "string"
                                                    }
                                                }
                                            },
                                            "voting_power": {
                                                "format": "int64",
                                                "type": "string"
                                            },
                                            "proposer_priority": {
                                                "format": "int64",
                                                "type": "string"
                                            }
                                        }
                                    }
                                },
                                "pagination": {
                                    "description": "pagination defines an pagination for the response.",
                                    "type": "object",
                                    "properties": {
                                        "next_key": {
                                            "format": "byte",
                                            "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently",
                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                            "type": "string"
                                        },
                                        "total": {
                                            "format": "uint64",
                                            "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                                            "type": "string"
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "400": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "500": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        },
        "/cosmos/distribution/v1beta1/community_pool": {
            "get": {
                "description": "CommunityPool queries the community pool coins.",
                "operationId": "CommunityPool",
                "summary": "CommunityPool queries the community pool coins.",
                "tags": [
                    "Query"
                ],
                "produces": [
                    "*/*"
                ],
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "description": "QueryCommunityPoolResponse is the response type for the Query/CommunityPool\nRPC method.",
                            "type": "object",
                            "properties": {
                                "pool": {
                                    "description": "pool defines community pool's coins.",
                                    "type": "array",
                                    "items": {
                                        "description": "DecCoin defines a token with a denomination and a decimal amount.\n\nNOTE: The amount field is an Dec which implements the custom method\nsignatures required by gogoproto.",
                                        "type": "object",
                                        "properties": {
                                            "denom": {
                                                "type": "string"
                                            },
                                            "amount": {
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "400": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "500": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        },
        "/cosmos/distribution/v1beta1/delegators/{delegator_address}/rewards": {
            "get": {
                "description": "DelegationTotalRewards queries the total rewards accrued by a each\nvalidator.",
                "operationId": "DelegationTotalRewards",
                "summary": "DelegationTotalRewards queries the total rewards accrued by a each\nvalidator.",
                "tags": [
                    "Query"
                ],
                "parameters": [
                    {
                        "name": "delegator_address",
                        "in": "path",
                        "description": "delegator_address defines the delegator address to query for.",
                        "required": true,
                        "type": "string"
                    }
                ],
                "produces": [
                    "*/*"
                ],
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "description": "QueryDelegationTotalRewardsResponse is the response type for the\nQuery/DelegationTotalRewards RPC method.",
                            "type": "object",
                            "properties": {
                                "rewards": {
                                    "description": "rewards defines all the rewards accrued by a delegator.",
                                    "type": "array",
                                    "items": {
                                        "description": "DelegationDelegatorReward represents the properties\nof a delegator's delegation reward.",
                                        "type": "object",
                                        "properties": {
                                            "validator_address": {
                                                "type": "string"
                                            },
                                            "reward": {
                                                "type": "array",
                                                "items": {
                                                    "description": "DecCoin defines a token with a denomination and a decimal amount.\n\nNOTE: The amount field is an Dec which implements the custom method\nsignatures required by gogoproto.",
                                                    "type": "object",
                                                    "properties": {
                                                        "denom": {
                                                            "type": "string"
                                                        },
                                                        "amount": {
                                                            "type": "string"
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                },
                                "total": {
                                    "description": "total defines the sum of all the rewards.",
                                    "type": "array",
                                    "items": {
                                        "description": "DecCoin defines a token with a denomination and a decimal amount.\n\nNOTE: The amount field is an Dec which implements the custom method\nsignatures required by gogoproto.",
                                        "type": "object",
                                        "properties": {
                                            "denom": {
                                                "type": "string"
                                            },
                                            "amount": {
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "400": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "500": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        },
        "/cosmos/distribution/v1beta1/delegators/{delegator_address}/rewards/{validator_address}": {
            "get": {
                "description": "DelegationRewards queries the total rewards accrued by a delegation.",
                "operationId": "DelegationRewards",
                "summary": "DelegationRewards queries the total rewards accrued by a delegation.",
                "tags": [
                    "Query"
                ],
                "parameters": [
                    {
                        "name": "delegator_address",
                        "in": "path",
                        "description": "delegator_address defines the delegator address to query for.",
                        "required": true,
                        "type": "string"
                    },
                    {
                        "name": "validator_address",
                        "in": "path",
                        "description": "validator_address defines the validator address to query for.",
                        "required": true,
                        "type": "string"
                    }
                ],
                "produces": [
                    "*/*"
                ],
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "description": "QueryDelegationRewardsResponse is the response type for the\nQuery/DelegationRewards RPC method.",
                            "type": "object",
                            "properties": {
                                "rewards": {
                                    "description": "rewards defines the rewards accrued by a delegation.",
                                    "type": "array",
                                    "items": {
                                        "description": "DecCoin defines a token with a denomination and a decimal amount.\n\nNOTE: The amount field is an Dec which implements the custom method\nsignatures required by gogoproto.",
                                        "type": "object",
                                        "properties": {
                                            "denom": {
                                                "type": "string"
                                            },
                                            "amount": {
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "400": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "500": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        },
        "/cosmos/distribution/v1beta1/delegators/{delegator_address}/validators": {
            "get": {
                "description": "DelegatorValidators queries the validators of a delegator.",
                "operationId": "DelegatorValidators",
                "summary": "DelegatorValidators queries the validators of a delegator.",
                "tags": [
                    "Query"
                ],
                "parameters": [
                    {
                        "name": "delegator_address",
                        "in": "path",
                        "description": "delegator_address defines the delegator address to query for.",
                        "required": true,
                        "type": "string"
                    }
                ],
                "produces": [
                    "*/*"
                ],
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "description": "QueryDelegatorValidatorsResponse is the response type for the\nQuery/DelegatorValidators RPC method.",
                            "type": "object",
                            "properties": {
                                "validators": {
                                    "description": "validators defines the validators a delegator is delegating for.",
                                    "type": "array",
                                    "items": {
                                        "type": "string"
                                    }
                                }
                            }
                        }
                    },
                    "400": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "500": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        },
        "/cosmos/distribution/v1beta1/delegators/{delegator_address}/withdraw_address": {
            "get": {
                "description": "DelegatorWithdrawAddress queries withdraw address of a delegator.",
                "operationId": "DelegatorWithdrawAddress",
                "summary": "DelegatorWithdrawAddress queries withdraw address of a delegator.",
                "tags": [
                    "Query"
                ],
                "parameters": [
                    {
                        "name": "delegator_address",
                        "in": "path",
                        "description": "delegator_address defines the delegator address to query for.",
                        "required": true,
                        "type": "string"
                    }
                ],
                "produces": [
                    "*/*"
                ],
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "description": "QueryDelegatorWithdrawAddressResponse is the response type for the\nQuery/DelegatorWithdrawAddress RPC method.",
                            "type": "object",
                            "properties": {
                                "withdraw_address": {
                                    "description": "withdraw_address defines the delegator address to query for.",
                                    "type": "string"
                                }
                            }
                        }
                    },
                    "400": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "500": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        },
        "/cosmos/distribution/v1beta1/foundation_tax": {
            "get": {
                "description": "DelegatorWithdrawAddress queries withdraw address of a delegator.",
                "operationId": "FoundationTax",
                "summary": "DelegatorWithdrawAddress queries withdraw address of a delegator.",
                "tags": [
                    "Query"
                ],
                "produces": [
                    "*/*"
                ],
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "description": "QueryDelegatorWithdrawAddressResponse is the response type for the\nQuery/DelegatorWithdrawAddress RPC method.",
                            "type": "object",
                            "properties": {
                                "tax": {
                                    "description": "withdraw_address defines the delegator address to query for.",
                                    "type": "string"
                                },
                                "foundation_address": {
                                    "type": "string"
                                }
                            }
                        }
                    },
                    "400": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "500": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        },
        "/cosmos/distribution/v1beta1/params": {
            "get": {
                "description": "Params queries params of the distribution module.",
                "operationId": "DistributionParams",
                "summary": "Params queries params of the distribution module.",
                "tags": [
                    "Query"
                ],
                "produces": [
                    "*/*"
                ],
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "description": "QueryParamsResponse is the response type for the Query/Params RPC method.",
                            "type": "object",
                            "properties": {
                                "params": {
                                    "description": "params defines the parameters of the module.",
                                    "type": "object",
                                    "properties": {
                                        "community_tax": {
                                            "type": "string"
                                        },
                                        "base_proposer_reward": {
                                            "type": "string"
                                        },
                                        "bonus_proposer_reward": {
                                            "type": "string"
                                        },
                                        "withdraw_addr_enabled": {
                                            "format": "boolean",
                                            "type": "boolean"
                                        },
                                        "secret_foundation_tax": {
                                            "type": "string"
                                        },
                                        "secret_foundation_address": {
                                            "type": "string"
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "400": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "500": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        },
        "/cosmos/distribution/v1beta1/validators/{validator_address}/commission": {
            "get": {
                "description": "ValidatorCommission queries accumulated commission for a validator.",
                "operationId": "ValidatorCommission",
                "summary": "ValidatorCommission queries accumulated commission for a validator.",
                "tags": [
                    "Query"
                ],
                "parameters": [
                    {
                        "name": "validator_address",
                        "in": "path",
                        "description": "validator_address defines the validator address to query for.",
                        "required": true,
                        "type": "string"
                    }
                ],
                "produces": [
                    "*/*"
                ],
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "title": "QueryValidatorCommissionResponse is the response type for the\nQuery/ValidatorCommission RPC method",
                            "type": "object",
                            "properties": {
                                "commission": {
                                    "description": "commission defines the commision the validator received.",
                                    "type": "object",
                                    "properties": {
                                        "commission": {
                                            "type": "array",
                                            "items": {
                                                "description": "DecCoin defines a token with a denomination and a decimal amount.\n\nNOTE: The amount field is an Dec which implements the custom method\nsignatures required by gogoproto.",
                                                "type": "object",
                                                "properties": {
                                                    "denom": {
                                                        "type": "string"
                                                    },
                                                    "amount": {
                                                        "type": "string"
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "400": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "500": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        },
        "/cosmos/distribution/v1beta1/validators/{validator_address}/outstanding_rewards": {
            "get": {
                "description": "ValidatorOutstandingRewards queries rewards of a validator address.",
                "operationId": "ValidatorOutstandingRewards",
                "summary": "ValidatorOutstandingRewards queries rewards of a validator address.",
                "tags": [
                    "Query"
                ],
                "parameters": [
                    {
                        "name": "validator_address",
                        "in": "path",
                        "description": "validator_address defines the validator address to query for.",
                        "required": true,
                        "type": "string"
                    }
                ],
                "produces": [
                    "*/*"
                ],
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "description": "QueryValidatorOutstandingRewardsResponse is the response type for the\nQuery/ValidatorOutstandingRewards RPC method.",
                            "type": "object",
                            "properties": {
                                "rewards": {
                                    "description": "ValidatorOutstandingRewards represents outstanding (un-withdrawn) rewards\nfor a validator inexpensive to track, allows simple sanity checks.",
                                    "type": "object",
                                    "properties": {
                                        "rewards": {
                                            "type": "array",
                                            "items": {
                                                "description": "DecCoin defines a token with a denomination and a decimal amount.\n\nNOTE: The amount field is an Dec which implements the custom method\nsignatures required by gogoproto.",
                                                "type": "object",
                                                "properties": {
                                                    "denom": {
                                                        "type": "string"
                                                    },
                                                    "amount": {
                                                        "type": "string"
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "400": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "500": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        },
        "/cosmos/distribution/v1beta1/validators/{validator_address}/slashes": {
            "get": {
                "description": "ValidatorSlashes queries slash events of a validator.",
                "operationId": "ValidatorSlashes",
                "summary": "ValidatorSlashes queries slash events of a validator.",
                "tags": [
                    "Query"
                ],
                "parameters": [
                    {
                        "name": "validator_address",
                        "in": "path",
                        "description": "validator_address defines the validator address to query for.",
                        "required": true,
                        "type": "string"
                    },
                    {
                        "name": "starting_height",
                        "in": "query",
                        "description": "Format - uint64. Format - uint64. Format - uint64. starting_height defines the optional starting height to query the slashes.",
                        "type": "string",
                        "format": "uint64"
                    },
                    {
                        "name": "ending_height",
                        "in": "query",
                        "description": "Format - uint64. Format - uint64. Format - uint64. starting_height defines the optional ending height to query the slashes.",
                        "type": "string",
                        "format": "uint64"
                    },
                    {
                        "name": "pagination.key",
                        "in": "query",
                        "description": "Format - byte. Format - byte. Format - byte. key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
                        "type": "string",
                        "format": "byte"
                    },
                    {
                        "name": "pagination.offset",
                        "in": "query",
                        "description": "Format - uint64. Format - uint64. Format - uint64. offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
                        "type": "string",
                        "format": "uint64"
                    },
                    {
                        "name": "pagination.limit",
                        "in": "query",
                        "description": "Format - uint64. Format - uint64. Format - uint64. limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
                        "type": "string",
                        "format": "uint64"
                    },
                    {
                        "name": "pagination.count_total",
                        "in": "query",
                        "description": "Format - boolean. Format - boolean. Format - boolean. count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
                        "type": "boolean",
                        "format": "boolean"
                    },
                    {
                        "name": "pagination.reverse",
                        "in": "query",
                        "description": "Format - boolean. Format - boolean. Format - boolean. reverse is set to true if results are to be returned in the descending order.",
                        "type": "boolean",
                        "format": "boolean"
                    }
                ],
                "produces": [
                    "*/*"
                ],
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "description": "QueryValidatorSlashesResponse is the response type for the\nQuery/ValidatorSlashes RPC method.",
                            "type": "object",
                            "properties": {
                                "slashes": {
                                    "description": "slashes defines the slashes the validator received.",
                                    "type": "array",
                                    "items": {
                                        "description": "ValidatorSlashEvent represents a validator slash event.\nHeight is implicit within the store key.\nThis is needed to calculate appropriate amount of staking tokens\nfor delegations which are withdrawn after a slash has occurred.",
                                        "type": "object",
                                        "properties": {
                                            "validator_period": {
                                                "format": "uint64",
                                                "type": "string"
                                            },
                                            "fraction": {
                                                "type": "string"
                                            }
                                        }
                                    }
                                },
                                "pagination": {
                                    "description": "pagination defines the pagination in the response.",
                                    "type": "object",
                                    "properties": {
                                        "next_key": {
                                            "format": "byte",
                                            "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently",
                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                            "type": "string"
                                        },
                                        "total": {
                                            "format": "uint64",
                                            "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                                            "type": "string"
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "400": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "500": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        },
        "/cosmos/evidence/v1beta1/evidence": {
            "get": {
                "description": "AllEvidence queries all evidence.",
                "operationId": "AllEvidence",
                "summary": "AllEvidence queries all evidence.",
                "tags": [
                    "Query"
                ],
                "parameters": [
                    {
                        "name": "pagination.key",
                        "in": "query",
                        "description": "Format - byte. Format - byte. Format - byte. key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
                        "type": "string",
                        "format": "byte"
                    },
                    {
                        "name": "pagination.offset",
                        "in": "query",
                        "description": "Format - uint64. Format - uint64. Format - uint64. offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
                        "type": "string",
                        "format": "uint64"
                    },
                    {
                        "name": "pagination.limit",
                        "in": "query",
                        "description": "Format - uint64. Format - uint64. Format - uint64. limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
                        "type": "string",
                        "format": "uint64"
                    },
                    {
                        "name": "pagination.count_total",
                        "in": "query",
                        "description": "Format - boolean. Format - boolean. Format - boolean. count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
                        "type": "boolean",
                        "format": "boolean"
                    },
                    {
                        "name": "pagination.reverse",
                        "in": "query",
                        "description": "Format - boolean. Format - boolean. Format - boolean. reverse is set to true if results are to be returned in the descending order.",
                        "type": "boolean",
                        "format": "boolean"
                    }
                ],
                "produces": [
                    "*/*"
                ],
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "description": "QueryAllEvidenceResponse is the response type for the Query/AllEvidence RPC\nmethod.",
                            "type": "object",
                            "properties": {
                                "evidence": {
                                    "description": "evidence returns all evidences.",
                                    "type": "array",
                                    "items": {
                                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                },
                                "pagination": {
                                    "description": "pagination defines the pagination in the response.",
                                    "type": "object",
                                    "properties": {
                                        "next_key": {
                                            "format": "byte",
                                            "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently",
                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                            "type": "string"
                                        },
                                        "total": {
                                            "format": "uint64",
                                            "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                                            "type": "string"
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "400": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "500": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        },
        "/cosmos/evidence/v1beta1/evidence/{evidence_hash}": {
            "get": {
                "description": "Evidence queries evidence based on evidence hash.",
                "operationId": "Evidence",
                "summary": "Evidence queries evidence based on evidence hash.",
                "tags": [
                    "Query"
                ],
                "parameters": [
                    {
                        "name": "evidence_hash",
                        "in": "path",
                        "description": "Format - byte. Format - byte. Format - byte. evidence_hash defines the hash of the requested evidence.",
                        "required": true,
                        "type": "string",
                        "format": "byte"
                    }
                ],
                "produces": [
                    "*/*"
                ],
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "description": "QueryEvidenceResponse is the response type for the Query/Evidence RPC method.",
                            "type": "object",
                            "properties": {
                                "evidence": {
                                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                    "type": "object",
                                    "properties": {
                                        "type_url": {
                                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                            "type": "string"
                                        },
                                        "value": {
                                            "format": "byte",
                                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                            "type": "string"
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "400": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "500": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        },
        "/cosmos/gov/v1beta1/params/{params_type}": {
            "get": {
                "description": "Params queries all parameters of the gov module.",
                "operationId": "GovParams",
                "summary": "Params queries all parameters of the gov module.",
                "tags": [
                    "Query"
                ],
                "parameters": [
                    {
                        "name": "params_type",
                        "in": "path",
                        "description": "params_type defines which parameters to query for, can be one of \"voting\",\n\"tallying\" or \"deposit\".",
                        "required": true,
                        "type": "string"
                    }
                ],
                "produces": [
                    "*/*"
                ],
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "description": "QueryParamsResponse is the response type for the Query/Params RPC method.",
                            "type": "object",
                            "properties": {
                                "voting_params": {
                                    "description": "voting_params defines the parameters related to voting.",
                                    "type": "object",
                                    "properties": {
                                        "voting_period": {
                                            "description": "Length of the voting period.",
                                            "type": "string"
                                        }
                                    }
                                },
                                "deposit_params": {
                                    "description": "deposit_params defines the parameters related to deposit.",
                                    "type": "object",
                                    "properties": {
                                        "min_deposit": {
                                            "description": "Minimum deposit for a proposal to enter voting period.",
                                            "type": "array",
                                            "items": {
                                                "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto.",
                                                "type": "object",
                                                "properties": {
                                                    "denom": {
                                                        "type": "string"
                                                    },
                                                    "amount": {
                                                        "type": "string"
                                                    }
                                                }
                                            }
                                        },
                                        "max_deposit_period": {
                                            "description": "Maximum period for Atom holders to deposit on a proposal. Initial value: 2\n months.",
                                            "type": "string"
                                        }
                                    }
                                },
                                "tally_params": {
                                    "description": "tally_params defines the parameters related to tally.",
                                    "type": "object",
                                    "properties": {
                                        "quorum": {
                                            "format": "byte",
                                            "description": "Minimum percentage of total stake needed to vote for a result to be\n considered valid.",
                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                            "type": "string"
                                        },
                                        "threshold": {
                                            "format": "byte",
                                            "description": "Minimum proportion of Yes votes for proposal to pass. Default value: 0.5.",
                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                            "type": "string"
                                        },
                                        "veto_threshold": {
                                            "format": "byte",
                                            "description": "Minimum value of Veto votes to Total votes ratio for proposal to be\n vetoed. Default value: 1/3.",
                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                            "type": "string"
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "400": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "500": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        },
        "/cosmos/gov/v1beta1/proposals": {
            "get": {
                "description": "Proposals queries all proposals based on given status.",
                "operationId": "Proposals",
                "summary": "Proposals queries all proposals based on given status.",
                "tags": [
                    "Query"
                ],
                "parameters": [
                    {
                        "name": "proposal_status",
                        "in": "query",
                        "description": "proposal_status defines the status of the proposals.\n\n - PROPOSAL_STATUS_UNSPECIFIED: PROPOSAL_STATUS_UNSPECIFIED defines the default propopsal status.\n - PROPOSAL_STATUS_DEPOSIT_PERIOD: PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit\nperiod.\n - PROPOSAL_STATUS_VOTING_PERIOD: PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting\nperiod.\n - PROPOSAL_STATUS_PASSED: PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has\npassed.\n - PROPOSAL_STATUS_REJECTED: PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has\nbeen rejected.\n - PROPOSAL_STATUS_FAILED: PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has\nfailed.",
                        "type": "string",
                        "default": "PROPOSAL_STATUS_UNSPECIFIED",
                        "enum": [
                            "PROPOSAL_STATUS_UNSPECIFIED",
                            "PROPOSAL_STATUS_DEPOSIT_PERIOD",
                            "PROPOSAL_STATUS_VOTING_PERIOD",
                            "PROPOSAL_STATUS_PASSED",
                            "PROPOSAL_STATUS_REJECTED",
                            "PROPOSAL_STATUS_FAILED"
                        ]
                    },
                    {
                        "name": "voter",
                        "in": "query",
                        "description": "voter defines the voter address for the proposals.",
                        "type": "string"
                    },
                    {
                        "name": "depositor",
                        "in": "query",
                        "description": "depositor defines the deposit addresses from the proposals.",
                        "type": "string"
                    },
                    {
                        "name": "pagination.key",
                        "in": "query",
                        "description": "Format - byte. Format - byte. Format - byte. key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
                        "type": "string",
                        "format": "byte"
                    },
                    {
                        "name": "pagination.offset",
                        "in": "query",
                        "description": "Format - uint64. Format - uint64. Format - uint64. offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
                        "type": "string",
                        "format": "uint64"
                    },
                    {
                        "name": "pagination.limit",
                        "in": "query",
                        "description": "Format - uint64. Format - uint64. Format - uint64. limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
                        "type": "string",
                        "format": "uint64"
                    },
                    {
                        "name": "pagination.count_total",
                        "in": "query",
                        "description": "Format - boolean. Format - boolean. Format - boolean. count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
                        "type": "boolean",
                        "format": "boolean"
                    },
                    {
                        "name": "pagination.reverse",
                        "in": "query",
                        "description": "Format - boolean. Format - boolean. Format - boolean. reverse is set to true if results are to be returned in the descending order.",
                        "type": "boolean",
                        "format": "boolean"
                    }
                ],
                "produces": [
                    "*/*"
                ],
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "description": "QueryProposalsResponse is the response type for the Query/Proposals RPC\nmethod.",
                            "type": "object",
                            "properties": {
                                "proposals": {
                                    "type": "array",
                                    "items": {
                                        "description": "Proposal defines the core field members of a governance proposal.",
                                        "type": "object",
                                        "properties": {
                                            "proposal_id": {
                                                "format": "uint64",
                                                "type": "string"
                                            },
                                            "content": {
                                                "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                                "type": "object",
                                                "properties": {
                                                    "type_url": {
                                                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                        "type": "string"
                                                    },
                                                    "value": {
                                                        "format": "byte",
                                                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                        "type": "string"
                                                    }
                                                }
                                            },
                                            "status": {
                                                "description": "ProposalStatus enumerates the valid statuses of a proposal.\n\n - PROPOSAL_STATUS_UNSPECIFIED: PROPOSAL_STATUS_UNSPECIFIED defines the default propopsal status.\n - PROPOSAL_STATUS_DEPOSIT_PERIOD: PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit\nperiod.\n - PROPOSAL_STATUS_VOTING_PERIOD: PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting\nperiod.\n - PROPOSAL_STATUS_PASSED: PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has\npassed.\n - PROPOSAL_STATUS_REJECTED: PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has\nbeen rejected.\n - PROPOSAL_STATUS_FAILED: PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has\nfailed.",
                                                "default": "PROPOSAL_STATUS_UNSPECIFIED",
                                                "enum": [
                                                    "PROPOSAL_STATUS_UNSPECIFIED",
                                                    "PROPOSAL_STATUS_DEPOSIT_PERIOD",
                                                    "PROPOSAL_STATUS_VOTING_PERIOD",
                                                    "PROPOSAL_STATUS_PASSED",
                                                    "PROPOSAL_STATUS_REJECTED",
                                                    "PROPOSAL_STATUS_FAILED"
                                                ],
                                                "type": "string"
                                            },
                                            "final_tally_result": {
                                                "description": "TallyResult defines a standard tally for a governance proposal.",
                                                "type": "object",
                                                "properties": {
                                                    "yes": {
                                                        "type": "string"
                                                    },
                                                    "abstain": {
                                                        "type": "string"
                                                    },
                                                    "no": {
                                                        "type": "string"
                                                    },
                                                    "no_with_veto": {
                                                        "type": "string"
                                                    }
                                                }
                                            },
                                            "submit_time": {
                                                "format": "date-time",
                                                "type": "string"
                                            },
                                            "deposit_end_time": {
                                                "format": "date-time",
                                                "type": "string"
                                            },
                                            "total_deposit": {
                                                "type": "array",
                                                "items": {
                                                    "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto.",
                                                    "type": "object",
                                                    "properties": {
                                                        "denom": {
                                                            "type": "string"
                                                        },
                                                        "amount": {
                                                            "type": "string"
                                                        }
                                                    }
                                                }
                                            },
                                            "voting_start_time": {
                                                "format": "date-time",
                                                "type": "string"
                                            },
                                            "voting_end_time": {
                                                "format": "date-time",
                                                "type": "string"
                                            }
                                        }
                                    }
                                },
                                "pagination": {
                                    "description": "pagination defines the pagination in the response.",
                                    "type": "object",
                                    "properties": {
                                        "next_key": {
                                            "format": "byte",
                                            "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently",
                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                            "type": "string"
                                        },
                                        "total": {
                                            "format": "uint64",
                                            "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                                            "type": "string"
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "400": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "500": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        },
        "/cosmos/gov/v1beta1/proposals/{proposal_id}": {
            "get": {
                "description": "Proposal queries proposal details based on ProposalID.",
                "operationId": "Proposal",
                "summary": "Proposal queries proposal details based on ProposalID.",
                "tags": [
                    "Query"
                ],
                "parameters": [
                    {
                        "name": "proposal_id",
                        "in": "path",
                        "description": "Format - uint64. Format - uint64. Format - uint64. proposal_id defines the unique id of the proposal.",
                        "required": true,
                        "type": "string",
                        "format": "uint64"
                    }
                ],
                "produces": [
                    "*/*"
                ],
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "description": "QueryProposalResponse is the response type for the Query/Proposal RPC method.",
                            "type": "object",
                            "properties": {
                                "proposal": {
                                    "description": "Proposal defines the core field members of a governance proposal.",
                                    "type": "object",
                                    "properties": {
                                        "proposal_id": {
                                            "format": "uint64",
                                            "type": "string"
                                        },
                                        "content": {
                                            "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                            "type": "object",
                                            "properties": {
                                                "type_url": {
                                                    "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                    "type": "string"
                                                },
                                                "value": {
                                                    "format": "byte",
                                                    "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                    "type": "string"
                                                }
                                            }
                                        },
                                        "status": {
                                            "description": "ProposalStatus enumerates the valid statuses of a proposal.\n\n - PROPOSAL_STATUS_UNSPECIFIED: PROPOSAL_STATUS_UNSPECIFIED defines the default propopsal status.\n - PROPOSAL_STATUS_DEPOSIT_PERIOD: PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit\nperiod.\n - PROPOSAL_STATUS_VOTING_PERIOD: PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting\nperiod.\n - PROPOSAL_STATUS_PASSED: PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has\npassed.\n - PROPOSAL_STATUS_REJECTED: PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has\nbeen rejected.\n - PROPOSAL_STATUS_FAILED: PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has\nfailed.",
                                            "default": "PROPOSAL_STATUS_UNSPECIFIED",
                                            "enum": [
                                                "PROPOSAL_STATUS_UNSPECIFIED",
                                                "PROPOSAL_STATUS_DEPOSIT_PERIOD",
                                                "PROPOSAL_STATUS_VOTING_PERIOD",
                                                "PROPOSAL_STATUS_PASSED",
                                                "PROPOSAL_STATUS_REJECTED",
                                                "PROPOSAL_STATUS_FAILED"
                                            ],
                                            "type": "string"
                                        },
                                        "final_tally_result": {
                                            "description": "TallyResult defines a standard tally for a governance proposal.",
                                            "type": "object",
                                            "properties": {
                                                "yes": {
                                                    "type": "string"
                                                },
                                                "abstain": {
                                                    "type": "string"
                                                },
                                                "no": {
                                                    "type": "string"
                                                },
                                                "no_with_veto": {
                                                    "type": "string"
                                                }
                                            }
                                        },
                                        "submit_time": {
                                            "format": "date-time",
                                            "type": "string"
                                        },
                                        "deposit_end_time": {
                                            "format": "date-time",
                                            "type": "string"
                                        },
                                        "total_deposit": {
                                            "type": "array",
                                            "items": {
                                                "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto.",
                                                "type": "object",
                                                "properties": {
                                                    "denom": {
                                                        "type": "string"
                                                    },
                                                    "amount": {
                                                        "type": "string"
                                                    }
                                                }
                                            }
                                        },
                                        "voting_start_time": {
                                            "format": "date-time",
                                            "type": "string"
                                        },
                                        "voting_end_time": {
                                            "format": "date-time",
                                            "type": "string"
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "400": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "500": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        },
        "/cosmos/gov/v1beta1/proposals/{proposal_id}/deposits": {
            "get": {
                "description": "Deposits queries all deposits of a single proposal.",
                "operationId": "Deposits",
                "summary": "Deposits queries all deposits of a single proposal.",
                "tags": [
                    "Query"
                ],
                "parameters": [
                    {
                        "name": "proposal_id",
                        "in": "path",
                        "description": "Format - uint64. Format - uint64. Format - uint64. proposal_id defines the unique id of the proposal.",
                        "required": true,
                        "type": "string",
                        "format": "uint64"
                    },
                    {
                        "name": "pagination.key",
                        "in": "query",
                        "description": "Format - byte. Format - byte. Format - byte. key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
                        "type": "string",
                        "format": "byte"
                    },
                    {
                        "name": "pagination.offset",
                        "in": "query",
                        "description": "Format - uint64. Format - uint64. Format - uint64. offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
                        "type": "string",
                        "format": "uint64"
                    },
                    {
                        "name": "pagination.limit",
                        "in": "query",
                        "description": "Format - uint64. Format - uint64. Format - uint64. limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
                        "type": "string",
                        "format": "uint64"
                    },
                    {
                        "name": "pagination.count_total",
                        "in": "query",
                        "description": "Format - boolean. Format - boolean. Format - boolean. count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
                        "type": "boolean",
                        "format": "boolean"
                    },
                    {
                        "name": "pagination.reverse",
                        "in": "query",
                        "description": "Format - boolean. Format - boolean. Format - boolean. reverse is set to true if results are to be returned in the descending order.",
                        "type": "boolean",
                        "format": "boolean"
                    }
                ],
                "produces": [
                    "*/*"
                ],
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "description": "QueryDepositsResponse is the response type for the Query/Deposits RPC method.",
                            "type": "object",
                            "properties": {
                                "deposits": {
                                    "type": "array",
                                    "items": {
                                        "description": "Deposit defines an amount deposited by an account address to an active\nproposal.",
                                        "type": "object",
                                        "properties": {
                                            "proposal_id": {
                                                "format": "uint64",
                                                "type": "string"
                                            },
                                            "depositor": {
                                                "type": "string"
                                            },
                                            "amount": {
                                                "type": "array",
                                                "items": {
                                                    "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto.",
                                                    "type": "object",
                                                    "properties": {
                                                        "denom": {
                                                            "type": "string"
                                                        },
                                                        "amount": {
                                                            "type": "string"
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                },
                                "pagination": {
                                    "description": "pagination defines the pagination in the response.",
                                    "type": "object",
                                    "properties": {
                                        "next_key": {
                                            "format": "byte",
                                            "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently",
                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                            "type": "string"
                                        },
                                        "total": {
                                            "format": "uint64",
                                            "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                                            "type": "string"
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "400": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "500": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        },
        "/cosmos/gov/v1beta1/proposals/{proposal_id}/deposits/{depositor}": {
            "get": {
                "description": "Deposit queries single deposit information based proposalID, depositAddr.",
                "operationId": "Deposit",
                "summary": "Deposit queries single deposit information based proposalID, depositAddr.",
                "tags": [
                    "Query"
                ],
                "parameters": [
                    {
                        "name": "proposal_id",
                        "in": "path",
                        "description": "Format - uint64. Format - uint64. Format - uint64. proposal_id defines the unique id of the proposal.",
                        "required": true,
                        "type": "string",
                        "format": "uint64"
                    },
                    {
                        "name": "depositor",
                        "in": "path",
                        "description": "depositor defines the deposit addresses from the proposals.",
                        "required": true,
                        "type": "string"
                    }
                ],
                "produces": [
                    "*/*"
                ],
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "description": "QueryDepositResponse is the response type for the Query/Deposit RPC method.",
                            "type": "object",
                            "properties": {
                                "deposit": {
                                    "description": "Deposit defines an amount deposited by an account address to an active\nproposal.",
                                    "type": "object",
                                    "properties": {
                                        "proposal_id": {
                                            "format": "uint64",
                                            "type": "string"
                                        },
                                        "depositor": {
                                            "type": "string"
                                        },
                                        "amount": {
                                            "type": "array",
                                            "items": {
                                                "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto.",
                                                "type": "object",
                                                "properties": {
                                                    "denom": {
                                                        "type": "string"
                                                    },
                                                    "amount": {
                                                        "type": "string"
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "400": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "500": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        },
        "/cosmos/gov/v1beta1/proposals/{proposal_id}/tally": {
            "get": {
                "description": "TallyResult queries the tally of a proposal vote.",
                "operationId": "TallyResult",
                "summary": "TallyResult queries the tally of a proposal vote.",
                "tags": [
                    "Query"
                ],
                "parameters": [
                    {
                        "name": "proposal_id",
                        "in": "path",
                        "description": "Format - uint64. Format - uint64. Format - uint64. proposal_id defines the unique id of the proposal.",
                        "required": true,
                        "type": "string",
                        "format": "uint64"
                    }
                ],
                "produces": [
                    "*/*"
                ],
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "description": "QueryTallyResultResponse is the response type for the Query/Tally RPC method.",
                            "type": "object",
                            "properties": {
                                "tally": {
                                    "description": "TallyResult defines a standard tally for a governance proposal.",
                                    "type": "object",
                                    "properties": {
                                        "yes": {
                                            "type": "string"
                                        },
                                        "abstain": {
                                            "type": "string"
                                        },
                                        "no": {
                                            "type": "string"
                                        },
                                        "no_with_veto": {
                                            "type": "string"
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "400": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "500": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        },
        "/cosmos/gov/v1beta1/proposals/{proposal_id}/votes": {
            "get": {
                "description": "Votes queries votes of a given proposal.",
                "operationId": "Votes",
                "summary": "Votes queries votes of a given proposal.",
                "tags": [
                    "Query"
                ],
                "parameters": [
                    {
                        "name": "proposal_id",
                        "in": "path",
                        "description": "Format - uint64. Format - uint64. Format - uint64. proposal_id defines the unique id of the proposal.",
                        "required": true,
                        "type": "string",
                        "format": "uint64"
                    },
                    {
                        "name": "pagination.key",
                        "in": "query",
                        "description": "Format - byte. Format - byte. Format - byte. key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
                        "type": "string",
                        "format": "byte"
                    },
                    {
                        "name": "pagination.offset",
                        "in": "query",
                        "description": "Format - uint64. Format - uint64. Format - uint64. offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
                        "type": "string",
                        "format": "uint64"
                    },
                    {
                        "name": "pagination.limit",
                        "in": "query",
                        "description": "Format - uint64. Format - uint64. Format - uint64. limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
                        "type": "string",
                        "format": "uint64"
                    },
                    {
                        "name": "pagination.count_total",
                        "in": "query",
                        "description": "Format - boolean. Format - boolean. Format - boolean. count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
                        "type": "boolean",
                        "format": "boolean"
                    },
                    {
                        "name": "pagination.reverse",
                        "in": "query",
                        "description": "Format - boolean. Format - boolean. Format - boolean. reverse is set to true if results are to be returned in the descending order.",
                        "type": "boolean",
                        "format": "boolean"
                    }
                ],
                "produces": [
                    "*/*"
                ],
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "description": "QueryVotesResponse is the response type for the Query/Votes RPC method.",
                            "type": "object",
                            "properties": {
                                "votes": {
                                    "description": "votes defined the queried votes.",
                                    "type": "array",
                                    "items": {
                                        "description": "Vote defines a vote on a governance proposal.\nA Vote consists of a proposal ID, the voter, and the vote option.",
                                        "type": "object",
                                        "properties": {
                                            "proposal_id": {
                                                "format": "uint64",
                                                "type": "string"
                                            },
                                            "voter": {
                                                "type": "string"
                                            },
                                            "option": {
                                                "description": "Deprecated: Prefer to use `options` instead. This field is set in queries\nif and only if `len(options) == 1` and that option has weight 1. In all\nother cases, this field will default to VOTE_OPTION_UNSPECIFIED.",
                                                "default": "VOTE_OPTION_UNSPECIFIED",
                                                "enum": [
                                                    "VOTE_OPTION_UNSPECIFIED",
                                                    "VOTE_OPTION_YES",
                                                    "VOTE_OPTION_ABSTAIN",
                                                    "VOTE_OPTION_NO",
                                                    "VOTE_OPTION_NO_WITH_VETO"
                                                ],
                                                "type": "string"
                                            },
                                            "options": {
                                                "type": "array",
                                                "items": {
                                                    "description": "WeightedVoteOption defines a unit of vote for vote split.",
                                                    "type": "object",
                                                    "properties": {
                                                        "option": {
                                                            "description": "VoteOption enumerates the valid vote options for a given governance proposal.\n\n - VOTE_OPTION_UNSPECIFIED: VOTE_OPTION_UNSPECIFIED defines a no-op vote option.\n - VOTE_OPTION_YES: VOTE_OPTION_YES defines a yes vote option.\n - VOTE_OPTION_ABSTAIN: VOTE_OPTION_ABSTAIN defines an abstain vote option.\n - VOTE_OPTION_NO: VOTE_OPTION_NO defines a no vote option.\n - VOTE_OPTION_NO_WITH_VETO: VOTE_OPTION_NO_WITH_VETO defines a no with veto vote option.",
                                                            "default": "VOTE_OPTION_UNSPECIFIED",
                                                            "enum": [
                                                                "VOTE_OPTION_UNSPECIFIED",
                                                                "VOTE_OPTION_YES",
                                                                "VOTE_OPTION_ABSTAIN",
                                                                "VOTE_OPTION_NO",
                                                                "VOTE_OPTION_NO_WITH_VETO"
                                                            ],
                                                            "type": "string"
                                                        },
                                                        "weight": {
                                                            "type": "string"
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                },
                                "pagination": {
                                    "description": "pagination defines the pagination in the response.",
                                    "type": "object",
                                    "properties": {
                                        "next_key": {
                                            "format": "byte",
                                            "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently",
                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                            "type": "string"
                                        },
                                        "total": {
                                            "format": "uint64",
                                            "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                                            "type": "string"
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "400": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "500": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        },
        "/cosmos/gov/v1beta1/proposals/{proposal_id}/votes/{voter}": {
            "get": {
                "description": "Vote queries voted information based on proposalID, voterAddr.",
                "operationId": "Vote",
                "summary": "Vote queries voted information based on proposalID, voterAddr.",
                "tags": [
                    "Query"
                ],
                "parameters": [
                    {
                        "name": "proposal_id",
                        "in": "path",
                        "description": "Format - uint64. Format - uint64. Format - uint64. proposal_id defines the unique id of the proposal.",
                        "required": true,
                        "type": "string",
                        "format": "uint64"
                    },
                    {
                        "name": "voter",
                        "in": "path",
                        "description": "voter defines the oter address for the proposals.",
                        "required": true,
                        "type": "string"
                    }
                ],
                "produces": [
                    "*/*"
                ],
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "description": "QueryVoteResponse is the response type for the Query/Vote RPC method.",
                            "type": "object",
                            "properties": {
                                "vote": {
                                    "description": "Vote defines a vote on a governance proposal.\nA Vote consists of a proposal ID, the voter, and the vote option.",
                                    "type": "object",
                                    "properties": {
                                        "proposal_id": {
                                            "format": "uint64",
                                            "type": "string"
                                        },
                                        "voter": {
                                            "type": "string"
                                        },
                                        "option": {
                                            "description": "Deprecated: Prefer to use `options` instead. This field is set in queries\nif and only if `len(options) == 1` and that option has weight 1. In all\nother cases, this field will default to VOTE_OPTION_UNSPECIFIED.",
                                            "default": "VOTE_OPTION_UNSPECIFIED",
                                            "enum": [
                                                "VOTE_OPTION_UNSPECIFIED",
                                                "VOTE_OPTION_YES",
                                                "VOTE_OPTION_ABSTAIN",
                                                "VOTE_OPTION_NO",
                                                "VOTE_OPTION_NO_WITH_VETO"
                                            ],
                                            "type": "string"
                                        },
                                        "options": {
                                            "type": "array",
                                            "items": {
                                                "description": "WeightedVoteOption defines a unit of vote for vote split.",
                                                "type": "object",
                                                "properties": {
                                                    "option": {
                                                        "description": "VoteOption enumerates the valid vote options for a given governance proposal.\n\n - VOTE_OPTION_UNSPECIFIED: VOTE_OPTION_UNSPECIFIED defines a no-op vote option.\n - VOTE_OPTION_YES: VOTE_OPTION_YES defines a yes vote option.\n - VOTE_OPTION_ABSTAIN: VOTE_OPTION_ABSTAIN defines an abstain vote option.\n - VOTE_OPTION_NO: VOTE_OPTION_NO defines a no vote option.\n - VOTE_OPTION_NO_WITH_VETO: VOTE_OPTION_NO_WITH_VETO defines a no with veto vote option.",
                                                        "default": "VOTE_OPTION_UNSPECIFIED",
                                                        "enum": [
                                                            "VOTE_OPTION_UNSPECIFIED",
                                                            "VOTE_OPTION_YES",
                                                            "VOTE_OPTION_ABSTAIN",
                                                            "VOTE_OPTION_NO",
                                                            "VOTE_OPTION_NO_WITH_VETO"
                                                        ],
                                                        "type": "string"
                                                    },
                                                    "weight": {
                                                        "type": "string"
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "400": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "500": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        },
        "/cosmos/mint/v1beta1/annual_provisions": {
            "get": {
                "description": "AnnualProvisions current minting annual provisions value.",
                "operationId": "AnnualProvisions",
                "summary": "AnnualProvisions current minting annual provisions value.",
                "tags": [
                    "Query"
                ],
                "produces": [
                    "*/*"
                ],
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "description": "QueryAnnualProvisionsResponse is the response type for the\nQuery/AnnualProvisions RPC method.",
                            "type": "object",
                            "properties": {
                                "annual_provisions": {
                                    "format": "byte",
                                    "description": "annual_provisions is the current minting annual provisions value.",
                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                    "type": "string"
                                }
                            }
                        }
                    },
                    "400": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "500": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        },
        "/cosmos/mint/v1beta1/inflation": {
            "get": {
                "description": "Inflation returns the current minting inflation value.",
                "operationId": "Inflation",
                "summary": "Inflation returns the current minting inflation value.",
                "tags": [
                    "Query"
                ],
                "produces": [
                    "*/*"
                ],
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "description": "QueryInflationResponse is the response type for the Query/Inflation RPC\nmethod.",
                            "type": "object",
                            "properties": {
                                "inflation": {
                                    "format": "byte",
                                    "description": "inflation is the current minting inflation value.",
                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                    "type": "string"
                                }
                            }
                        }
                    },
                    "400": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "500": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        },
        "/cosmos/mint/v1beta1/params": {
            "get": {
                "description": "Params returns the total set of minting parameters.",
                "operationId": "MintParams",
                "summary": "Params returns the total set of minting parameters.",
                "tags": [
                    "Query"
                ],
                "produces": [
                    "*/*"
                ],
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "description": "QueryParamsResponse is the response type for the Query/Params RPC method.",
                            "type": "object",
                            "properties": {
                                "params": {
                                    "description": "params defines the parameters of the module.",
                                    "type": "object",
                                    "properties": {
                                        "mint_denom": {
                                            "title": "type of coin to mint",
                                            "type": "string"
                                        },
                                        "inflation_rate_change": {
                                            "title": "maximum annual change in inflation rate",
                                            "type": "string"
                                        },
                                        "inflation_max": {
                                            "title": "maximum inflation rate",
                                            "type": "string"
                                        },
                                        "inflation_min": {
                                            "title": "minimum inflation rate",
                                            "type": "string"
                                        },
                                        "goal_bonded": {
                                            "title": "goal of percent bonded atoms",
                                            "type": "string"
                                        },
                                        "blocks_per_year": {
                                            "format": "uint64",
                                            "title": "expected blocks per year",
                                            "type": "string"
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "400": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "500": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        },
        "/cosmos/params/v1beta1/params": {
            "get": {
                "description": "Params queries a specific parameter of a module, given its subspace and\nkey.",
                "operationId": "Params",
                "summary": "Params queries a specific parameter of a module, given its subspace and\nkey.",
                "tags": [
                    "Query"
                ],
                "parameters": [
                    {
                        "name": "subspace",
                        "in": "query",
                        "description": "subspace defines the module to query the parameter for.",
                        "type": "string"
                    },
                    {
                        "name": "key",
                        "in": "query",
                        "description": "key defines the key of the parameter in the subspace.",
                        "type": "string"
                    }
                ],
                "produces": [
                    "*/*"
                ],
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "description": "QueryParamsResponse is response type for the Query/Params RPC method.",
                            "type": "object",
                            "properties": {
                                "param": {
                                    "description": "param defines the queried parameter.",
                                    "type": "object",
                                    "properties": {
                                        "subspace": {
                                            "type": "string"
                                        },
                                        "key": {
                                            "type": "string"
                                        },
                                        "value": {
                                            "type": "string"
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "400": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "500": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        },
        "/cosmos/slashing/v1beta1/params": {
            "get": {
                "description": "Params queries the parameters of slashing module",
                "operationId": "SlashingParams",
                "summary": "Params queries the parameters of slashing module",
                "tags": [
                    "Query"
                ],
                "produces": [
                    "*/*"
                ],
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "title": "QueryParamsResponse is the response type for the Query/Params RPC method",
                            "type": "object",
                            "properties": {
                                "params": {
                                    "description": "Params represents the parameters used for by the slashing module.",
                                    "type": "object",
                                    "properties": {
                                        "signed_blocks_window": {
                                            "format": "int64",
                                            "type": "string"
                                        },
                                        "min_signed_per_window": {
                                            "format": "byte",
                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                            "type": "string"
                                        },
                                        "downtime_jail_duration": {
                                            "type": "string"
                                        },
                                        "slash_fraction_double_sign": {
                                            "format": "byte",
                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                            "type": "string"
                                        },
                                        "slash_fraction_downtime": {
                                            "format": "byte",
                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                            "type": "string"
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "400": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "500": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        },
        "/cosmos/slashing/v1beta1/signing_infos": {
            "get": {
                "description": "SigningInfos queries signing info of all validators",
                "operationId": "SigningInfos",
                "summary": "SigningInfos queries signing info of all validators",
                "tags": [
                    "Query"
                ],
                "parameters": [
                    {
                        "name": "pagination.key",
                        "in": "query",
                        "description": "Format - byte. Format - byte. Format - byte. key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
                        "type": "string",
                        "format": "byte"
                    },
                    {
                        "name": "pagination.offset",
                        "in": "query",
                        "description": "Format - uint64. Format - uint64. Format - uint64. offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
                        "type": "string",
                        "format": "uint64"
                    },
                    {
                        "name": "pagination.limit",
                        "in": "query",
                        "description": "Format - uint64. Format - uint64. Format - uint64. limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
                        "type": "string",
                        "format": "uint64"
                    },
                    {
                        "name": "pagination.count_total",
                        "in": "query",
                        "description": "Format - boolean. Format - boolean. Format - boolean. count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
                        "type": "boolean",
                        "format": "boolean"
                    },
                    {
                        "name": "pagination.reverse",
                        "in": "query",
                        "description": "Format - boolean. Format - boolean. Format - boolean. reverse is set to true if results are to be returned in the descending order.",
                        "type": "boolean",
                        "format": "boolean"
                    }
                ],
                "produces": [
                    "*/*"
                ],
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "title": "QuerySigningInfosResponse is the response type for the Query/SigningInfos RPC\nmethod",
                            "type": "object",
                            "properties": {
                                "info": {
                                    "title": "info is the signing info of all validators",
                                    "type": "array",
                                    "items": {
                                        "description": "ValidatorSigningInfo defines a validator's signing info for monitoring their\nliveness activity.",
                                        "type": "object",
                                        "properties": {
                                            "address": {
                                                "type": "string"
                                            },
                                            "start_height": {
                                                "format": "int64",
                                                "title": "Height at which validator was first a candidate OR was unjailed",
                                                "type": "string"
                                            },
                                            "index_offset": {
                                                "format": "int64",
                                                "description": "Index which is incremented each time the validator was a bonded\nin a block and may have signed a precommit or not. This in conjunction with the\n`SignedBlocksWindow` param determines the index in the `MissedBlocksBitArray`.",
                                                "type": "string"
                                            },
                                            "jailed_until": {
                                                "format": "date-time",
                                                "description": "Timestamp until which the validator is jailed due to liveness downtime.",
                                                "type": "string"
                                            },
                                            "tombstoned": {
                                                "format": "boolean",
                                                "description": "Whether or not a validator has been tombstoned (killed out of validator set). It is set\nonce the validator commits an equivocation or for any other configured misbehiavor.",
                                                "type": "boolean"
                                            },
                                            "missed_blocks_counter": {
                                                "format": "int64",
                                                "description": "A counter kept to avoid unnecessary array reads.\nNote that `Sum(MissedBlocksBitArray)` always equals `MissedBlocksCounter`.",
                                                "type": "string"
                                            }
                                        }
                                    }
                                },
                                "pagination": {
                                    "description": "PageResponse is to be embedded in gRPC response messages where the\ncorresponding request message has used PageRequest.\n\n message SomeResponse {\n         repeated Bar results = 1;\n         PageResponse page = 2;\n }",
                                    "type": "object",
                                    "properties": {
                                        "next_key": {
                                            "format": "byte",
                                            "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently",
                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                            "type": "string"
                                        },
                                        "total": {
                                            "format": "uint64",
                                            "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                                            "type": "string"
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "400": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "500": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        },
        "/cosmos/slashing/v1beta1/signing_infos/{cons_address}": {
            "get": {
                "description": "SigningInfo queries the signing info of given cons address",
                "operationId": "SigningInfo",
                "summary": "SigningInfo queries the signing info of given cons address",
                "tags": [
                    "Query"
                ],
                "parameters": [
                    {
                        "name": "cons_address",
                        "in": "path",
                        "description": "cons_address is the address to query signing info of",
                        "required": true,
                        "type": "string"
                    }
                ],
                "produces": [
                    "*/*"
                ],
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "title": "QuerySigningInfoResponse is the response type for the Query/SigningInfo RPC\nmethod",
                            "type": "object",
                            "properties": {
                                "val_signing_info": {
                                    "title": "val_signing_info is the signing info of requested val cons address",
                                    "description": "ValidatorSigningInfo defines a validator's signing info for monitoring their\nliveness activity.",
                                    "type": "object",
                                    "properties": {
                                        "address": {
                                            "type": "string"
                                        },
                                        "start_height": {
                                            "format": "int64",
                                            "title": "Height at which validator was first a candidate OR was unjailed",
                                            "type": "string"
                                        },
                                        "index_offset": {
                                            "format": "int64",
                                            "description": "Index which is incremented each time the validator was a bonded\nin a block and may have signed a precommit or not. This in conjunction with the\n`SignedBlocksWindow` param determines the index in the `MissedBlocksBitArray`.",
                                            "type": "string"
                                        },
                                        "jailed_until": {
                                            "format": "date-time",
                                            "description": "Timestamp until which the validator is jailed due to liveness downtime.",
                                            "type": "string"
                                        },
                                        "tombstoned": {
                                            "format": "boolean",
                                            "description": "Whether or not a validator has been tombstoned (killed out of validator set). It is set\nonce the validator commits an equivocation or for any other configured misbehiavor.",
                                            "type": "boolean"
                                        },
                                        "missed_blocks_counter": {
                                            "format": "int64",
                                            "description": "A counter kept to avoid unnecessary array reads.\nNote that `Sum(MissedBlocksBitArray)` always equals `MissedBlocksCounter`.",
                                            "type": "string"
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "400": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "500": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        },
        "/cosmos/staking/v1beta1/delegations/{delegator_addr}": {
            "get": {
                "description": "DelegatorDelegations queries all delegations of a given delegator address.",
                "operationId": "DelegatorDelegations",
                "summary": "DelegatorDelegations queries all delegations of a given delegator address.",
                "tags": [
                    "Query"
                ],
                "parameters": [
                    {
                        "name": "delegator_addr",
                        "in": "path",
                        "description": "delegator_addr defines the delegator address to query for.",
                        "required": true,
                        "type": "string"
                    },
                    {
                        "name": "pagination.key",
                        "in": "query",
                        "description": "Format - byte. Format - byte. Format - byte. key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
                        "type": "string",
                        "format": "byte"
                    },
                    {
                        "name": "pagination.offset",
                        "in": "query",
                        "description": "Format - uint64. Format - uint64. Format - uint64. offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
                        "type": "string",
                        "format": "uint64"
                    },
                    {
                        "name": "pagination.limit",
                        "in": "query",
                        "description": "Format - uint64. Format - uint64. Format - uint64. limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
                        "type": "string",
                        "format": "uint64"
                    },
                    {
                        "name": "pagination.count_total",
                        "in": "query",
                        "description": "Format - boolean. Format - boolean. Format - boolean. count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
                        "type": "boolean",
                        "format": "boolean"
                    },
                    {
                        "name": "pagination.reverse",
                        "in": "query",
                        "description": "Format - boolean. Format - boolean. Format - boolean. reverse is set to true if results are to be returned in the descending order.",
                        "type": "boolean",
                        "format": "boolean"
                    }
                ],
                "produces": [
                    "*/*"
                ],
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "description": "QueryDelegatorDelegationsResponse is response type for the\nQuery/DelegatorDelegations RPC method.",
                            "type": "object",
                            "properties": {
                                "delegation_responses": {
                                    "description": "delegation_responses defines all the delegations' info of a delegator.",
                                    "type": "array",
                                    "items": {
                                        "description": "DelegationResponse is equivalent to Delegation except that it contains a\nbalance in addition to shares which is more suitable for client responses.",
                                        "type": "object",
                                        "properties": {
                                            "delegation": {
                                                "description": "Delegation represents the bond with tokens held by an account. It is\nowned by one delegator, and is associated with the voting power of one\nvalidator.",
                                                "type": "object",
                                                "properties": {
                                                    "delegator_address": {
                                                        "description": "delegator_address is the bech32-encoded address of the delegator.",
                                                        "type": "string"
                                                    },
                                                    "validator_address": {
                                                        "description": "validator_address is the bech32-encoded address of the validator.",
                                                        "type": "string"
                                                    },
                                                    "shares": {
                                                        "description": "shares define the delegation shares received.",
                                                        "type": "string"
                                                    }
                                                }
                                            },
                                            "balance": {
                                                "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto.",
                                                "type": "object",
                                                "properties": {
                                                    "denom": {
                                                        "type": "string"
                                                    },
                                                    "amount": {
                                                        "type": "string"
                                                    }
                                                }
                                            }
                                        }
                                    }
                                },
                                "pagination": {
                                    "description": "pagination defines the pagination in the response.",
                                    "type": "object",
                                    "properties": {
                                        "next_key": {
                                            "format": "byte",
                                            "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently",
                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                            "type": "string"
                                        },
                                        "total": {
                                            "format": "uint64",
                                            "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                                            "type": "string"
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "400": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "500": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        },
        "/cosmos/staking/v1beta1/delegators/{delegator_addr}/redelegations": {
            "get": {
                "description": "Redelegations queries redelegations of given address.",
                "operationId": "Redelegations",
                "summary": "Redelegations queries redelegations of given address.",
                "tags": [
                    "Query"
                ],
                "parameters": [
                    {
                        "name": "delegator_addr",
                        "in": "path",
                        "description": "delegator_addr defines the delegator address to query for.",
                        "required": true,
                        "type": "string"
                    },
                    {
                        "name": "src_validator_addr",
                        "in": "query",
                        "description": "src_validator_addr defines the validator address to redelegate from.",
                        "type": "string"
                    },
                    {
                        "name": "dst_validator_addr",
                        "in": "query",
                        "description": "dst_validator_addr defines the validator address to redelegate to.",
                        "type": "string"
                    },
                    {
                        "name": "pagination.key",
                        "in": "query",
                        "description": "Format - byte. Format - byte. Format - byte. key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
                        "type": "string",
                        "format": "byte"
                    },
                    {
                        "name": "pagination.offset",
                        "in": "query",
                        "description": "Format - uint64. Format - uint64. Format - uint64. offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
                        "type": "string",
                        "format": "uint64"
                    },
                    {
                        "name": "pagination.limit",
                        "in": "query",
                        "description": "Format - uint64. Format - uint64. Format - uint64. limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
                        "type": "string",
                        "format": "uint64"
                    },
                    {
                        "name": "pagination.count_total",
                        "in": "query",
                        "description": "Format - boolean. Format - boolean. Format - boolean. count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
                        "type": "boolean",
                        "format": "boolean"
                    },
                    {
                        "name": "pagination.reverse",
                        "in": "query",
                        "description": "Format - boolean. Format - boolean. Format - boolean. reverse is set to true if results are to be returned in the descending order.",
                        "type": "boolean",
                        "format": "boolean"
                    }
                ],
                "produces": [
                    "*/*"
                ],
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "description": "QueryRedelegationsResponse is response type for the Query/Redelegations RPC\nmethod.",
                            "type": "object",
                            "properties": {
                                "redelegation_responses": {
                                    "type": "array",
                                    "items": {
                                        "description": "RedelegationResponse is equivalent to a Redelegation except that its entries\ncontain a balance in addition to shares which is more suitable for client\nresponses.",
                                        "type": "object",
                                        "properties": {
                                            "redelegation": {
                                                "description": "Redelegation contains the list of a particular delegator's redelegating bonds\nfrom a particular source validator to a particular destination validator.",
                                                "type": "object",
                                                "properties": {
                                                    "delegator_address": {
                                                        "description": "delegator_address is the bech32-encoded address of the delegator.",
                                                        "type": "string"
                                                    },
                                                    "validator_src_address": {
                                                        "description": "validator_src_address is the validator redelegation source operator address.",
                                                        "type": "string"
                                                    },
                                                    "validator_dst_address": {
                                                        "description": "validator_dst_address is the validator redelegation destination operator address.",
                                                        "type": "string"
                                                    },
                                                    "entries": {
                                                        "description": "entries are the redelegation entries.",
                                                        "type": "array",
                                                        "items": {
                                                            "description": "RedelegationEntry defines a redelegation object with relevant metadata.",
                                                            "type": "object",
                                                            "properties": {
                                                                "creation_height": {
                                                                    "format": "int64",
                                                                    "description": "creation_height  defines the height which the redelegation took place.",
                                                                    "type": "string"
                                                                },
                                                                "completion_time": {
                                                                    "format": "date-time",
                                                                    "description": "completion_time defines the unix time for redelegation completion.",
                                                                    "type": "string"
                                                                },
                                                                "initial_balance": {
                                                                    "description": "initial_balance defines the initial balance when redelegation started.",
                                                                    "type": "string"
                                                                },
                                                                "shares_dst": {
                                                                    "description": "shares_dst is the amount of destination-validator shares created by redelegation.",
                                                                    "type": "string"
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            },
                                            "entries": {
                                                "type": "array",
                                                "items": {
                                                    "description": "RedelegationEntryResponse is equivalent to a RedelegationEntry except that it\ncontains a balance in addition to shares which is more suitable for client\nresponses.",
                                                    "type": "object",
                                                    "properties": {
                                                        "redelegation_entry": {
                                                            "description": "RedelegationEntry defines a redelegation object with relevant metadata.",
                                                            "type": "object",
                                                            "properties": {
                                                                "creation_height": {
                                                                    "format": "int64",
                                                                    "description": "creation_height  defines the height which the redelegation took place.",
                                                                    "type": "string"
                                                                },
                                                                "completion_time": {
                                                                    "format": "date-time",
                                                                    "description": "completion_time defines the unix time for redelegation completion.",
                                                                    "type": "string"
                                                                },
                                                                "initial_balance": {
                                                                    "description": "initial_balance defines the initial balance when redelegation started.",
                                                                    "type": "string"
                                                                },
                                                                "shares_dst": {
                                                                    "description": "shares_dst is the amount of destination-validator shares created by redelegation.",
                                                                    "type": "string"
                                                                }
                                                            }
                                                        },
                                                        "balance": {
                                                            "type": "string"
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                },
                                "pagination": {
                                    "description": "pagination defines the pagination in the response.",
                                    "type": "object",
                                    "properties": {
                                        "next_key": {
                                            "format": "byte",
                                            "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently",
                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                            "type": "string"
                                        },
                                        "total": {
                                            "format": "uint64",
                                            "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                                            "type": "string"
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "400": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "500": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        },
        "/cosmos/staking/v1beta1/delegators/{delegator_addr}/unbonding_delegations": {
            "get": {
                "description": "DelegatorUnbondingDelegations queries all unbonding delegations of a given\ndelegator address.",
                "operationId": "DelegatorUnbondingDelegations",
                "summary": "DelegatorUnbondingDelegations queries all unbonding delegations of a given\ndelegator address.",
                "tags": [
                    "Query"
                ],
                "parameters": [
                    {
                        "name": "delegator_addr",
                        "in": "path",
                        "description": "delegator_addr defines the delegator address to query for.",
                        "required": true,
                        "type": "string"
                    },
                    {
                        "name": "pagination.key",
                        "in": "query",
                        "description": "Format - byte. Format - byte. Format - byte. key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
                        "type": "string",
                        "format": "byte"
                    },
                    {
                        "name": "pagination.offset",
                        "in": "query",
                        "description": "Format - uint64. Format - uint64. Format - uint64. offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
                        "type": "string",
                        "format": "uint64"
                    },
                    {
                        "name": "pagination.limit",
                        "in": "query",
                        "description": "Format - uint64. Format - uint64. Format - uint64. limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
                        "type": "string",
                        "format": "uint64"
                    },
                    {
                        "name": "pagination.count_total",
                        "in": "query",
                        "description": "Format - boolean. Format - boolean. Format - boolean. count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
                        "type": "boolean",
                        "format": "boolean"
                    },
                    {
                        "name": "pagination.reverse",
                        "in": "query",
                        "description": "Format - boolean. Format - boolean. Format - boolean. reverse is set to true if results are to be returned in the descending order.",
                        "type": "boolean",
                        "format": "boolean"
                    }
                ],
                "produces": [
                    "*/*"
                ],
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "description": "QueryUnbondingDelegatorDelegationsResponse is response type for the\nQuery/UnbondingDelegatorDelegations RPC method.",
                            "type": "object",
                            "properties": {
                                "unbonding_responses": {
                                    "type": "array",
                                    "items": {
                                        "description": "UnbondingDelegation stores all of a single delegator's unbonding bonds\nfor a single validator in an time-ordered list.",
                                        "type": "object",
                                        "properties": {
                                            "delegator_address": {
                                                "description": "delegator_address is the bech32-encoded address of the delegator.",
                                                "type": "string"
                                            },
                                            "validator_address": {
                                                "description": "validator_address is the bech32-encoded address of the validator.",
                                                "type": "string"
                                            },
                                            "entries": {
                                                "description": "entries are the unbonding delegation entries.",
                                                "type": "array",
                                                "items": {
                                                    "description": "UnbondingDelegationEntry defines an unbonding object with relevant metadata.",
                                                    "type": "object",
                                                    "properties": {
                                                        "creation_height": {
                                                            "format": "int64",
                                                            "description": "creation_height is the height which the unbonding took place.",
                                                            "type": "string"
                                                        },
                                                        "completion_time": {
                                                            "format": "date-time",
                                                            "description": "completion_time is the unix time for unbonding completion.",
                                                            "type": "string"
                                                        },
                                                        "initial_balance": {
                                                            "description": "initial_balance defines the tokens initially scheduled to receive at completion.",
                                                            "type": "string"
                                                        },
                                                        "balance": {
                                                            "description": "balance defines the tokens to receive at completion.",
                                                            "type": "string"
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                },
                                "pagination": {
                                    "description": "pagination defines the pagination in the response.",
                                    "type": "object",
                                    "properties": {
                                        "next_key": {
                                            "format": "byte",
                                            "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently",
                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                            "type": "string"
                                        },
                                        "total": {
                                            "format": "uint64",
                                            "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                                            "type": "string"
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "400": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "500": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        },
        "/cosmos/staking/v1beta1/delegators/{delegator_addr}/validators": {
            "get": {
                "description": "DelegatorValidators queries all validators info for given delegator\naddress.",
                "operationId": "StakingDelegatorValidators",
                "summary": "DelegatorValidators queries all validators info for given delegator\naddress.",
                "tags": [
                    "Query"
                ],
                "parameters": [
                    {
                        "name": "delegator_addr",
                        "in": "path",
                        "description": "delegator_addr defines the delegator address to query for.",
                        "required": true,
                        "type": "string"
                    },
                    {
                        "name": "pagination.key",
                        "in": "query",
                        "description": "Format - byte. Format - byte. Format - byte. key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
                        "type": "string",
                        "format": "byte"
                    },
                    {
                        "name": "pagination.offset",
                        "in": "query",
                        "description": "Format - uint64. Format - uint64. Format - uint64. offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
                        "type": "string",
                        "format": "uint64"
                    },
                    {
                        "name": "pagination.limit",
                        "in": "query",
                        "description": "Format - uint64. Format - uint64. Format - uint64. limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
                        "type": "string",
                        "format": "uint64"
                    },
                    {
                        "name": "pagination.count_total",
                        "in": "query",
                        "description": "Format - boolean. Format - boolean. Format - boolean. count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
                        "type": "boolean",
                        "format": "boolean"
                    },
                    {
                        "name": "pagination.reverse",
                        "in": "query",
                        "description": "Format - boolean. Format - boolean. Format - boolean. reverse is set to true if results are to be returned in the descending order.",
                        "type": "boolean",
                        "format": "boolean"
                    }
                ],
                "produces": [
                    "*/*"
                ],
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "description": "QueryDelegatorValidatorsResponse is response type for the\nQuery/DelegatorValidators RPC method.",
                            "type": "object",
                            "properties": {
                                "validators": {
                                    "description": "validators defines the the validators' info of a delegator.",
                                    "type": "array",
                                    "items": {
                                        "description": "Validator defines a validator, together with the total amount of the\nValidator's bond shares and their exchange rate to coins. Slashing results in\na decrease in the exchange rate, allowing correct calculation of future\nundelegations without iterating over delegators. When coins are delegated to\nthis validator, the validator is credited with a delegation whose number of\nbond shares is based on the amount of coins delegated divided by the current\nexchange rate. Voting power can be calculated as total bonded shares\nmultiplied by exchange rate.",
                                        "type": "object",
                                        "properties": {
                                            "operator_address": {
                                                "description": "operator_address defines the address of the validator's operator; bech encoded in JSON.",
                                                "type": "string"
                                            },
                                            "consensus_pubkey": {
                                                "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                                "type": "object",
                                                "properties": {
                                                    "type_url": {
                                                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                        "type": "string"
                                                    },
                                                    "value": {
                                                        "format": "byte",
                                                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                        "type": "string"
                                                    }
                                                }
                                            },
                                            "jailed": {
                                                "format": "boolean",
                                                "description": "jailed defined whether the validator has been jailed from bonded status or not.",
                                                "type": "boolean"
                                            },
                                            "status": {
                                                "description": "status is the validator status (bonded/unbonding/unbonded).",
                                                "default": "BOND_STATUS_UNSPECIFIED",
                                                "enum": [
                                                    "BOND_STATUS_UNSPECIFIED",
                                                    "BOND_STATUS_UNBONDED",
                                                    "BOND_STATUS_UNBONDING",
                                                    "BOND_STATUS_BONDED"
                                                ],
                                                "type": "string"
                                            },
                                            "tokens": {
                                                "description": "tokens define the delegated tokens (incl. self-delegation).",
                                                "type": "string"
                                            },
                                            "delegator_shares": {
                                                "description": "delegator_shares defines total shares issued to a validator's delegators.",
                                                "type": "string"
                                            },
                                            "description": {
                                                "description": "description defines the description terms for the validator.",
                                                "type": "object",
                                                "properties": {
                                                    "moniker": {
                                                        "description": "moniker defines a human-readable name for the validator.",
                                                        "type": "string"
                                                    },
                                                    "identity": {
                                                        "description": "identity defines an optional identity signature (ex. UPort or Keybase).",
                                                        "type": "string"
                                                    },
                                                    "website": {
                                                        "description": "website defines an optional website link.",
                                                        "type": "string"
                                                    },
                                                    "security_contact": {
                                                        "description": "security_contact defines an optional email for security contact.",
                                                        "type": "string"
                                                    },
                                                    "details": {
                                                        "description": "details define other optional details.",
                                                        "type": "string"
                                                    }
                                                }
                                            },
                                            "unbonding_height": {
                                                "format": "int64",
                                                "description": "unbonding_height defines, if unbonding, the height at which this validator has begun unbonding.",
                                                "type": "string"
                                            },
                                            "unbonding_time": {
                                                "format": "date-time",
                                                "description": "unbonding_time defines, if unbonding, the min time for the validator to complete unbonding.",
                                                "type": "string"
                                            },
                                            "commission": {
                                                "description": "commission defines the commission parameters.",
                                                "type": "object",
                                                "properties": {
                                                    "commission_rates": {
                                                        "description": "commission_rates defines the initial commission rates to be used for creating a validator.",
                                                        "type": "object",
                                                        "properties": {
                                                            "rate": {
                                                                "description": "rate is the commission rate charged to delegators, as a fraction.",
                                                                "type": "string"
                                                            },
                                                            "max_rate": {
                                                                "description": "max_rate defines the maximum commission rate which validator can ever charge, as a fraction.",
                                                                "type": "string"
                                                            },
                                                            "max_change_rate": {
                                                                "description": "max_change_rate defines the maximum daily increase of the validator commission, as a fraction.",
                                                                "type": "string"
                                                            }
                                                        }
                                                    },
                                                    "update_time": {
                                                        "format": "date-time",
                                                        "description": "update_time is the last time the commission rate was changed.",
                                                        "type": "string"
                                                    }
                                                }
                                            },
                                            "min_self_delegation": {
                                                "description": "min_self_delegation is the validator's self declared minimum self delegation.",
                                                "type": "string"
                                            }
                                        }
                                    }
                                },
                                "pagination": {
                                    "description": "pagination defines the pagination in the response.",
                                    "type": "object",
                                    "properties": {
                                        "next_key": {
                                            "format": "byte",
                                            "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently",
                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                            "type": "string"
                                        },
                                        "total": {
                                            "format": "uint64",
                                            "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                                            "type": "string"
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "400": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "500": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        },
        "/cosmos/staking/v1beta1/delegators/{delegator_addr}/validators/{validator_addr}": {
            "get": {
                "description": "DelegatorValidator queries validator info for given delegator validator\npair.",
                "operationId": "DelegatorValidator",
                "summary": "DelegatorValidator queries validator info for given delegator validator\npair.",
                "tags": [
                    "Query"
                ],
                "parameters": [
                    {
                        "name": "delegator_addr",
                        "in": "path",
                        "description": "delegator_addr defines the delegator address to query for.",
                        "required": true,
                        "type": "string"
                    },
                    {
                        "name": "validator_addr",
                        "in": "path",
                        "description": "validator_addr defines the validator address to query for.",
                        "required": true,
                        "type": "string"
                    }
                ],
                "produces": [
                    "*/*"
                ],
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "description": "QueryDelegatorValidatorResponse response type for the\nQuery/DelegatorValidator RPC method.",
                            "type": "object",
                            "properties": {
                                "validator": {
                                    "description": "Validator defines a validator, together with the total amount of the\nValidator's bond shares and their exchange rate to coins. Slashing results in\na decrease in the exchange rate, allowing correct calculation of future\nundelegations without iterating over delegators. When coins are delegated to\nthis validator, the validator is credited with a delegation whose number of\nbond shares is based on the amount of coins delegated divided by the current\nexchange rate. Voting power can be calculated as total bonded shares\nmultiplied by exchange rate.",
                                    "type": "object",
                                    "properties": {
                                        "operator_address": {
                                            "description": "operator_address defines the address of the validator's operator; bech encoded in JSON.",
                                            "type": "string"
                                        },
                                        "consensus_pubkey": {
                                            "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                            "type": "object",
                                            "properties": {
                                                "type_url": {
                                                    "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                    "type": "string"
                                                },
                                                "value": {
                                                    "format": "byte",
                                                    "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                    "type": "string"
                                                }
                                            }
                                        },
                                        "jailed": {
                                            "format": "boolean",
                                            "description": "jailed defined whether the validator has been jailed from bonded status or not.",
                                            "type": "boolean"
                                        },
                                        "status": {
                                            "description": "status is the validator status (bonded/unbonding/unbonded).",
                                            "default": "BOND_STATUS_UNSPECIFIED",
                                            "enum": [
                                                "BOND_STATUS_UNSPECIFIED",
                                                "BOND_STATUS_UNBONDED",
                                                "BOND_STATUS_UNBONDING",
                                                "BOND_STATUS_BONDED"
                                            ],
                                            "type": "string"
                                        },
                                        "tokens": {
                                            "description": "tokens define the delegated tokens (incl. self-delegation).",
                                            "type": "string"
                                        },
                                        "delegator_shares": {
                                            "description": "delegator_shares defines total shares issued to a validator's delegators.",
                                            "type": "string"
                                        },
                                        "description": {
                                            "description": "description defines the description terms for the validator.",
                                            "type": "object",
                                            "properties": {
                                                "moniker": {
                                                    "description": "moniker defines a human-readable name for the validator.",
                                                    "type": "string"
                                                },
                                                "identity": {
                                                    "description": "identity defines an optional identity signature (ex. UPort or Keybase).",
                                                    "type": "string"
                                                },
                                                "website": {
                                                    "description": "website defines an optional website link.",
                                                    "type": "string"
                                                },
                                                "security_contact": {
                                                    "description": "security_contact defines an optional email for security contact.",
                                                    "type": "string"
                                                },
                                                "details": {
                                                    "description": "details define other optional details.",
                                                    "type": "string"
                                                }
                                            }
                                        },
                                        "unbonding_height": {
                                            "format": "int64",
                                            "description": "unbonding_height defines, if unbonding, the height at which this validator has begun unbonding.",
                                            "type": "string"
                                        },
                                        "unbonding_time": {
                                            "format": "date-time",
                                            "description": "unbonding_time defines, if unbonding, the min time for the validator to complete unbonding.",
                                            "type": "string"
                                        },
                                        "commission": {
                                            "description": "commission defines the commission parameters.",
                                            "type": "object",
                                            "properties": {
                                                "commission_rates": {
                                                    "description": "commission_rates defines the initial commission rates to be used for creating a validator.",
                                                    "type": "object",
                                                    "properties": {
                                                        "rate": {
                                                            "description": "rate is the commission rate charged to delegators, as a fraction.",
                                                            "type": "string"
                                                        },
                                                        "max_rate": {
                                                            "description": "max_rate defines the maximum commission rate which validator can ever charge, as a fraction.",
                                                            "type": "string"
                                                        },
                                                        "max_change_rate": {
                                                            "description": "max_change_rate defines the maximum daily increase of the validator commission, as a fraction.",
                                                            "type": "string"
                                                        }
                                                    }
                                                },
                                                "update_time": {
                                                    "format": "date-time",
                                                    "description": "update_time is the last time the commission rate was changed.",
                                                    "type": "string"
                                                }
                                            }
                                        },
                                        "min_self_delegation": {
                                            "description": "min_self_delegation is the validator's self declared minimum self delegation.",
                                            "type": "string"
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "400": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "500": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        },
        "/cosmos/staking/v1beta1/historical_info/{height}": {
            "get": {
                "description": "HistoricalInfo queries the historical info for given height.",
                "operationId": "HistoricalInfo",
                "summary": "HistoricalInfo queries the historical info for given height.",
                "tags": [
                    "Query"
                ],
                "parameters": [
                    {
                        "name": "height",
                        "in": "path",
                        "description": "Format - int64. Format - int64. Format - int64. height defines at which height to query the historical info.",
                        "required": true,
                        "type": "string",
                        "format": "int64"
                    }
                ],
                "produces": [
                    "*/*"
                ],
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "description": "QueryHistoricalInfoResponse is response type for the Query/HistoricalInfo RPC\nmethod.",
                            "type": "object",
                            "properties": {
                                "hist": {
                                    "description": "hist defines the historical info at the given height.",
                                    "type": "object",
                                    "properties": {
                                        "header": {
                                            "description": "Header defines the structure of a Tendermint block header.",
                                            "type": "object",
                                            "properties": {
                                                "version": {
                                                    "title": "basic block info",
                                                    "description": "Consensus captures the consensus rules for processing a block in the blockchain,\nincluding all blockchain data structures and the rules of the application's\nstate transition machine.",
                                                    "type": "object",
                                                    "properties": {
                                                        "block": {
                                                            "format": "uint64",
                                                            "type": "string"
                                                        },
                                                        "app": {
                                                            "format": "uint64",
                                                            "type": "string"
                                                        }
                                                    }
                                                },
                                                "chain_id": {
                                                    "type": "string"
                                                },
                                                "height": {
                                                    "format": "int64",
                                                    "type": "string"
                                                },
                                                "time": {
                                                    "format": "date-time",
                                                    "type": "string"
                                                },
                                                "last_block_id": {
                                                    "title": "prev block info",
                                                    "type": "object",
                                                    "properties": {
                                                        "hash": {
                                                            "format": "byte",
                                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                            "type": "string"
                                                        },
                                                        "part_set_header": {
                                                            "title": "PartsetHeader",
                                                            "type": "object",
                                                            "properties": {
                                                                "total": {
                                                                    "format": "int64",
                                                                    "type": "integer"
                                                                },
                                                                "hash": {
                                                                    "format": "byte",
                                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                    "type": "string"
                                                                }
                                                            }
                                                        }
                                                    }
                                                },
                                                "last_commit_hash": {
                                                    "format": "byte",
                                                    "title": "hashes of block data",
                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                    "type": "string"
                                                },
                                                "data_hash": {
                                                    "format": "byte",
                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                    "type": "string"
                                                },
                                                "validators_hash": {
                                                    "format": "byte",
                                                    "title": "hashes from the app output from the prev block",
                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                    "type": "string"
                                                },
                                                "next_validators_hash": {
                                                    "format": "byte",
                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                    "type": "string"
                                                },
                                                "consensus_hash": {
                                                    "format": "byte",
                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                    "type": "string"
                                                },
                                                "app_hash": {
                                                    "format": "byte",
                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                    "type": "string"
                                                },
                                                "last_results_hash": {
                                                    "format": "byte",
                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                    "type": "string"
                                                },
                                                "evidence_hash": {
                                                    "format": "byte",
                                                    "title": "consensus info",
                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                    "type": "string"
                                                },
                                                "proposer_address": {
                                                    "format": "byte",
                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                    "type": "string"
                                                }
                                            }
                                        },
                                        "valset": {
                                            "type": "array",
                                            "items": {
                                                "description": "Validator defines a validator, together with the total amount of the\nValidator's bond shares and their exchange rate to coins. Slashing results in\na decrease in the exchange rate, allowing correct calculation of future\nundelegations without iterating over delegators. When coins are delegated to\nthis validator, the validator is credited with a delegation whose number of\nbond shares is based on the amount of coins delegated divided by the current\nexchange rate. Voting power can be calculated as total bonded shares\nmultiplied by exchange rate.",
                                                "type": "object",
                                                "properties": {
                                                    "operator_address": {
                                                        "description": "operator_address defines the address of the validator's operator; bech encoded in JSON.",
                                                        "type": "string"
                                                    },
                                                    "consensus_pubkey": {
                                                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                                        "type": "object",
                                                        "properties": {
                                                            "type_url": {
                                                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                                "type": "string"
                                                            },
                                                            "value": {
                                                                "format": "byte",
                                                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                "type": "string"
                                                            }
                                                        }
                                                    },
                                                    "jailed": {
                                                        "format": "boolean",
                                                        "description": "jailed defined whether the validator has been jailed from bonded status or not.",
                                                        "type": "boolean"
                                                    },
                                                    "status": {
                                                        "description": "status is the validator status (bonded/unbonding/unbonded).",
                                                        "default": "BOND_STATUS_UNSPECIFIED",
                                                        "enum": [
                                                            "BOND_STATUS_UNSPECIFIED",
                                                            "BOND_STATUS_UNBONDED",
                                                            "BOND_STATUS_UNBONDING",
                                                            "BOND_STATUS_BONDED"
                                                        ],
                                                        "type": "string"
                                                    },
                                                    "tokens": {
                                                        "description": "tokens define the delegated tokens (incl. self-delegation).",
                                                        "type": "string"
                                                    },
                                                    "delegator_shares": {
                                                        "description": "delegator_shares defines total shares issued to a validator's delegators.",
                                                        "type": "string"
                                                    },
                                                    "description": {
                                                        "description": "description defines the description terms for the validator.",
                                                        "type": "object",
                                                        "properties": {
                                                            "moniker": {
                                                                "description": "moniker defines a human-readable name for the validator.",
                                                                "type": "string"
                                                            },
                                                            "identity": {
                                                                "description": "identity defines an optional identity signature (ex. UPort or Keybase).",
                                                                "type": "string"
                                                            },
                                                            "website": {
                                                                "description": "website defines an optional website link.",
                                                                "type": "string"
                                                            },
                                                            "security_contact": {
                                                                "description": "security_contact defines an optional email for security contact.",
                                                                "type": "string"
                                                            },
                                                            "details": {
                                                                "description": "details define other optional details.",
                                                                "type": "string"
                                                            }
                                                        }
                                                    },
                                                    "unbonding_height": {
                                                        "format": "int64",
                                                        "description": "unbonding_height defines, if unbonding, the height at which this validator has begun unbonding.",
                                                        "type": "string"
                                                    },
                                                    "unbonding_time": {
                                                        "format": "date-time",
                                                        "description": "unbonding_time defines, if unbonding, the min time for the validator to complete unbonding.",
                                                        "type": "string"
                                                    },
                                                    "commission": {
                                                        "description": "commission defines the commission parameters.",
                                                        "type": "object",
                                                        "properties": {
                                                            "commission_rates": {
                                                                "description": "commission_rates defines the initial commission rates to be used for creating a validator.",
                                                                "type": "object",
                                                                "properties": {
                                                                    "rate": {
                                                                        "description": "rate is the commission rate charged to delegators, as a fraction.",
                                                                        "type": "string"
                                                                    },
                                                                    "max_rate": {
                                                                        "description": "max_rate defines the maximum commission rate which validator can ever charge, as a fraction.",
                                                                        "type": "string"
                                                                    },
                                                                    "max_change_rate": {
                                                                        "description": "max_change_rate defines the maximum daily increase of the validator commission, as a fraction.",
                                                                        "type": "string"
                                                                    }
                                                                }
                                                            },
                                                            "update_time": {
                                                                "format": "date-time",
                                                                "description": "update_time is the last time the commission rate was changed.",
                                                                "type": "string"
                                                            }
                                                        }
                                                    },
                                                    "min_self_delegation": {
                                                        "description": "min_self_delegation is the validator's self declared minimum self delegation.",
                                                        "type": "string"
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "400": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "500": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        },
        "/cosmos/staking/v1beta1/params": {
            "get": {
                "description": "Parameters queries the staking parameters.",
                "operationId": "StakingParams",
                "summary": "Parameters queries the staking parameters.",
                "tags": [
                    "Query"
                ],
                "produces": [
                    "*/*"
                ],
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "description": "QueryParamsResponse is response type for the Query/Params RPC method.",
                            "type": "object",
                            "properties": {
                                "params": {
                                    "description": "params holds all the parameters of this module.",
                                    "type": "object",
                                    "properties": {
                                        "unbonding_time": {
                                            "description": "unbonding_time is the time duration of unbonding.",
                                            "type": "string"
                                        },
                                        "max_validators": {
                                            "format": "int64",
                                            "description": "max_validators is the maximum number of validators.",
                                            "type": "integer"
                                        },
                                        "max_entries": {
                                            "format": "int64",
                                            "description": "max_entries is the max entries for either unbonding delegation or redelegation (per pair/trio).",
                                            "type": "integer"
                                        },
                                        "historical_entries": {
                                            "format": "int64",
                                            "description": "historical_entries is the number of historical entries to persist.",
                                            "type": "integer"
                                        },
                                        "bond_denom": {
                                            "description": "bond_denom defines the bondable coin denomination.",
                                            "type": "string"
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "400": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "500": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        },
        "/cosmos/staking/v1beta1/pool": {
            "get": {
                "description": "Pool queries the pool info.",
                "operationId": "Pool",
                "summary": "Pool queries the pool info.",
                "tags": [
                    "Query"
                ],
                "produces": [
                    "*/*"
                ],
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "description": "QueryPoolResponse is response type for the Query/Pool RPC method.",
                            "type": "object",
                            "properties": {
                                "pool": {
                                    "description": "pool defines the pool info.",
                                    "type": "object",
                                    "properties": {
                                        "not_bonded_tokens": {
                                            "type": "string"
                                        },
                                        "bonded_tokens": {
                                            "type": "string"
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "400": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "500": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        },
        "/cosmos/staking/v1beta1/validators": {
            "get": {
                "description": "Validators queries all validators that match the given status.",
                "operationId": "Validators",
                "summary": "Validators queries all validators that match the given status.",
                "tags": [
                    "Query"
                ],
                "parameters": [
                    {
                        "name": "status",
                        "in": "query",
                        "description": "status enables to query for validators matching a given status.",
                        "type": "string"
                    },
                    {
                        "name": "pagination.key",
                        "in": "query",
                        "description": "Format - byte. Format - byte. Format - byte. key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
                        "type": "string",
                        "format": "byte"
                    },
                    {
                        "name": "pagination.offset",
                        "in": "query",
                        "description": "Format - uint64. Format - uint64. Format - uint64. offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
                        "type": "string",
                        "format": "uint64"
                    },
                    {
                        "name": "pagination.limit",
                        "in": "query",
                        "description": "Format - uint64. Format - uint64. Format - uint64. limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
                        "type": "string",
                        "format": "uint64"
                    },
                    {
                        "name": "pagination.count_total",
                        "in": "query",
                        "description": "Format - boolean. Format - boolean. Format - boolean. count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
                        "type": "boolean",
                        "format": "boolean"
                    },
                    {
                        "name": "pagination.reverse",
                        "in": "query",
                        "description": "Format - boolean. Format - boolean. Format - boolean. reverse is set to true if results are to be returned in the descending order.",
                        "type": "boolean",
                        "format": "boolean"
                    }
                ],
                "produces": [
                    "*/*"
                ],
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "title": "QueryValidatorsResponse is response type for the Query/Validators RPC method",
                            "type": "object",
                            "properties": {
                                "validators": {
                                    "description": "validators contains all the queried validators.",
                                    "type": "array",
                                    "items": {
                                        "description": "Validator defines a validator, together with the total amount of the\nValidator's bond shares and their exchange rate to coins. Slashing results in\na decrease in the exchange rate, allowing correct calculation of future\nundelegations without iterating over delegators. When coins are delegated to\nthis validator, the validator is credited with a delegation whose number of\nbond shares is based on the amount of coins delegated divided by the current\nexchange rate. Voting power can be calculated as total bonded shares\nmultiplied by exchange rate.",
                                        "type": "object",
                                        "properties": {
                                            "operator_address": {
                                                "description": "operator_address defines the address of the validator's operator; bech encoded in JSON.",
                                                "type": "string"
                                            },
                                            "consensus_pubkey": {
                                                "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                                "type": "object",
                                                "properties": {
                                                    "type_url": {
                                                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                        "type": "string"
                                                    },
                                                    "value": {
                                                        "format": "byte",
                                                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                        "type": "string"
                                                    }
                                                }
                                            },
                                            "jailed": {
                                                "format": "boolean",
                                                "description": "jailed defined whether the validator has been jailed from bonded status or not.",
                                                "type": "boolean"
                                            },
                                            "status": {
                                                "description": "status is the validator status (bonded/unbonding/unbonded).",
                                                "default": "BOND_STATUS_UNSPECIFIED",
                                                "enum": [
                                                    "BOND_STATUS_UNSPECIFIED",
                                                    "BOND_STATUS_UNBONDED",
                                                    "BOND_STATUS_UNBONDING",
                                                    "BOND_STATUS_BONDED"
                                                ],
                                                "type": "string"
                                            },
                                            "tokens": {
                                                "description": "tokens define the delegated tokens (incl. self-delegation).",
                                                "type": "string"
                                            },
                                            "delegator_shares": {
                                                "description": "delegator_shares defines total shares issued to a validator's delegators.",
                                                "type": "string"
                                            },
                                            "description": {
                                                "description": "description defines the description terms for the validator.",
                                                "type": "object",
                                                "properties": {
                                                    "moniker": {
                                                        "description": "moniker defines a human-readable name for the validator.",
                                                        "type": "string"
                                                    },
                                                    "identity": {
                                                        "description": "identity defines an optional identity signature (ex. UPort or Keybase).",
                                                        "type": "string"
                                                    },
                                                    "website": {
                                                        "description": "website defines an optional website link.",
                                                        "type": "string"
                                                    },
                                                    "security_contact": {
                                                        "description": "security_contact defines an optional email for security contact.",
                                                        "type": "string"
                                                    },
                                                    "details": {
                                                        "description": "details define other optional details.",
                                                        "type": "string"
                                                    }
                                                }
                                            },
                                            "unbonding_height": {
                                                "format": "int64",
                                                "description": "unbonding_height defines, if unbonding, the height at which this validator has begun unbonding.",
                                                "type": "string"
                                            },
                                            "unbonding_time": {
                                                "format": "date-time",
                                                "description": "unbonding_time defines, if unbonding, the min time for the validator to complete unbonding.",
                                                "type": "string"
                                            },
                                            "commission": {
                                                "description": "commission defines the commission parameters.",
                                                "type": "object",
                                                "properties": {
                                                    "commission_rates": {
                                                        "description": "commission_rates defines the initial commission rates to be used for creating a validator.",
                                                        "type": "object",
                                                        "properties": {
                                                            "rate": {
                                                                "description": "rate is the commission rate charged to delegators, as a fraction.",
                                                                "type": "string"
                                                            },
                                                            "max_rate": {
                                                                "description": "max_rate defines the maximum commission rate which validator can ever charge, as a fraction.",
                                                                "type": "string"
                                                            },
                                                            "max_change_rate": {
                                                                "description": "max_change_rate defines the maximum daily increase of the validator commission, as a fraction.",
                                                                "type": "string"
                                                            }
                                                        }
                                                    },
                                                    "update_time": {
                                                        "format": "date-time",
                                                        "description": "update_time is the last time the commission rate was changed.",
                                                        "type": "string"
                                                    }
                                                }
                                            },
                                            "min_self_delegation": {
                                                "description": "min_self_delegation is the validator's self declared minimum self delegation.",
                                                "type": "string"
                                            }
                                        }
                                    }
                                },
                                "pagination": {
                                    "description": "pagination defines the pagination in the response.",
                                    "type": "object",
                                    "properties": {
                                        "next_key": {
                                            "format": "byte",
                                            "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently",
                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                            "type": "string"
                                        },
                                        "total": {
                                            "format": "uint64",
                                            "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                                            "type": "string"
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "400": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "500": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        },
        "/cosmos/staking/v1beta1/validators/{validator_addr}": {
            "get": {
                "description": "Validator queries validator info for given validator address.",
                "operationId": "Validator",
                "summary": "Validator queries validator info for given validator address.",
                "tags": [
                    "Query"
                ],
                "parameters": [
                    {
                        "name": "validator_addr",
                        "in": "path",
                        "description": "validator_addr defines the validator address to query for.",
                        "required": true,
                        "type": "string"
                    }
                ],
                "produces": [
                    "*/*"
                ],
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "title": "QueryValidatorResponse is response type for the Query/Validator RPC method",
                            "type": "object",
                            "properties": {
                                "validator": {
                                    "description": "Validator defines a validator, together with the total amount of the\nValidator's bond shares and their exchange rate to coins. Slashing results in\na decrease in the exchange rate, allowing correct calculation of future\nundelegations without iterating over delegators. When coins are delegated to\nthis validator, the validator is credited with a delegation whose number of\nbond shares is based on the amount of coins delegated divided by the current\nexchange rate. Voting power can be calculated as total bonded shares\nmultiplied by exchange rate.",
                                    "type": "object",
                                    "properties": {
                                        "operator_address": {
                                            "description": "operator_address defines the address of the validator's operator; bech encoded in JSON.",
                                            "type": "string"
                                        },
                                        "consensus_pubkey": {
                                            "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                            "type": "object",
                                            "properties": {
                                                "type_url": {
                                                    "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                    "type": "string"
                                                },
                                                "value": {
                                                    "format": "byte",
                                                    "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                    "type": "string"
                                                }
                                            }
                                        },
                                        "jailed": {
                                            "format": "boolean",
                                            "description": "jailed defined whether the validator has been jailed from bonded status or not.",
                                            "type": "boolean"
                                        },
                                        "status": {
                                            "description": "status is the validator status (bonded/unbonding/unbonded).",
                                            "default": "BOND_STATUS_UNSPECIFIED",
                                            "enum": [
                                                "BOND_STATUS_UNSPECIFIED",
                                                "BOND_STATUS_UNBONDED",
                                                "BOND_STATUS_UNBONDING",
                                                "BOND_STATUS_BONDED"
                                            ],
                                            "type": "string"
                                        },
                                        "tokens": {
                                            "description": "tokens define the delegated tokens (incl. self-delegation).",
                                            "type": "string"
                                        },
                                        "delegator_shares": {
                                            "description": "delegator_shares defines total shares issued to a validator's delegators.",
                                            "type": "string"
                                        },
                                        "description": {
                                            "description": "description defines the description terms for the validator.",
                                            "type": "object",
                                            "properties": {
                                                "moniker": {
                                                    "description": "moniker defines a human-readable name for the validator.",
                                                    "type": "string"
                                                },
                                                "identity": {
                                                    "description": "identity defines an optional identity signature (ex. UPort or Keybase).",
                                                    "type": "string"
                                                },
                                                "website": {
                                                    "description": "website defines an optional website link.",
                                                    "type": "string"
                                                },
                                                "security_contact": {
                                                    "description": "security_contact defines an optional email for security contact.",
                                                    "type": "string"
                                                },
                                                "details": {
                                                    "description": "details define other optional details.",
                                                    "type": "string"
                                                }
                                            }
                                        },
                                        "unbonding_height": {
                                            "format": "int64",
                                            "description": "unbonding_height defines, if unbonding, the height at which this validator has begun unbonding.",
                                            "type": "string"
                                        },
                                        "unbonding_time": {
                                            "format": "date-time",
                                            "description": "unbonding_time defines, if unbonding, the min time for the validator to complete unbonding.",
                                            "type": "string"
                                        },
                                        "commission": {
                                            "description": "commission defines the commission parameters.",
                                            "type": "object",
                                            "properties": {
                                                "commission_rates": {
                                                    "description": "commission_rates defines the initial commission rates to be used for creating a validator.",
                                                    "type": "object",
                                                    "properties": {
                                                        "rate": {
                                                            "description": "rate is the commission rate charged to delegators, as a fraction.",
                                                            "type": "string"
                                                        },
                                                        "max_rate": {
                                                            "description": "max_rate defines the maximum commission rate which validator can ever charge, as a fraction.",
                                                            "type": "string"
                                                        },
                                                        "max_change_rate": {
                                                            "description": "max_change_rate defines the maximum daily increase of the validator commission, as a fraction.",
                                                            "type": "string"
                                                        }
                                                    }
                                                },
                                                "update_time": {
                                                    "format": "date-time",
                                                    "description": "update_time is the last time the commission rate was changed.",
                                                    "type": "string"
                                                }
                                            }
                                        },
                                        "min_self_delegation": {
                                            "description": "min_self_delegation is the validator's self declared minimum self delegation.",
                                            "type": "string"
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "400": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "500": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        },
        "/cosmos/staking/v1beta1/validators/{validator_addr}/delegations": {
            "get": {
                "description": "ValidatorDelegations queries delegate info for given validator.",
                "operationId": "ValidatorDelegations",
                "summary": "ValidatorDelegations queries delegate info for given validator.",
                "tags": [
                    "Query"
                ],
                "parameters": [
                    {
                        "name": "validator_addr",
                        "in": "path",
                        "description": "validator_addr defines the validator address to query for.",
                        "required": true,
                        "type": "string"
                    },
                    {
                        "name": "pagination.key",
                        "in": "query",
                        "description": "Format - byte. Format - byte. Format - byte. key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
                        "type": "string",
                        "format": "byte"
                    },
                    {
                        "name": "pagination.offset",
                        "in": "query",
                        "description": "Format - uint64. Format - uint64. Format - uint64. offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
                        "type": "string",
                        "format": "uint64"
                    },
                    {
                        "name": "pagination.limit",
                        "in": "query",
                        "description": "Format - uint64. Format - uint64. Format - uint64. limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
                        "type": "string",
                        "format": "uint64"
                    },
                    {
                        "name": "pagination.count_total",
                        "in": "query",
                        "description": "Format - boolean. Format - boolean. Format - boolean. count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
                        "type": "boolean",
                        "format": "boolean"
                    },
                    {
                        "name": "pagination.reverse",
                        "in": "query",
                        "description": "Format - boolean. Format - boolean. Format - boolean. reverse is set to true if results are to be returned in the descending order.",
                        "type": "boolean",
                        "format": "boolean"
                    }
                ],
                "produces": [
                    "*/*"
                ],
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "title": "QueryValidatorDelegationsResponse is response type for the\nQuery/ValidatorDelegations RPC method",
                            "type": "object",
                            "properties": {
                                "delegation_responses": {
                                    "type": "array",
                                    "items": {
                                        "description": "DelegationResponse is equivalent to Delegation except that it contains a\nbalance in addition to shares which is more suitable for client responses.",
                                        "type": "object",
                                        "properties": {
                                            "delegation": {
                                                "description": "Delegation represents the bond with tokens held by an account. It is\nowned by one delegator, and is associated with the voting power of one\nvalidator.",
                                                "type": "object",
                                                "properties": {
                                                    "delegator_address": {
                                                        "description": "delegator_address is the bech32-encoded address of the delegator.",
                                                        "type": "string"
                                                    },
                                                    "validator_address": {
                                                        "description": "validator_address is the bech32-encoded address of the validator.",
                                                        "type": "string"
                                                    },
                                                    "shares": {
                                                        "description": "shares define the delegation shares received.",
                                                        "type": "string"
                                                    }
                                                }
                                            },
                                            "balance": {
                                                "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto.",
                                                "type": "object",
                                                "properties": {
                                                    "denom": {
                                                        "type": "string"
                                                    },
                                                    "amount": {
                                                        "type": "string"
                                                    }
                                                }
                                            }
                                        }
                                    }
                                },
                                "pagination": {
                                    "description": "pagination defines the pagination in the response.",
                                    "type": "object",
                                    "properties": {
                                        "next_key": {
                                            "format": "byte",
                                            "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently",
                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                            "type": "string"
                                        },
                                        "total": {
                                            "format": "uint64",
                                            "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                                            "type": "string"
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "400": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "500": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        },
        "/cosmos/staking/v1beta1/validators/{validator_addr}/delegations/{delegator_addr}": {
            "get": {
                "description": "Delegation queries delegate info for given validator delegator pair.",
                "operationId": "Delegation",
                "summary": "Delegation queries delegate info for given validator delegator pair.",
                "tags": [
                    "Query"
                ],
                "parameters": [
                    {
                        "name": "validator_addr",
                        "in": "path",
                        "description": "validator_addr defines the validator address to query for.",
                        "required": true,
                        "type": "string"
                    },
                    {
                        "name": "delegator_addr",
                        "in": "path",
                        "description": "delegator_addr defines the delegator address to query for.",
                        "required": true,
                        "type": "string"
                    }
                ],
                "produces": [
                    "*/*"
                ],
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "description": "QueryDelegationResponse is response type for the Query/Delegation RPC method.",
                            "type": "object",
                            "properties": {
                                "delegation_response": {
                                    "description": "DelegationResponse is equivalent to Delegation except that it contains a\nbalance in addition to shares which is more suitable for client responses.",
                                    "type": "object",
                                    "properties": {
                                        "delegation": {
                                            "description": "Delegation represents the bond with tokens held by an account. It is\nowned by one delegator, and is associated with the voting power of one\nvalidator.",
                                            "type": "object",
                                            "properties": {
                                                "delegator_address": {
                                                    "description": "delegator_address is the bech32-encoded address of the delegator.",
                                                    "type": "string"
                                                },
                                                "validator_address": {
                                                    "description": "validator_address is the bech32-encoded address of the validator.",
                                                    "type": "string"
                                                },
                                                "shares": {
                                                    "description": "shares define the delegation shares received.",
                                                    "type": "string"
                                                }
                                            }
                                        },
                                        "balance": {
                                            "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto.",
                                            "type": "object",
                                            "properties": {
                                                "denom": {
                                                    "type": "string"
                                                },
                                                "amount": {
                                                    "type": "string"
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "400": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "500": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        },
        "/cosmos/staking/v1beta1/validators/{validator_addr}/delegations/{delegator_addr}/unbonding_delegation": {
            "get": {
                "description": "UnbondingDelegation queries unbonding info for given validator delegator\npair.",
                "operationId": "UnbondingDelegation",
                "summary": "UnbondingDelegation queries unbonding info for given validator delegator\npair.",
                "tags": [
                    "Query"
                ],
                "parameters": [
                    {
                        "name": "validator_addr",
                        "in": "path",
                        "description": "validator_addr defines the validator address to query for.",
                        "required": true,
                        "type": "string"
                    },
                    {
                        "name": "delegator_addr",
                        "in": "path",
                        "description": "delegator_addr defines the delegator address to query for.",
                        "required": true,
                        "type": "string"
                    }
                ],
                "produces": [
                    "*/*"
                ],
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "description": "QueryDelegationResponse is response type for the Query/UnbondingDelegation\nRPC method.",
                            "type": "object",
                            "properties": {
                                "unbond": {
                                    "description": "UnbondingDelegation stores all of a single delegator's unbonding bonds\nfor a single validator in an time-ordered list.",
                                    "type": "object",
                                    "properties": {
                                        "delegator_address": {
                                            "description": "delegator_address is the bech32-encoded address of the delegator.",
                                            "type": "string"
                                        },
                                        "validator_address": {
                                            "description": "validator_address is the bech32-encoded address of the validator.",
                                            "type": "string"
                                        },
                                        "entries": {
                                            "description": "entries are the unbonding delegation entries.",
                                            "type": "array",
                                            "items": {
                                                "description": "UnbondingDelegationEntry defines an unbonding object with relevant metadata.",
                                                "type": "object",
                                                "properties": {
                                                    "creation_height": {
                                                        "format": "int64",
                                                        "description": "creation_height is the height which the unbonding took place.",
                                                        "type": "string"
                                                    },
                                                    "completion_time": {
                                                        "format": "date-time",
                                                        "description": "completion_time is the unix time for unbonding completion.",
                                                        "type": "string"
                                                    },
                                                    "initial_balance": {
                                                        "description": "initial_balance defines the tokens initially scheduled to receive at completion.",
                                                        "type": "string"
                                                    },
                                                    "balance": {
                                                        "description": "balance defines the tokens to receive at completion.",
                                                        "type": "string"
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "400": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "500": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        },
        "/cosmos/staking/v1beta1/validators/{validator_addr}/unbonding_delegations": {
            "get": {
                "description": "ValidatorUnbondingDelegations queries unbonding delegations of a validator.",
                "operationId": "ValidatorUnbondingDelegations",
                "summary": "ValidatorUnbondingDelegations queries unbonding delegations of a validator.",
                "tags": [
                    "Query"
                ],
                "parameters": [
                    {
                        "name": "validator_addr",
                        "in": "path",
                        "description": "validator_addr defines the validator address to query for.",
                        "required": true,
                        "type": "string"
                    },
                    {
                        "name": "pagination.key",
                        "in": "query",
                        "description": "Format - byte. Format - byte. Format - byte. key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
                        "type": "string",
                        "format": "byte"
                    },
                    {
                        "name": "pagination.offset",
                        "in": "query",
                        "description": "Format - uint64. Format - uint64. Format - uint64. offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
                        "type": "string",
                        "format": "uint64"
                    },
                    {
                        "name": "pagination.limit",
                        "in": "query",
                        "description": "Format - uint64. Format - uint64. Format - uint64. limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
                        "type": "string",
                        "format": "uint64"
                    },
                    {
                        "name": "pagination.count_total",
                        "in": "query",
                        "description": "Format - boolean. Format - boolean. Format - boolean. count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
                        "type": "boolean",
                        "format": "boolean"
                    },
                    {
                        "name": "pagination.reverse",
                        "in": "query",
                        "description": "Format - boolean. Format - boolean. Format - boolean. reverse is set to true if results are to be returned in the descending order.",
                        "type": "boolean",
                        "format": "boolean"
                    }
                ],
                "produces": [
                    "*/*"
                ],
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "description": "QueryValidatorUnbondingDelegationsResponse is response type for the\nQuery/ValidatorUnbondingDelegations RPC method.",
                            "type": "object",
                            "properties": {
                                "unbonding_responses": {
                                    "type": "array",
                                    "items": {
                                        "description": "UnbondingDelegation stores all of a single delegator's unbonding bonds\nfor a single validator in an time-ordered list.",
                                        "type": "object",
                                        "properties": {
                                            "delegator_address": {
                                                "description": "delegator_address is the bech32-encoded address of the delegator.",
                                                "type": "string"
                                            },
                                            "validator_address": {
                                                "description": "validator_address is the bech32-encoded address of the validator.",
                                                "type": "string"
                                            },
                                            "entries": {
                                                "description": "entries are the unbonding delegation entries.",
                                                "type": "array",
                                                "items": {
                                                    "description": "UnbondingDelegationEntry defines an unbonding object with relevant metadata.",
                                                    "type": "object",
                                                    "properties": {
                                                        "creation_height": {
                                                            "format": "int64",
                                                            "description": "creation_height is the height which the unbonding took place.",
                                                            "type": "string"
                                                        },
                                                        "completion_time": {
                                                            "format": "date-time",
                                                            "description": "completion_time is the unix time for unbonding completion.",
                                                            "type": "string"
                                                        },
                                                        "initial_balance": {
                                                            "description": "initial_balance defines the tokens initially scheduled to receive at completion.",
                                                            "type": "string"
                                                        },
                                                        "balance": {
                                                            "description": "balance defines the tokens to receive at completion.",
                                                            "type": "string"
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                },
                                "pagination": {
                                    "description": "pagination defines the pagination in the response.",
                                    "type": "object",
                                    "properties": {
                                        "next_key": {
                                            "format": "byte",
                                            "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently",
                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                            "type": "string"
                                        },
                                        "total": {
                                            "format": "uint64",
                                            "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                                            "type": "string"
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "400": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "500": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        },
        "/cosmos/tx/v1beta1/simulate": {
            "post": {
                "description": "Simulate simulates executing a transaction for estimating gas usage.",
                "operationId": "Simulate",
                "summary": "Simulate simulates executing a transaction for estimating gas usage.",
                "tags": [
                    "Service"
                ],
                "parameters": [
                    {
                        "name": "cosmos.tx.v1beta1.SimulateRequest",
                        "in": "body",
                        "schema": {
                            "$ref": "#/definitions/cosmos.tx.v1beta1.SimulateRequest"
                        }
                    }
                ],
                "consumes": [
                    "*/*"
                ],
                "produces": [
                    "*/*"
                ],
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "description": "SimulateResponse is the response type for the\nService.SimulateRPC method.",
                            "type": "object",
                            "properties": {
                                "gas_info": {
                                    "description": "gas_info is the information about gas used in the simulation.",
                                    "type": "object",
                                    "properties": {
                                        "gas_wanted": {
                                            "format": "uint64",
                                            "description": "GasWanted is the maximum units of work we allow this tx to perform.",
                                            "type": "string"
                                        },
                                        "gas_used": {
                                            "format": "uint64",
                                            "description": "GasUsed is the amount of gas actually consumed.",
                                            "type": "string"
                                        }
                                    }
                                },
                                "result": {
                                    "description": "result is the result of the simulation.",
                                    "type": "object",
                                    "properties": {
                                        "data": {
                                            "format": "byte",
                                            "description": "Data is any data returned from message or handler execution. It MUST be\nlength prefixed in order to separate data from multiple message executions.",
                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                            "type": "string"
                                        },
                                        "log": {
                                            "description": "Log contains the log information from message or handler execution.",
                                            "type": "string"
                                        },
                                        "events": {
                                            "description": "Events contains a slice of Event objects that were emitted during message\nor handler execution.",
                                            "type": "array",
                                            "items": {
                                                "description": "Event allows application developers to attach additional information to\nResponseBeginBlock, ResponseEndBlock, ResponseCheckTx and ResponseDeliverTx.\nLater, transactions may be queried using these events.",
                                                "type": "object",
                                                "properties": {
                                                    "type": {
                                                        "type": "string"
                                                    },
                                                    "attributes": {
                                                        "type": "array",
                                                        "items": {
                                                            "description": "EventAttribute is a single key-value pair, associated with an event.",
                                                            "type": "object",
                                                            "properties": {
                                                                "key": {
                                                                    "format": "byte",
                                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                    "type": "string"
                                                                },
                                                                "value": {
                                                                    "format": "byte",
                                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                    "type": "string"
                                                                },
                                                                "index": {
                                                                    "format": "boolean",
                                                                    "type": "boolean"
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "400": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "500": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        },
        "/cosmos/tx/v1beta1/txs": {
            "get": {
                "description": "GetTxsEvent fetches txs by event.",
                "operationId": "GetTxsEvent",
                "summary": "GetTxsEvent fetches txs by event.",
                "tags": [
                    "Service"
                ],
                "parameters": [
                    {
                        "name": "events",
                        "in": "query",
                        "description": "events is the list of transaction event type.",
                        "type": "array",
                        "items": {
                            "type": "string"
                        }
                    },
                    {
                        "name": "pagination.key",
                        "in": "query",
                        "description": "Format - byte. Format - byte. Format - byte. key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
                        "type": "string",
                        "format": "byte"
                    },
                    {
                        "name": "pagination.offset",
                        "in": "query",
                        "description": "Format - uint64. Format - uint64. Format - uint64. offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
                        "type": "string",
                        "format": "uint64"
                    },
                    {
                        "name": "pagination.limit",
                        "in": "query",
                        "description": "Format - uint64. Format - uint64. Format - uint64. limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
                        "type": "string",
                        "format": "uint64"
                    },
                    {
                        "name": "pagination.count_total",
                        "in": "query",
                        "description": "Format - boolean. Format - boolean. Format - boolean. count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
                        "type": "boolean",
                        "format": "boolean"
                    },
                    {
                        "name": "pagination.reverse",
                        "in": "query",
                        "description": "Format - boolean. Format - boolean. Format - boolean. reverse is set to true if results are to be returned in the descending order.",
                        "type": "boolean",
                        "format": "boolean"
                    },
                    {
                        "name": "order_by",
                        "in": "query",
                        "description": " - ORDER_BY_UNSPECIFIED: ORDER_BY_UNSPECIFIED specifies an unknown sorting order. OrderBy defaults to ASC in this case.\n - ORDER_BY_ASC: ORDER_BY_ASC defines ascending order\n - ORDER_BY_DESC: ORDER_BY_DESC defines descending order",
                        "type": "string",
                        "default": "ORDER_BY_UNSPECIFIED",
                        "enum": [
                            "ORDER_BY_UNSPECIFIED",
                            "ORDER_BY_ASC",
                            "ORDER_BY_DESC"
                        ]
                    }
                ],
                "produces": [
                    "*/*"
                ],
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/cosmos.tx.v1beta1.GetTxsEventResponse"
                        }
                    },
                    "400": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "500": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            },
            "post": {
                "description": "BroadcastTx broadcast transaction.",
                "operationId": "BroadcastTx",
                "summary": "BroadcastTx broadcast transaction.",
                "tags": [
                    "Service"
                ],
                "parameters": [
                    {
                        "name": "cosmosTxV1beta1TxsPostRequest",
                        "in": "body",
                        "schema": {
                            "description": "BroadcastTxRequest is the request type for the Service.BroadcastTxRequest\nRPC method.",
                            "type": "object",
                            "properties": {
                                "tx_bytes": {
                                    "format": "byte",
                                    "description": "tx_bytes is the raw transaction.",
                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                    "type": "string"
                                },
                                "mode": {
                                    "description": "BroadcastMode specifies the broadcast mode for the TxService.Broadcast RPC method.\n\n - BROADCAST_MODE_UNSPECIFIED: zero-value for mode ordering\n - BROADCAST_MODE_BLOCK: BROADCAST_MODE_BLOCK defines a tx broadcasting mode where the client waits for\nthe tx to be committed in a block.\n - BROADCAST_MODE_SYNC: BROADCAST_MODE_SYNC defines a tx broadcasting mode where the client waits for\na CheckTx execution response only.\n - BROADCAST_MODE_ASYNC: BROADCAST_MODE_ASYNC defines a tx broadcasting mode where the client returns\nimmediately.",
                                    "default": "BROADCAST_MODE_UNSPECIFIED",
                                    "enum": [
                                        "BROADCAST_MODE_UNSPECIFIED",
                                        "BROADCAST_MODE_BLOCK",
                                        "BROADCAST_MODE_SYNC",
                                        "BROADCAST_MODE_ASYNC"
                                    ],
                                    "type": "string"
                                }
                            }
                        }
                    }
                ],
                "consumes": [
                    "*/*"
                ],
                "produces": [
                    "*/*"
                ],
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "description": "BroadcastTxResponse is the response type for the\nService.BroadcastTx method.",
                            "type": "object",
                            "properties": {
                                "tx_response": {
                                    "description": "TxResponse defines a structure containing relevant tx data and metadata. The\ntags are stringified and the log is JSON decoded.",
                                    "type": "object",
                                    "properties": {
                                        "height": {
                                            "format": "int64",
                                            "title": "The block height",
                                            "type": "string"
                                        },
                                        "txhash": {
                                            "description": "The transaction hash.",
                                            "type": "string"
                                        },
                                        "codespace": {
                                            "title": "Namespace for the Code",
                                            "type": "string"
                                        },
                                        "code": {
                                            "format": "int64",
                                            "description": "Response code.",
                                            "type": "integer"
                                        },
                                        "data": {
                                            "description": "Result bytes, if any.",
                                            "type": "string"
                                        },
                                        "raw_log": {
                                            "description": "The output of the application's logger (raw string). May be\nnon-deterministic.",
                                            "type": "string"
                                        },
                                        "logs": {
                                            "description": "The output of the application's logger (typed). May be non-deterministic.",
                                            "type": "array",
                                            "items": {
                                                "description": "ABCIMessageLog defines a structure containing an indexed tx ABCI message log.",
                                                "type": "object",
                                                "properties": {
                                                    "msg_index": {
                                                        "format": "int64",
                                                        "type": "integer"
                                                    },
                                                    "log": {
                                                        "type": "string"
                                                    },
                                                    "events": {
                                                        "description": "Events contains a slice of Event objects that were emitted during some\nexecution.",
                                                        "type": "array",
                                                        "items": {
                                                            "description": "StringEvent defines en Event object wrapper where all the attributes\ncontain key/value pairs that are strings instead of raw bytes.",
                                                            "type": "object",
                                                            "properties": {
                                                                "type": {
                                                                    "type": "string"
                                                                },
                                                                "attributes": {
                                                                    "type": "array",
                                                                    "items": {
                                                                        "description": "Attribute defines an attribute wrapper where the key and value are\nstrings instead of raw bytes.",
                                                                        "type": "object",
                                                                        "properties": {
                                                                            "key": {
                                                                                "type": "string"
                                                                            },
                                                                            "value": {
                                                                                "type": "string"
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        },
                                        "info": {
                                            "description": "Additional information. May be non-deterministic.",
                                            "type": "string"
                                        },
                                        "gas_wanted": {
                                            "format": "int64",
                                            "description": "Amount of gas requested for transaction.",
                                            "type": "string"
                                        },
                                        "gas_used": {
                                            "format": "int64",
                                            "description": "Amount of gas consumed by transaction.",
                                            "type": "string"
                                        },
                                        "tx": {
                                            "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                            "type": "object",
                                            "properties": {
                                                "type_url": {
                                                    "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                    "type": "string"
                                                },
                                                "value": {
                                                    "format": "byte",
                                                    "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                    "type": "string"
                                                }
                                            }
                                        },
                                        "timestamp": {
                                            "description": "Time of the previous block. For heights > 1, it's the weighted median of\nthe timestamps of the valid votes in the block.LastCommit. For height == 1,\nit's genesis time.",
                                            "type": "string"
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "400": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "500": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        },
        "/cosmos/tx/v1beta1/txs/{hash}": {
            "get": {
                "description": "GetTx fetches a tx by hash.",
                "operationId": "GetTx",
                "summary": "GetTx fetches a tx by hash.",
                "tags": [
                    "Service"
                ],
                "parameters": [
                    {
                        "name": "hash",
                        "in": "path",
                        "description": "hash is the tx hash to query, encoded as a hex string.",
                        "required": true,
                        "type": "string"
                    }
                ],
                "produces": [
                    "*/*"
                ],
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "$ref": "#/definitions/cosmos.tx.v1beta1.GetTxResponse"
                        }
                    },
                    "400": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "500": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        },
        "/cosmos/upgrade/v1beta1/applied_plan/{name}": {
            "get": {
                "description": "AppliedPlan queries a previously applied upgrade plan by its name.",
                "operationId": "AppliedPlan",
                "summary": "AppliedPlan queries a previously applied upgrade plan by its name.",
                "tags": [
                    "Query"
                ],
                "parameters": [
                    {
                        "name": "name",
                        "in": "path",
                        "description": "name is the name of the applied plan to query for.",
                        "required": true,
                        "type": "string"
                    }
                ],
                "produces": [
                    "*/*"
                ],
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "description": "QueryAppliedPlanResponse is the response type for the Query/AppliedPlan RPC\nmethod.",
                            "type": "object",
                            "properties": {
                                "height": {
                                    "format": "int64",
                                    "description": "height is the block height at which the plan was applied.",
                                    "type": "string"
                                }
                            }
                        }
                    },
                    "400": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "500": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        },
        "/cosmos/upgrade/v1beta1/current_plan": {
            "get": {
                "description": "CurrentPlan queries the current upgrade plan.",
                "operationId": "CurrentPlan",
                "summary": "CurrentPlan queries the current upgrade plan.",
                "tags": [
                    "Query"
                ],
                "produces": [
                    "*/*"
                ],
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "description": "QueryCurrentPlanResponse is the response type for the Query/CurrentPlan RPC\nmethod.",
                            "type": "object",
                            "properties": {
                                "plan": {
                                    "description": "plan is the current upgrade plan.",
                                    "type": "object",
                                    "properties": {
                                        "name": {
                                            "description": "Sets the name for the upgrade. This name will be used by the upgraded\nversion of the software to apply any special \"on-upgrade\" commands during\nthe first BeginBlock method after the upgrade is applied. It is also used\nto detect whether a software version can handle a given upgrade. If no\nupgrade handler with this name has been set in the software, it will be\nassumed that the software is out-of-date when the upgrade Time or Height is\nreached and the software will exit.",
                                            "type": "string"
                                        },
                                        "time": {
                                            "format": "date-time",
                                            "description": "Deprecated: Time based upgrades have been deprecated. Time based upgrade logic\nhas been removed from the SDK.\nIf this field is not empty, an error will be thrown.",
                                            "type": "string"
                                        },
                                        "height": {
                                            "format": "int64",
                                            "description": "The height at which the upgrade must be performed.\nOnly used if Time is not set.",
                                            "type": "string"
                                        },
                                        "info": {
                                            "title": "Any application specific upgrade info to be included on-chain\nsuch as a git commit that validators could automatically upgrade to",
                                            "type": "string"
                                        },
                                        "upgraded_client_state": {
                                            "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                            "type": "object",
                                            "properties": {
                                                "type_url": {
                                                    "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                    "type": "string"
                                                },
                                                "value": {
                                                    "format": "byte",
                                                    "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                    "type": "string"
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "400": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "500": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        },
        "/cosmos/upgrade/v1beta1/module_versions": {
            "get": {
                "description": "ModuleVersions queries the list of module versions from state.",
                "operationId": "ModuleVersions",
                "summary": "ModuleVersions queries the list of module versions from state.",
                "tags": [
                    "Query"
                ],
                "parameters": [
                    {
                        "name": "module_name",
                        "in": "query",
                        "description": "module_name is a field to query a specific module\nconsensus version from state. Leaving this empty will\nfetch the full list of module versions from state.",
                        "type": "string"
                    }
                ],
                "produces": [
                    "*/*"
                ],
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "description": "QueryModuleVersionsResponse is the response type for the Query/ModuleVersions\nRPC method.",
                            "type": "object",
                            "properties": {
                                "module_versions": {
                                    "description": "module_versions is a list of module names with their consensus versions.",
                                    "type": "array",
                                    "items": {
                                        "description": "ModuleVersion specifies a module and its consensus version.",
                                        "type": "object",
                                        "properties": {
                                            "name": {
                                                "title": "name of the app module",
                                                "type": "string"
                                            },
                                            "version": {
                                                "format": "uint64",
                                                "title": "consensus version of the app module",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "400": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "500": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        },
        "/cosmos/upgrade/v1beta1/upgraded_consensus_state/{last_height}": {
            "get": {
                "description": "UpgradedConsensusState queries the consensus state that will serve\n\nas a trusted kernel for the next version of this chain. It will only be\n\nstored at the last height of this chain.\n\nUpgradedConsensusState RPC not supported with legacy querier\nThis rpc is deprecated now that IBC has its own replacement\n\n(https://github.com/cosmos/ibc-go/blob/2c880a22e9f9cc75f62b527ca94aa75ce1106001/proto/ibc/core/client/v1/query.proto#L54)",
                "operationId": "UpgradedConsensusState",
                "summary": "UpgradedConsensusState queries the consensus state that will serve\n\nas a trusted kernel for the next version of this chain. It will only be\n\nstored at the last height of this chain.\n\nUpgradedConsensusState RPC not supported with legacy querier\nThis rpc is deprecated now that IBC has its own replacem",
                "tags": [
                    "Query"
                ],
                "parameters": [
                    {
                        "name": "last_height",
                        "in": "path",
                        "description": "Format - int64. Format - int64. Format - int64. last height of the current chain must be sent in request\nas this is the height under which next consensus state is stored",
                        "required": true,
                        "type": "string",
                        "format": "int64"
                    }
                ],
                "produces": [
                    "*/*"
                ],
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "description": "QueryUpgradedConsensusStateResponse is the response type for the Query/UpgradedConsensusState\nRPC method.",
                            "type": "object",
                            "properties": {
                                "upgraded_consensus_state": {
                                    "format": "byte",
                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                    "type": "string"
                                }
                            }
                        }
                    },
                    "400": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "500": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        },
        "/cosmos/authz/v1beta1/grants": {
            "get": {
                "description": "Returns list of `Authorization`, granted to the grantee by the granter.",
                "operationId": "Grants",
                "summary": "Returns list of `Authorization`, granted to the grantee by the granter.",
                "tags": [
                    "Query"
                ],
                "parameters": [
                    {
                        "name": "granter",
                        "in": "query",
                        "type": "string"
                    },
                    {
                        "name": "grantee",
                        "in": "query",
                        "type": "string"
                    },
                    {
                        "name": "msg_type_url",
                        "in": "query",
                        "description": "Optional, msg_type_url, when set, will query only grants matching given msg type.",
                        "type": "string"
                    },
                    {
                        "name": "pagination.key",
                        "in": "query",
                        "description": "Format - byte. Format - byte. Format - byte. key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
                        "type": "string",
                        "format": "byte"
                    },
                    {
                        "name": "pagination.offset",
                        "in": "query",
                        "description": "Format - uint64. Format - uint64. Format - uint64. offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
                        "type": "string",
                        "format": "uint64"
                    },
                    {
                        "name": "pagination.limit",
                        "in": "query",
                        "description": "Format - uint64. Format - uint64. Format - uint64. limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
                        "type": "string",
                        "format": "uint64"
                    },
                    {
                        "name": "pagination.count_total",
                        "in": "query",
                        "description": "Format - boolean. Format - boolean. Format - boolean. count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
                        "type": "boolean",
                        "format": "boolean"
                    },
                    {
                        "name": "pagination.reverse",
                        "in": "query",
                        "description": "Format - boolean. Format - boolean. Format - boolean. reverse is set to true if results are to be returned in the descending order.",
                        "type": "boolean",
                        "format": "boolean"
                    }
                ],
                "produces": [
                    "*/*"
                ],
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "description": "QueryGrantsResponse is the response type for the Query/Authorizations RPC method.",
                            "type": "object",
                            "properties": {
                                "grants": {
                                    "description": "authorizations is a list of grants granted for grantee by granter.",
                                    "type": "array",
                                    "items": {
                                        "description": "Grant gives permissions to execute\nthe provide method with expiration time.",
                                        "type": "object",
                                        "properties": {
                                            "authorization": {
                                                "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                                "type": "object",
                                                "properties": {
                                                    "type_url": {
                                                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                        "type": "string"
                                                    },
                                                    "value": {
                                                        "format": "byte",
                                                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                        "type": "string"
                                                    }
                                                }
                                            },
                                            "expiration": {
                                                "format": "date-time",
                                                "type": "string"
                                            }
                                        }
                                    }
                                },
                                "pagination": {
                                    "description": "pagination defines an pagination for the response.",
                                    "type": "object",
                                    "properties": {
                                        "next_key": {
                                            "format": "byte",
                                            "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently",
                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                            "type": "string"
                                        },
                                        "total": {
                                            "format": "uint64",
                                            "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                                            "type": "string"
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "400": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "500": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        },
        "/cosmos/feegrant/v1beta1/allowance/{granter}/{grantee}": {
            "get": {
                "description": "Allowance returns fee granted to the grantee by the granter.",
                "operationId": "Allowance",
                "summary": "Allowance returns fee granted to the grantee by the granter.",
                "tags": [
                    "Query"
                ],
                "parameters": [
                    {
                        "name": "granter",
                        "in": "path",
                        "description": "granter is the address of the user granting an allowance of their funds.",
                        "required": true,
                        "type": "string"
                    },
                    {
                        "name": "grantee",
                        "in": "path",
                        "description": "grantee is the address of the user being granted an allowance of another user's funds.",
                        "required": true,
                        "type": "string"
                    }
                ],
                "produces": [
                    "*/*"
                ],
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "description": "QueryAllowanceResponse is the response type for the Query/Allowance RPC method.",
                            "type": "object",
                            "properties": {
                                "allowance": {
                                    "title": "Grant is stored in the KVStore to record a grant with full context",
                                    "description": "allowance is a allowance granted for grantee by granter.",
                                    "type": "object",
                                    "properties": {
                                        "granter": {
                                            "description": "granter is the address of the user granting an allowance of their funds.",
                                            "type": "string"
                                        },
                                        "grantee": {
                                            "description": "grantee is the address of the user being granted an allowance of another user's funds.",
                                            "type": "string"
                                        },
                                        "allowance": {
                                            "description": "allowance can be any of basic and filtered fee allowance.",
                                            "type": "object",
                                            "properties": {
                                                "type_url": {
                                                    "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                    "type": "string"
                                                },
                                                "value": {
                                                    "format": "byte",
                                                    "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                    "type": "string"
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "400": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "500": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        },
        "/cosmos/feegrant/v1beta1/allowances/{grantee}": {
            "get": {
                "description": "Allowances returns all the grants for address.",
                "operationId": "Allowances",
                "summary": "Allowances returns all the grants for address.",
                "tags": [
                    "Query"
                ],
                "parameters": [
                    {
                        "name": "grantee",
                        "in": "path",
                        "required": true,
                        "type": "string"
                    },
                    {
                        "name": "pagination.key",
                        "in": "query",
                        "description": "Format - byte. Format - byte. Format - byte. key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
                        "type": "string",
                        "format": "byte"
                    },
                    {
                        "name": "pagination.offset",
                        "in": "query",
                        "description": "Format - uint64. Format - uint64. Format - uint64. offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
                        "type": "string",
                        "format": "uint64"
                    },
                    {
                        "name": "pagination.limit",
                        "in": "query",
                        "description": "Format - uint64. Format - uint64. Format - uint64. limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
                        "type": "string",
                        "format": "uint64"
                    },
                    {
                        "name": "pagination.count_total",
                        "in": "query",
                        "description": "Format - boolean. Format - boolean. Format - boolean. count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
                        "type": "boolean",
                        "format": "boolean"
                    },
                    {
                        "name": "pagination.reverse",
                        "in": "query",
                        "description": "Format - boolean. Format - boolean. Format - boolean. reverse is set to true if results are to be returned in the descending order.",
                        "type": "boolean",
                        "format": "boolean"
                    }
                ],
                "produces": [
                    "*/*"
                ],
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "description": "QueryAllowancesResponse is the response type for the Query/Allowances RPC method.",
                            "type": "object",
                            "properties": {
                                "allowances": {
                                    "description": "allowances are allowance's granted for grantee by granter.",
                                    "type": "array",
                                    "items": {
                                        "title": "Grant is stored in the KVStore to record a grant with full context",
                                        "type": "object",
                                        "properties": {
                                            "granter": {
                                                "description": "granter is the address of the user granting an allowance of their funds.",
                                                "type": "string"
                                            },
                                            "grantee": {
                                                "description": "grantee is the address of the user being granted an allowance of another user's funds.",
                                                "type": "string"
                                            },
                                            "allowance": {
                                                "description": "allowance can be any of basic and filtered fee allowance.",
                                                "type": "object",
                                                "properties": {
                                                    "type_url": {
                                                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                        "type": "string"
                                                    },
                                                    "value": {
                                                        "format": "byte",
                                                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                        "type": "string"
                                                    }
                                                }
                                            }
                                        }
                                    }
                                },
                                "pagination": {
                                    "description": "pagination defines an pagination for the response.",
                                    "type": "object",
                                    "properties": {
                                        "next_key": {
                                            "format": "byte",
                                            "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently",
                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                            "type": "string"
                                        },
                                        "total": {
                                            "format": "uint64",
                                            "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                                            "type": "string"
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "400": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "500": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        },
        "/registration/v1beta1/encrypted-seed/{pub_key}": {
            "get": {
                "description": "Returns the encrypted seed for a registered node by public key",
                "operationId": "EncryptedSeed",
                "summary": "Returns the encrypted seed for a registered node by public key",
                "tags": [
                    "Query"
                ],
                "parameters": [
                    {
                        "name": "pub_key",
                        "in": "path",
                        "description": "Format - byte. Format - byte. Format - byte.",
                        "required": true,
                        "type": "string",
                        "format": "byte"
                    }
                ],
                "produces": [
                    "*/*"
                ],
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "encrypted_seed": {
                                    "format": "byte",
                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                    "type": "string"
                                }
                            }
                        }
                    },
                    "400": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "500": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        },
        "/registration/v1beta1/registration-key": {
            "get": {
                "description": "Returns the key used for registration",
                "operationId": "RegistrationKeyNew",
                "summary": "Returns the key used for registration",
                "tags": [
                    "Query"
                ],
                "produces": [
                    "*/*"
                ],
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "key": {
                                    "format": "byte",
                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                    "type": "string"
                                }
                            }
                        }
                    },
                    "400": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "500": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        },
        "/registration/v1beta1/tx-key": {
            "get": {
                "description": "Returns the key used for transactions",
                "operationId": "TxKeyNew",
                "summary": "Returns the key used for transactions",
                "tags": [
                    "Query"
                ],
                "produces": [
                    "*/*"
                ],
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "key": {
                                    "format": "byte",
                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                    "type": "string"
                                }
                            }
                        }
                    },
                    "400": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "500": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        },
        "/compute/v1beta1/code": {
            "get": {
                "description": "Codes",
                "operationId": "Codes",
                "summary": "Codes",
                "tags": [
                    "Query"
                ],
                "produces": [
                    "*/*"
                ],
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "code_infos": {
                                    "type": "array",
                                    "items": {
                                        "type": "object",
                                        "properties": {
                                            "code_id": {
                                                "format": "uint64",
                                                "type": "string"
                                            },
                                            "creator": {
                                                "format": "byte",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            },
                                            "data_hash": {
                                                "format": "byte",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            },
                                            "source": {
                                                "type": "string"
                                            },
                                            "builder": {
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "400": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "500": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        },
        "/compute/v1beta1/code/{code_id}": {
            "get": {
                "description": "Code",
                "operationId": "Code",
                "summary": "Code",
                "tags": [
                    "Query"
                ],
                "parameters": [
                    {
                        "name": "code_id",
                        "in": "path",
                        "description": "Format - uint64. Format - uint64. Format - uint64.",
                        "required": true,
                        "type": "string",
                        "format": "uint64"
                    }
                ],
                "produces": [
                    "*/*"
                ],
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "code_info": {
                                    "type": "object",
                                    "properties": {
                                        "code_id": {
                                            "format": "uint64",
                                            "type": "string"
                                        },
                                        "creator": {
                                            "format": "byte",
                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                            "type": "string"
                                        },
                                        "data_hash": {
                                            "format": "byte",
                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                            "type": "string"
                                        },
                                        "source": {
                                            "type": "string"
                                        },
                                        "builder": {
                                            "type": "string"
                                        }
                                    }
                                },
                                "data": {
                                    "format": "byte",
                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                    "type": "string"
                                }
                            }
                        }
                    },
                    "400": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "500": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        },
        "/compute/v1beta1/code/{code_id}/contracts": {
            "get": {
                "description": "rpc ContractHistory (QueryContractHistoryRequest) returns (QueryContractHistoryResponse) {\noption (google.api.http).get = \"/compute/v1beta1/contract/{address}/history\";\n}",
                "operationId": "ContractsByCode",
                "summary": "rpc ContractHistory (QueryContractHistoryRequest) returns (QueryContractHistoryResponse) {\noption (google.api.http).get = \"/compute/v1beta1/contract/{address}/history\";\n}",
                "tags": [
                    "Query"
                ],
                "parameters": [
                    {
                        "name": "code_id",
                        "in": "path",
                        "description": "Format - uint64. Format - uint64. Format - uint64.",
                        "required": true,
                        "type": "string",
                        "format": "uint64"
                    }
                ],
                "produces": [
                    "*/*"
                ],
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "contract_infos": {
                                    "type": "array",
                                    "items": {
                                        "title": "ContractInfoWithAddress adds the address (key) to the ContractInfo representation",
                                        "type": "object",
                                        "properties": {
                                            "address": {
                                                "format": "byte",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            },
                                            "ContractInfo": {
                                                "title": "ContractInfo stores a WASM contract instance",
                                                "type": "object",
                                                "properties": {
                                                    "code_id": {
                                                        "format": "uint64",
                                                        "type": "string"
                                                    },
                                                    "creator": {
                                                        "format": "byte",
                                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                        "type": "string"
                                                    },
                                                    "label": {
                                                        "title": "bytes admin = 3 [(gogoproto.casttype) = \"github.com/cosmos/cosmos-sdk/types.AccAddress\"];",
                                                        "type": "string"
                                                    },
                                                    "created": {
                                                        "title": "never show this in query results, just use for sorting\n(Note: when using json tag \"-\" amino refused to serialize it...)",
                                                        "type": "object",
                                                        "properties": {
                                                            "block_height": {
                                                                "format": "int64",
                                                                "title": "BlockHeight is the block the contract was created at",
                                                                "type": "string"
                                                            },
                                                            "tx_index": {
                                                                "format": "uint64",
                                                                "title": "TxIndex is a monotonic counter within the block (actual transaction index, or gas consumed)",
                                                                "type": "string"
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "400": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "500": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        },
        "/compute/v1beta1/contract/{address}": {
            "get": {
                "description": "ContractInfo",
                "operationId": "ContractInfo",
                "summary": "ContractInfo",
                "tags": [
                    "Query"
                ],
                "parameters": [
                    {
                        "name": "address",
                        "in": "path",
                        "description": "Format - byte. Format - byte. Format - byte. address is the address of the contract to query",
                        "required": true,
                        "type": "string",
                        "format": "byte"
                    }
                ],
                "produces": [
                    "*/*"
                ],
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "title": "QueryContractInfoResponse is the response type for the Query/ContractInfo RPC method",
                            "type": "object",
                            "properties": {
                                "address": {
                                    "format": "byte",
                                    "title": "address is the address of the contract",
                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                    "type": "string"
                                },
                                "ContractInfo": {
                                    "title": "ContractInfo stores a WASM contract instance",
                                    "type": "object",
                                    "properties": {
                                        "code_id": {
                                            "format": "uint64",
                                            "type": "string"
                                        },
                                        "creator": {
                                            "format": "byte",
                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                            "type": "string"
                                        },
                                        "label": {
                                            "title": "bytes admin = 3 [(gogoproto.casttype) = \"github.com/cosmos/cosmos-sdk/types.AccAddress\"];",
                                            "type": "string"
                                        },
                                        "created": {
                                            "title": "never show this in query results, just use for sorting\n(Note: when using json tag \"-\" amino refused to serialize it...)",
                                            "type": "object",
                                            "properties": {
                                                "block_height": {
                                                    "format": "int64",
                                                    "title": "BlockHeight is the block the contract was created at",
                                                    "type": "string"
                                                },
                                                "tx_index": {
                                                    "format": "uint64",
                                                    "title": "TxIndex is a monotonic counter within the block (actual transaction index, or gas consumed)",
                                                    "type": "string"
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "400": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "500": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        },
        "/compute/v1beta1/contract/{address}/smart/{query_data}": {
            "get": {
                "description": "rpc AllContractState (QueryAllContractStateRequest) returns (QueryAllContractStateResponse) {\noption (google.api.http).get = \"/compute/v1beta1/contract/{address}/state\";\n}\nrpc RawContractState (QueryRawContractStateRequest) returns (QueryRawContractStateResponse) {\noption (google.api.http).get = \"/compute/v1beta1/contract/{address}/raw/{query_data}\";\n}",
                "operationId": "SmartContractState",
                "summary": "rpc AllContractState (QueryAllContractStateRequest) returns (QueryAllContractStateResponse) {\noption (google.api.http).get = \"/compute/v1beta1/contract/{address}/state\";\n}\nrpc RawContractState (QueryRawContractStateRequest) returns (QueryRawContractStateResponse) {\noption (google.api.http).get = \"/c",
                "tags": [
                    "Query"
                ],
                "parameters": [
                    {
                        "name": "address",
                        "in": "path",
                        "description": "Format - byte. Format - byte. Format - byte. address is the address of the contract",
                        "required": true,
                        "type": "string",
                        "format": "byte"
                    },
                    {
                        "name": "query_data",
                        "in": "path",
                        "description": "Format - byte. Format - byte. Format - byte.",
                        "required": true,
                        "type": "string",
                        "format": "byte"
                    }
                ],
                "produces": [
                    "*/*"
                ],
                "responses": {
                    "200": {
                        "description": "A successful response.",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "data": {
                                    "format": "byte",
                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                    "type": "string"
                                }
                            }
                        }
                    },
                    "400": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    "500": {
                        "description": "An unexpected error response",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "error": {
                                    "type": "string"
                                },
                                "code": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "message": {
                                    "type": "string"
                                },
                                "details": {
                                    "type": "array",
                                    "items": {
                                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        },
        "/reg/tx-key": {
            "get": {
                "description": "Gets the network's public key, which is used to derive an encryption key for each transaction",
                "operationId": "TxKey",
                "summary": "Get public transaction key",
                "tags": [
                    "Reg"
                ],
                "produces": [
                    "*/*"
                ],
                "responses": {
                    "200": {
                        "description": "OK",
                        "schema": {
                            "type": "object",
                            "properties": {
                                "height": {
                                    "type": "string"
                                },
                                "result": {
                                    "type": "object",
                                    "properties": {
                                        "TxKey": {
                                            "type": "string"
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        },
        "/ibc/*": {
            "get": {
                "operationId": "ibc-operations",
                "summary": "IBC operations",
                "responses": {
                    "200": {
                        "description": ""
                    }
                }
            }
        }
    },
    "definitions": {
        "CodeIdContracts": {
            "type": "object",
            "properties": {
                "height": {
                    "type": "string"
                },
                "result": {
                    "type": "array",
                    "items": {
                        "type": "object",
                        "properties": {
                            "code-id": {
                                "type": "number"
                            },
                            "creator": {
                                "type": "string"
                            },
                            "label": {
                                "type": "string"
                            },
                            "address": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        },
        "IoExchPubkeyResponse": {
            "type": "object",
            "properties": {
                "height": {
                    "type": "string"
                },
                "result": {
                    "type": "object",
                    "properties": {
                        "ioExchPubkey": {
                            "type": "string"
                        }
                    }
                }
            }
        },
        "ListContractSingle": {
            "type": "object",
            "properties": {
                "code-id": {
                    "type": "number"
                },
                "creator": {
                    "type": "string"
                },
                "label": {
                    "type": "string"
                },
                "address": {
                    "type": "string"
                }
            }
        },
        "ListCodeReponse": {
            "type": "object",
            "properties": {
                "height": {
                    "type": "string"
                },
                "result": {
                    "type": "array",
                    "items": {
                        "type": "object",
                        "properties": {
                            "id": {
                                "type": "number"
                            },
                            "creator": {
                                "type": "string"
                            },
                            "data_hash": {
                                "type": "string"
                            },
                            "source": {
                                "type": "string"
                            },
                            "builder": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        },
        "ListCodeSingle": {
            "type": "object",
            "properties": {
                "id": {
                    "type": "number"
                },
                "creator": {
                    "type": "string"
                },
                "data_hash": {
                    "type": "string"
                },
                "source": {
                    "type": "string"
                },
                "builder": {
                    "type": "string"
                }
            }
        },
        "CodeHash": {
            "type": "object",
            "properties": {
                "height": {
                    "type": "string"
                },
                "result": {
                    "type": "string"
                }
            }
        },
        "CodeInfo": {
            "type": "object",
            "properties": {
                "code_hash": {
                    "type": "string"
                },
                "creator": {
                    "type": "string"
                }
            }
        },
        "StoreCodeReq": {
            "type": "object",
            "properties": {
                "base_req": {
                    "type": "object",
                    "properties": {
                        "from": {
                            "description": "Sender address or Keybase name to generate a transaction",
                            "type": "string",
                            "example": "cosmos1g9ahr6xhht5rmqven628nklxluzyv8z9jqjcmc"
                        },
                        "memo": {
                            "type": "string",
                            "example": "Sent via Cosmos Voyager ðŸš€"
                        },
                        "chain_id": {
                            "type": "string",
                            "example": "Cosmos-Hub"
                        },
                        "account_number": {
                            "type": "string",
                            "example": "0"
                        },
                        "sequence": {
                            "type": "string",
                            "example": "1"
                        },
                        "gas": {
                            "type": "string",
                            "example": "200000"
                        },
                        "gas_adjustment": {
                            "type": "string",
                            "example": "1.2"
                        },
                        "fees": {
                            "type": "array",
                            "items": {
                                "type": "object",
                                "properties": {
                                    "denom": {
                                        "type": "string",
                                        "example": "stake"
                                    },
                                    "amount": {
                                        "type": "string",
                                        "example": "50"
                                    }
                                }
                            }
                        },
                        "simulate": {
                            "description": "Estimate gas for a transaction (cannot be used in conjunction with generate_only)",
                            "type": "boolean",
                            "example": false
                        }
                    }
                },
                "wasm_bytes": {
                    "type": "string",
                    "example": "Avz04VhtKJh8ACCVzlI8aTosGy0ikFXKIVHQ3jKMrosH"
                }
            }
        },
        "InstantiateContractReq": {
            "type": "object",
            "properties": {
                "base_req": {
                    "type": "object",
                    "properties": {
                        "from": {
                            "description": "Sender address or Keybase name to generate a transaction",
                            "type": "string",
                            "example": "cosmos1g9ahr6xhht5rmqven628nklxluzyv8z9jqjcmc"
                        },
                        "memo": {
                            "type": "string",
                            "example": "Sent via Cosmos Voyager ðŸš€"
                        },
                        "chain_id": {
                            "type": "string",
                            "example": "Cosmos-Hub"
                        },
                        "account_number": {
                            "type": "string",
                            "example": "0"
                        },
                        "sequence": {
                            "type": "string",
                            "example": "1"
                        },
                        "gas": {
                            "type": "string",
                            "example": "200000"
                        },
                        "gas_adjustment": {
                            "type": "string",
                            "example": "1.2"
                        },
                        "fees": {
                            "type": "array",
                            "items": {
                                "type": "object",
                                "properties": {
                                    "denom": {
                                        "type": "string",
                                        "example": "stake"
                                    },
                                    "amount": {
                                        "type": "string",
                                        "example": "50"
                                    }
                                }
                            }
                        },
                        "simulate": {
                            "description": "Estimate gas for a transaction (cannot be used in conjunction with generate_only)",
                            "type": "boolean",
                            "example": false
                        }
                    }
                },
                "init_coins": {
                    "type": "array",
                    "items": {
                        "type": "object",
                        "properties": {
                            "denom": {
                                "type": "string",
                                "example": "stake"
                            },
                            "amount": {
                                "type": "string",
                                "example": "50"
                            }
                        }
                    }
                },
                "init_msg": {
                    "description": "json formatted string",
                    "type": "string",
                    "example": "{}"
                }
            }
        },
        "ExecuteContractReq": {
            "type": "object",
            "properties": {
                "base_req": {
                    "type": "object",
                    "properties": {
                        "from": {
                            "description": "Sender address or Keybase name to generate a transaction",
                            "type": "string",
                            "example": "cosmos1g9ahr6xhht5rmqven628nklxluzyv8z9jqjcmc"
                        },
                        "memo": {
                            "type": "string",
                            "example": "Sent via Cosmos Voyager ðŸš€"
                        },
                        "chain_id": {
                            "type": "string",
                            "example": "Cosmos-Hub"
                        },
                        "account_number": {
                            "type": "string",
                            "example": "0"
                        },
                        "sequence": {
                            "type": "string",
                            "example": "1"
                        },
                        "gas": {
                            "type": "string",
                            "example": "200000"
                        },
                        "gas_adjustment": {
                            "type": "string",
                            "example": "1.2"
                        },
                        "fees": {
                            "type": "array",
                            "items": {
                                "type": "object",
                                "properties": {
                                    "denom": {
                                        "type": "string",
                                        "example": "stake"
                                    },
                                    "amount": {
                                        "type": "string",
                                        "example": "50"
                                    }
                                }
                            }
                        },
                        "simulate": {
                            "description": "Estimate gas for a transaction (cannot be used in conjunction with generate_only)",
                            "type": "boolean",
                            "example": false
                        }
                    }
                },
                "coins": {
                    "type": "array",
                    "items": {
                        "type": "object",
                        "properties": {
                            "denom": {
                                "type": "string",
                                "example": "stake"
                            },
                            "amount": {
                                "type": "string",
                                "example": "50"
                            }
                        }
                    }
                },
                "exec_msg": {
                    "type": "string",
                    "example": "{}"
                }
            }
        },
        "CheckTxResult": {
            "type": "object",
            "properties": {
                "code": {
                    "type": "integer"
                },
                "data": {
                    "type": "string"
                },
                "gas_used": {
                    "type": "integer"
                },
                "gas_wanted": {
                    "type": "integer"
                },
                "info": {
                    "type": "string"
                },
                "log": {
                    "type": "string"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "object",
                        "properties": {
                            "key": {
                                "type": "string"
                            },
                            "value": {
                                "type": "string"
                            }
                        }
                    }
                }
            },
            "example": {
                "code": 0,
                "data": "data",
                "log": "log",
                "gas_used": 5000,
                "gas_wanted": 10000,
                "info": "info",
                "tags": [
                    "",
                    ""
                ]
            }
        },
        "DeliverTxResult": {
            "type": "object",
            "properties": {
                "code": {
                    "type": "integer"
                },
                "data": {
                    "type": "string"
                },
                "gas_used": {
                    "type": "integer"
                },
                "gas_wanted": {
                    "type": "integer"
                },
                "info": {
                    "type": "string"
                },
                "log": {
                    "type": "string"
                },
                "tags": {
                    "type": "array",
                    "items": {
                        "type": "object",
                        "properties": {
                            "key": {
                                "type": "string"
                            },
                            "value": {
                                "type": "string"
                            }
                        }
                    }
                }
            },
            "example": {
                "code": 5,
                "data": "data",
                "log": "log",
                "gas_used": 5000,
                "gas_wanted": 10000,
                "info": "info",
                "tags": [
                    "",
                    ""
                ]
            }
        },
        "BroadcastTxCommitResult": {
            "type": "object",
            "properties": {
                "check_tx": {
                    "type": "object",
                    "properties": {
                        "code": {
                            "type": "integer"
                        },
                        "data": {
                            "type": "string"
                        },
                        "gas_used": {
                            "type": "integer"
                        },
                        "gas_wanted": {
                            "type": "integer"
                        },
                        "info": {
                            "type": "string"
                        },
                        "log": {
                            "type": "string"
                        },
                        "tags": {
                            "type": "array",
                            "items": {
                                "type": "object",
                                "properties": {
                                    "key": {
                                        "type": "string"
                                    },
                                    "value": {
                                        "type": "string"
                                    }
                                }
                            }
                        }
                    },
                    "example": {
                        "code": 0,
                        "data": "data",
                        "log": "log",
                        "gas_used": 5000,
                        "gas_wanted": 10000,
                        "info": "info",
                        "tags": [
                            "",
                            ""
                        ]
                    }
                },
                "deliver_tx": {
                    "type": "object",
                    "properties": {
                        "code": {
                            "type": "integer"
                        },
                        "data": {
                            "type": "string"
                        },
                        "gas_used": {
                            "type": "integer"
                        },
                        "gas_wanted": {
                            "type": "integer"
                        },
                        "info": {
                            "type": "string"
                        },
                        "log": {
                            "type": "string"
                        },
                        "tags": {
                            "type": "array",
                            "items": {
                                "type": "object",
                                "properties": {
                                    "key": {
                                        "type": "string"
                                    },
                                    "value": {
                                        "type": "string"
                                    }
                                }
                            }
                        }
                    },
                    "example": {
                        "code": 5,
                        "data": "data",
                        "log": "log",
                        "gas_used": 5000,
                        "gas_wanted": 10000,
                        "info": "info",
                        "tags": [
                            "",
                            ""
                        ]
                    }
                },
                "hash": {
                    "type": "string",
                    "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                },
                "height": {
                    "type": "integer"
                }
            }
        },
        "KVPair": {
            "type": "object",
            "properties": {
                "key": {
                    "type": "string"
                },
                "value": {
                    "type": "string"
                }
            }
        },
        "Msg": {
            "type": "string"
        },
        "Address": {
            "description": "bech32 encoded address",
            "type": "string",
            "example": "cosmos1depk54cuajgkzea6zpgkq36tnjwdzv4afc3d27"
        },
        "ValidatorAddress": {
            "description": "bech32 encoded address",
            "type": "string",
            "example": "cosmosvaloper16xyempempp92x9hyzz9wrgf94r6j9h5f2w4n2l"
        },
        "Coin": {
            "type": "object",
            "properties": {
                "denom": {
                    "type": "string",
                    "example": "stake"
                },
                "amount": {
                    "type": "string",
                    "example": "50"
                }
            }
        },
        "Hash": {
            "type": "string",
            "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
        },
        "TxQuery": {
            "type": "object",
            "properties": {
                "hash": {
                    "type": "string",
                    "example": "D085138D913993919295FF4B0A9107F1F2CDE0D37A87CE0644E217CBF3B49656"
                },
                "height": {
                    "type": "number",
                    "example": 368
                },
                "tx": {
                    "type": "object",
                    "properties": {
                        "msg": {
                            "type": "array",
                            "items": {
                                "type": "string"
                            }
                        },
                        "fee": {
                            "type": "object",
                            "properties": {
                                "gas": {
                                    "type": "string"
                                },
                                "amount": {
                                    "type": "array",
                                    "items": {
                                        "type": "object",
                                        "properties": {
                                            "denom": {
                                                "type": "string",
                                                "example": "stake"
                                            },
                                            "amount": {
                                                "type": "string",
                                                "example": "50"
                                            }
                                        }
                                    }
                                }
                            }
                        },
                        "memo": {
                            "type": "string"
                        },
                        "signature": {
                            "type": "object",
                            "properties": {
                                "signature": {
                                    "type": "string",
                                    "example": "MEUCIQD02fsDPra8MtbRsyB1w7bqTM55Wu138zQbFcWx4+CFyAIge5WNPfKIuvzBZ69MyqHsqD8S1IwiEp+iUb6VSdtlpgY="
                                },
                                "pub_key": {
                                    "type": "object",
                                    "properties": {
                                        "type": {
                                            "type": "string",
                                            "example": "tendermint/PubKeySecp256k1"
                                        },
                                        "value": {
                                            "type": "string",
                                            "example": "Avz04VhtKJh8ACCVzlI8aTosGy0ikFXKIVHQ3jKMrosH"
                                        }
                                    }
                                },
                                "account_number": {
                                    "type": "string",
                                    "example": "0"
                                },
                                "sequence": {
                                    "type": "string",
                                    "example": "0"
                                }
                            }
                        }
                    }
                },
                "result": {
                    "type": "object",
                    "properties": {
                        "log": {
                            "type": "string"
                        },
                        "gas_wanted": {
                            "type": "string",
                            "example": "200000"
                        },
                        "gas_used": {
                            "type": "string",
                            "example": "26354"
                        },
                        "tags": {
                            "type": "array",
                            "items": {
                                "type": "object",
                                "properties": {
                                    "key": {
                                        "type": "string"
                                    },
                                    "value": {
                                        "type": "string"
                                    }
                                }
                            }
                        }
                    }
                }
            }
        },
        "PaginatedQueryTxs": {
            "type": "object",
            "properties": {
                "total_count": {
                    "type": "number",
                    "example": 1
                },
                "count": {
                    "type": "number",
                    "example": 1
                },
                "page_number": {
                    "type": "number",
                    "example": 1
                },
                "page_total": {
                    "type": "number",
                    "example": 1
                },
                "limit": {
                    "type": "number",
                    "example": 30
                },
                "txs": {
                    "type": "array",
                    "items": {
                        "type": "object",
                        "properties": {
                            "hash": {
                                "type": "string",
                                "example": "D085138D913993919295FF4B0A9107F1F2CDE0D37A87CE0644E217CBF3B49656"
                            },
                            "height": {
                                "type": "number",
                                "example": 368
                            },
                            "tx": {
                                "type": "object",
                                "properties": {
                                    "msg": {
                                        "type": "array",
                                        "items": {
                                            "type": "string"
                                        }
                                    },
                                    "fee": {
                                        "type": "object",
                                        "properties": {
                                            "gas": {
                                                "type": "string"
                                            },
                                            "amount": {
                                                "type": "array",
                                                "items": {
                                                    "type": "object",
                                                    "properties": {
                                                        "denom": {
                                                            "type": "string",
                                                            "example": "stake"
                                                        },
                                                        "amount": {
                                                            "type": "string",
                                                            "example": "50"
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    },
                                    "memo": {
                                        "type": "string"
                                    },
                                    "signature": {
                                        "type": "object",
                                        "properties": {
                                            "signature": {
                                                "type": "string",
                                                "example": "MEUCIQD02fsDPra8MtbRsyB1w7bqTM55Wu138zQbFcWx4+CFyAIge5WNPfKIuvzBZ69MyqHsqD8S1IwiEp+iUb6VSdtlpgY="
                                            },
                                            "pub_key": {
                                                "type": "object",
                                                "properties": {
                                                    "type": {
                                                        "type": "string",
                                                        "example": "tendermint/PubKeySecp256k1"
                                                    },
                                                    "value": {
                                                        "type": "string",
                                                        "example": "Avz04VhtKJh8ACCVzlI8aTosGy0ikFXKIVHQ3jKMrosH"
                                                    }
                                                }
                                            },
                                            "account_number": {
                                                "type": "string",
                                                "example": "0"
                                            },
                                            "sequence": {
                                                "type": "string",
                                                "example": "0"
                                            }
                                        }
                                    }
                                }
                            },
                            "result": {
                                "type": "object",
                                "properties": {
                                    "log": {
                                        "type": "string"
                                    },
                                    "gas_wanted": {
                                        "type": "string",
                                        "example": "200000"
                                    },
                                    "gas_used": {
                                        "type": "string",
                                        "example": "26354"
                                    },
                                    "tags": {
                                        "type": "array",
                                        "items": {
                                            "type": "object",
                                            "properties": {
                                                "key": {
                                                    "type": "string"
                                                },
                                                "value": {
                                                    "type": "string"
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        },
        "StdTx": {
            "type": "object",
            "properties": {
                "msg": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "fee": {
                    "type": "object",
                    "properties": {
                        "gas": {
                            "type": "string"
                        },
                        "amount": {
                            "type": "array",
                            "items": {
                                "type": "object",
                                "properties": {
                                    "denom": {
                                        "type": "string",
                                        "example": "stake"
                                    },
                                    "amount": {
                                        "type": "string",
                                        "example": "50"
                                    }
                                }
                            }
                        }
                    }
                },
                "memo": {
                    "type": "string"
                },
                "signature": {
                    "type": "object",
                    "properties": {
                        "signature": {
                            "type": "string",
                            "example": "MEUCIQD02fsDPra8MtbRsyB1w7bqTM55Wu138zQbFcWx4+CFyAIge5WNPfKIuvzBZ69MyqHsqD8S1IwiEp+iUb6VSdtlpgY="
                        },
                        "pub_key": {
                            "type": "object",
                            "properties": {
                                "type": {
                                    "type": "string",
                                    "example": "tendermint/PubKeySecp256k1"
                                },
                                "value": {
                                    "type": "string",
                                    "example": "Avz04VhtKJh8ACCVzlI8aTosGy0ikFXKIVHQ3jKMrosH"
                                }
                            }
                        },
                        "account_number": {
                            "type": "string",
                            "example": "0"
                        },
                        "sequence": {
                            "type": "string",
                            "example": "0"
                        }
                    }
                }
            }
        },
        "BlockID": {
            "type": "object",
            "properties": {
                "hash": {
                    "type": "string",
                    "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                },
                "parts": {
                    "type": "object",
                    "properties": {
                        "total": {
                            "type": "number",
                            "example": 0
                        },
                        "hash": {
                            "type": "string",
                            "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                        }
                    }
                }
            }
        },
        "BlockHeader": {
            "type": "object",
            "properties": {
                "chain_id": {
                    "type": "string",
                    "example": "cosmoshub-2"
                },
                "height": {
                    "type": "number",
                    "example": 1
                },
                "time": {
                    "type": "string",
                    "example": "2017-12-30T04:53:09.287Z"
                },
                "num_txs": {
                    "type": "number",
                    "example": 0
                },
                "last_block_id": {
                    "type": "object",
                    "properties": {
                        "hash": {
                            "type": "string",
                            "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                        },
                        "parts": {
                            "type": "object",
                            "properties": {
                                "total": {
                                    "type": "number",
                                    "example": 0
                                },
                                "hash": {
                                    "type": "string",
                                    "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                                }
                            }
                        }
                    }
                },
                "total_txs": {
                    "type": "number",
                    "example": 35
                },
                "last_commit_hash": {
                    "type": "string",
                    "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                },
                "data_hash": {
                    "type": "string",
                    "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                },
                "validators_hash": {
                    "type": "string",
                    "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                },
                "next_validators_hash": {
                    "type": "string",
                    "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                },
                "consensus_hash": {
                    "type": "string",
                    "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                },
                "app_hash": {
                    "type": "string",
                    "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                },
                "last_results_hash": {
                    "type": "string",
                    "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                },
                "evidence_hash": {
                    "type": "string",
                    "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                },
                "proposer_address": {
                    "description": "bech32 encoded address",
                    "type": "string",
                    "example": "cosmos1depk54cuajgkzea6zpgkq36tnjwdzv4afc3d27"
                },
                "version": {
                    "type": "object",
                    "properties": {
                        "block": {
                            "type": "string",
                            "example": "10"
                        },
                        "app": {
                            "type": "string",
                            "example": "0"
                        }
                    }
                }
            }
        },
        "Block": {
            "type": "object",
            "properties": {
                "header": {
                    "type": "object",
                    "properties": {
                        "chain_id": {
                            "type": "string",
                            "example": "cosmoshub-2"
                        },
                        "height": {
                            "type": "number",
                            "example": 1
                        },
                        "time": {
                            "type": "string",
                            "example": "2017-12-30T04:53:09.287Z"
                        },
                        "num_txs": {
                            "type": "number",
                            "example": 0
                        },
                        "last_block_id": {
                            "type": "object",
                            "properties": {
                                "hash": {
                                    "type": "string",
                                    "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                                },
                                "parts": {
                                    "type": "object",
                                    "properties": {
                                        "total": {
                                            "type": "number",
                                            "example": 0
                                        },
                                        "hash": {
                                            "type": "string",
                                            "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                                        }
                                    }
                                }
                            }
                        },
                        "total_txs": {
                            "type": "number",
                            "example": 35
                        },
                        "last_commit_hash": {
                            "type": "string",
                            "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                        },
                        "data_hash": {
                            "type": "string",
                            "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                        },
                        "validators_hash": {
                            "type": "string",
                            "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                        },
                        "next_validators_hash": {
                            "type": "string",
                            "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                        },
                        "consensus_hash": {
                            "type": "string",
                            "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                        },
                        "app_hash": {
                            "type": "string",
                            "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                        },
                        "last_results_hash": {
                            "type": "string",
                            "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                        },
                        "evidence_hash": {
                            "type": "string",
                            "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                        },
                        "proposer_address": {
                            "description": "bech32 encoded address",
                            "type": "string",
                            "example": "cosmos1depk54cuajgkzea6zpgkq36tnjwdzv4afc3d27"
                        },
                        "version": {
                            "type": "object",
                            "properties": {
                                "block": {
                                    "type": "string",
                                    "example": "10"
                                },
                                "app": {
                                    "type": "string",
                                    "example": "0"
                                }
                            }
                        }
                    }
                },
                "txs": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "evidence": {
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "last_commit": {
                    "type": "object",
                    "properties": {
                        "block_id": {
                            "type": "object",
                            "properties": {
                                "hash": {
                                    "type": "string",
                                    "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                                },
                                "parts": {
                                    "type": "object",
                                    "properties": {
                                        "total": {
                                            "type": "number",
                                            "example": 0
                                        },
                                        "hash": {
                                            "type": "string",
                                            "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                                        }
                                    }
                                }
                            }
                        },
                        "precommits": {
                            "type": "array",
                            "items": {
                                "type": "object",
                                "properties": {
                                    "validator_address": {
                                        "type": "string"
                                    },
                                    "validator_index": {
                                        "type": "string",
                                        "example": "0"
                                    },
                                    "height": {
                                        "type": "string",
                                        "example": "0"
                                    },
                                    "round": {
                                        "type": "string",
                                        "example": "0"
                                    },
                                    "timestamp": {
                                        "type": "string",
                                        "example": "2017-12-30T04:53:09.287Z"
                                    },
                                    "type": {
                                        "type": "number",
                                        "example": 2
                                    },
                                    "block_id": {
                                        "type": "object",
                                        "properties": {
                                            "hash": {
                                                "type": "string",
                                                "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                                            },
                                            "parts": {
                                                "type": "object",
                                                "properties": {
                                                    "total": {
                                                        "type": "number",
                                                        "example": 0
                                                    },
                                                    "hash": {
                                                        "type": "string",
                                                        "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                                                    }
                                                }
                                            }
                                        }
                                    },
                                    "signature": {
                                        "type": "string",
                                        "example": "7uTC74QlknqYWEwg7Vn6M8Om7FuZ0EO4bjvuj6rwH1mTUJrRuMMZvAAqT9VjNgP0RA/TDp6u/92AqrZfXJSpBQ=="
                                    }
                                }
                            }
                        }
                    }
                }
            }
        },
        "BlockQuery": {
            "type": "object",
            "properties": {
                "block_meta": {
                    "type": "object",
                    "properties": {
                        "header": {
                            "type": "object",
                            "properties": {
                                "chain_id": {
                                    "type": "string",
                                    "example": "cosmoshub-2"
                                },
                                "height": {
                                    "type": "number",
                                    "example": 1
                                },
                                "time": {
                                    "type": "string",
                                    "example": "2017-12-30T04:53:09.287Z"
                                },
                                "num_txs": {
                                    "type": "number",
                                    "example": 0
                                },
                                "last_block_id": {
                                    "type": "object",
                                    "properties": {
                                        "hash": {
                                            "type": "string",
                                            "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                                        },
                                        "parts": {
                                            "type": "object",
                                            "properties": {
                                                "total": {
                                                    "type": "number",
                                                    "example": 0
                                                },
                                                "hash": {
                                                    "type": "string",
                                                    "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                                                }
                                            }
                                        }
                                    }
                                },
                                "total_txs": {
                                    "type": "number",
                                    "example": 35
                                },
                                "last_commit_hash": {
                                    "type": "string",
                                    "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                                },
                                "data_hash": {
                                    "type": "string",
                                    "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                                },
                                "validators_hash": {
                                    "type": "string",
                                    "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                                },
                                "next_validators_hash": {
                                    "type": "string",
                                    "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                                },
                                "consensus_hash": {
                                    "type": "string",
                                    "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                                },
                                "app_hash": {
                                    "type": "string",
                                    "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                                },
                                "last_results_hash": {
                                    "type": "string",
                                    "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                                },
                                "evidence_hash": {
                                    "type": "string",
                                    "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                                },
                                "proposer_address": {
                                    "description": "bech32 encoded address",
                                    "type": "string",
                                    "example": "cosmos1depk54cuajgkzea6zpgkq36tnjwdzv4afc3d27"
                                },
                                "version": {
                                    "type": "object",
                                    "properties": {
                                        "block": {
                                            "type": "string",
                                            "example": "10"
                                        },
                                        "app": {
                                            "type": "string",
                                            "example": "0"
                                        }
                                    }
                                }
                            }
                        },
                        "block_id": {
                            "type": "object",
                            "properties": {
                                "hash": {
                                    "type": "string",
                                    "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                                },
                                "parts": {
                                    "type": "object",
                                    "properties": {
                                        "total": {
                                            "type": "number",
                                            "example": 0
                                        },
                                        "hash": {
                                            "type": "string",
                                            "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                                        }
                                    }
                                }
                            }
                        }
                    }
                },
                "block": {
                    "type": "object",
                    "properties": {
                        "header": {
                            "type": "object",
                            "properties": {
                                "chain_id": {
                                    "type": "string",
                                    "example": "cosmoshub-2"
                                },
                                "height": {
                                    "type": "number",
                                    "example": 1
                                },
                                "time": {
                                    "type": "string",
                                    "example": "2017-12-30T04:53:09.287Z"
                                },
                                "num_txs": {
                                    "type": "number",
                                    "example": 0
                                },
                                "last_block_id": {
                                    "type": "object",
                                    "properties": {
                                        "hash": {
                                            "type": "string",
                                            "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                                        },
                                        "parts": {
                                            "type": "object",
                                            "properties": {
                                                "total": {
                                                    "type": "number",
                                                    "example": 0
                                                },
                                                "hash": {
                                                    "type": "string",
                                                    "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                                                }
                                            }
                                        }
                                    }
                                },
                                "total_txs": {
                                    "type": "number",
                                    "example": 35
                                },
                                "last_commit_hash": {
                                    "type": "string",
                                    "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                                },
                                "data_hash": {
                                    "type": "string",
                                    "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                                },
                                "validators_hash": {
                                    "type": "string",
                                    "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                                },
                                "next_validators_hash": {
                                    "type": "string",
                                    "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                                },
                                "consensus_hash": {
                                    "type": "string",
                                    "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                                },
                                "app_hash": {
                                    "type": "string",
                                    "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                                },
                                "last_results_hash": {
                                    "type": "string",
                                    "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                                },
                                "evidence_hash": {
                                    "type": "string",
                                    "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                                },
                                "proposer_address": {
                                    "description": "bech32 encoded address",
                                    "type": "string",
                                    "example": "cosmos1depk54cuajgkzea6zpgkq36tnjwdzv4afc3d27"
                                },
                                "version": {
                                    "type": "object",
                                    "properties": {
                                        "block": {
                                            "type": "string",
                                            "example": "10"
                                        },
                                        "app": {
                                            "type": "string",
                                            "example": "0"
                                        }
                                    }
                                }
                            }
                        },
                        "txs": {
                            "type": "array",
                            "items": {
                                "type": "string"
                            }
                        },
                        "evidence": {
                            "type": "array",
                            "items": {
                                "type": "string"
                            }
                        },
                        "last_commit": {
                            "type": "object",
                            "properties": {
                                "block_id": {
                                    "type": "object",
                                    "properties": {
                                        "hash": {
                                            "type": "string",
                                            "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                                        },
                                        "parts": {
                                            "type": "object",
                                            "properties": {
                                                "total": {
                                                    "type": "number",
                                                    "example": 0
                                                },
                                                "hash": {
                                                    "type": "string",
                                                    "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                                                }
                                            }
                                        }
                                    }
                                },
                                "precommits": {
                                    "type": "array",
                                    "items": {
                                        "type": "object",
                                        "properties": {
                                            "validator_address": {
                                                "type": "string"
                                            },
                                            "validator_index": {
                                                "type": "string",
                                                "example": "0"
                                            },
                                            "height": {
                                                "type": "string",
                                                "example": "0"
                                            },
                                            "round": {
                                                "type": "string",
                                                "example": "0"
                                            },
                                            "timestamp": {
                                                "type": "string",
                                                "example": "2017-12-30T04:53:09.287Z"
                                            },
                                            "type": {
                                                "type": "number",
                                                "example": 2
                                            },
                                            "block_id": {
                                                "type": "object",
                                                "properties": {
                                                    "hash": {
                                                        "type": "string",
                                                        "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                                                    },
                                                    "parts": {
                                                        "type": "object",
                                                        "properties": {
                                                            "total": {
                                                                "type": "number",
                                                                "example": 0
                                                            },
                                                            "hash": {
                                                                "type": "string",
                                                                "example": "EE5F3404034C524501629B56E0DDC38FAD651F04"
                                                            }
                                                        }
                                                    }
                                                }
                                            },
                                            "signature": {
                                                "type": "string",
                                                "example": "7uTC74QlknqYWEwg7Vn6M8Om7FuZ0EO4bjvuj6rwH1mTUJrRuMMZvAAqT9VjNgP0RA/TDp6u/92AqrZfXJSpBQ=="
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        },
        "DelegationDelegatorReward": {
            "type": "object",
            "properties": {
                "validator_address": {
                    "description": "bech32 encoded address",
                    "type": "string",
                    "example": "cosmosvaloper16xyempempp92x9hyzz9wrgf94r6j9h5f2w4n2l"
                },
                "reward": {
                    "type": "array",
                    "items": {
                        "type": "object",
                        "properties": {
                            "denom": {
                                "type": "string",
                                "example": "stake"
                            },
                            "amount": {
                                "type": "string",
                                "example": "50"
                            }
                        }
                    }
                }
            }
        },
        "DelegatorTotalRewards": {
            "type": "object",
            "properties": {
                "rewards": {
                    "type": "array",
                    "items": {
                        "type": "object",
                        "properties": {
                            "validator_address": {
                                "description": "bech32 encoded address",
                                "type": "string",
                                "example": "cosmosvaloper16xyempempp92x9hyzz9wrgf94r6j9h5f2w4n2l"
                            },
                            "reward": {
                                "type": "array",
                                "items": {
                                    "type": "object",
                                    "properties": {
                                        "denom": {
                                            "type": "string",
                                            "example": "stake"
                                        },
                                        "amount": {
                                            "type": "string",
                                            "example": "50"
                                        }
                                    }
                                }
                            }
                        }
                    }
                },
                "total": {
                    "type": "array",
                    "items": {
                        "type": "object",
                        "properties": {
                            "denom": {
                                "type": "string",
                                "example": "stake"
                            },
                            "amount": {
                                "type": "string",
                                "example": "50"
                            }
                        }
                    }
                }
            }
        },
        "BaseReq": {
            "type": "object",
            "properties": {
                "from": {
                    "description": "Sender address or Keybase name to generate a transaction",
                    "type": "string",
                    "example": "cosmos1g9ahr6xhht5rmqven628nklxluzyv8z9jqjcmc"
                },
                "memo": {
                    "type": "string",
                    "example": "Sent via Cosmos Voyager ðŸš€"
                },
                "chain_id": {
                    "type": "string",
                    "example": "Cosmos-Hub"
                },
                "account_number": {
                    "type": "string",
                    "example": "0"
                },
                "sequence": {
                    "type": "string",
                    "example": "1"
                },
                "gas": {
                    "type": "string",
                    "example": "200000"
                },
                "gas_adjustment": {
                    "type": "string",
                    "example": "1.2"
                },
                "fees": {
                    "type": "array",
                    "items": {
                        "type": "object",
                        "properties": {
                            "denom": {
                                "type": "string",
                                "example": "stake"
                            },
                            "amount": {
                                "type": "string",
                                "example": "50"
                            }
                        }
                    }
                },
                "simulate": {
                    "description": "Estimate gas for a transaction (cannot be used in conjunction with generate_only)",
                    "type": "boolean",
                    "example": false
                }
            }
        },
        "TendermintValidator": {
            "type": "object",
            "properties": {
                "address": {
                    "description": "bech32 encoded address",
                    "type": "string",
                    "example": "cosmosvaloper16xyempempp92x9hyzz9wrgf94r6j9h5f2w4n2l"
                },
                "pub_key": {
                    "type": "string",
                    "example": "cosmosvalconspub1zcjduepq0vu2zgkgk49efa0nqwzndanq5m4c7pa3u4apz4g2r9gspqg6g9cs3k9cuf"
                },
                "voting_power": {
                    "type": "string",
                    "example": "1000"
                },
                "proposer_priority": {
                    "type": "string",
                    "example": "1000"
                }
            }
        },
        "TextProposal": {
            "type": "object",
            "properties": {
                "proposal_id": {
                    "type": "integer"
                },
                "title": {
                    "type": "string"
                },
                "description": {
                    "type": "string"
                },
                "proposal_type": {
                    "type": "string"
                },
                "proposal_status": {
                    "type": "string"
                },
                "final_tally_result": {
                    "type": "object",
                    "properties": {
                        "yes": {
                            "type": "string",
                            "example": "0.0000000000"
                        },
                        "abstain": {
                            "type": "string",
                            "example": "0.0000000000"
                        },
                        "no": {
                            "type": "string",
                            "example": "0.0000000000"
                        },
                        "no_with_veto": {
                            "type": "string",
                            "example": "0.0000000000"
                        }
                    }
                },
                "submit_time": {
                    "type": "string"
                },
                "total_deposit": {
                    "type": "array",
                    "items": {
                        "type": "object",
                        "properties": {
                            "denom": {
                                "type": "string",
                                "example": "stake"
                            },
                            "amount": {
                                "type": "string",
                                "example": "50"
                            }
                        }
                    }
                },
                "voting_start_time": {
                    "type": "string"
                }
            }
        },
        "Proposer": {
            "type": "object",
            "properties": {
                "proposal_id": {
                    "type": "string"
                },
                "proposer": {
                    "type": "string"
                }
            }
        },
        "Deposit": {
            "type": "object",
            "properties": {
                "amount": {
                    "type": "array",
                    "items": {
                        "type": "object",
                        "properties": {
                            "denom": {
                                "type": "string",
                                "example": "stake"
                            },
                            "amount": {
                                "type": "string",
                                "example": "50"
                            }
                        }
                    }
                },
                "proposal_id": {
                    "type": "string"
                },
                "depositor": {
                    "description": "bech32 encoded address",
                    "type": "string",
                    "example": "cosmos1depk54cuajgkzea6zpgkq36tnjwdzv4afc3d27"
                }
            }
        },
        "TallyResult": {
            "type": "object",
            "properties": {
                "yes": {
                    "type": "string",
                    "example": "0.0000000000"
                },
                "abstain": {
                    "type": "string",
                    "example": "0.0000000000"
                },
                "no": {
                    "type": "string",
                    "example": "0.0000000000"
                },
                "no_with_veto": {
                    "type": "string",
                    "example": "0.0000000000"
                }
            }
        },
        "Vote": {
            "type": "object",
            "properties": {
                "voter": {
                    "type": "string"
                },
                "proposal_id": {
                    "type": "string"
                },
                "option": {
                    "type": "string"
                }
            }
        },
        "Validator": {
            "type": "object",
            "properties": {
                "operator_address": {
                    "description": "bech32 encoded address",
                    "type": "string",
                    "example": "cosmosvaloper16xyempempp92x9hyzz9wrgf94r6j9h5f2w4n2l"
                },
                "consensus_pubkey": {
                    "type": "string",
                    "example": "cosmosvalconspub1zcjduepq0vu2zgkgk49efa0nqwzndanq5m4c7pa3u4apz4g2r9gspqg6g9cs3k9cuf"
                },
                "jailed": {
                    "type": "boolean"
                },
                "status": {
                    "type": "integer"
                },
                "tokens": {
                    "type": "string"
                },
                "delegator_shares": {
                    "type": "string"
                },
                "description": {
                    "type": "object",
                    "properties": {
                        "moniker": {
                            "type": "string"
                        },
                        "identity": {
                            "type": "string"
                        },
                        "website": {
                            "type": "string"
                        },
                        "security_contact": {
                            "type": "string"
                        },
                        "details": {
                            "type": "string"
                        }
                    }
                },
                "bond_height": {
                    "type": "string",
                    "example": "0"
                },
                "bond_intra_tx_counter": {
                    "type": "integer",
                    "example": 0
                },
                "unbonding_height": {
                    "type": "string",
                    "example": "0"
                },
                "unbonding_time": {
                    "type": "string",
                    "example": "1970-01-01T00:00:00Z"
                },
                "commission": {
                    "type": "object",
                    "properties": {
                        "rate": {
                            "type": "string",
                            "example": "0"
                        },
                        "max_rate": {
                            "type": "string",
                            "example": "0"
                        },
                        "max_change_rate": {
                            "type": "string",
                            "example": "0"
                        },
                        "update_time": {
                            "type": "string",
                            "example": "1970-01-01T00:00:00Z"
                        }
                    }
                }
            }
        },
        "Delegation": {
            "type": "object",
            "properties": {
                "delegator_address": {
                    "type": "string"
                },
                "validator_address": {
                    "type": "string"
                },
                "shares": {
                    "type": "string"
                },
                "balance": {
                    "type": "object",
                    "properties": {
                        "denom": {
                            "type": "string",
                            "example": "stake"
                        },
                        "amount": {
                            "type": "string",
                            "example": "50"
                        }
                    }
                }
            }
        },
        "UnbondingDelegationPair": {
            "type": "object",
            "properties": {
                "delegator_address": {
                    "type": "string"
                },
                "validator_address": {
                    "type": "string"
                },
                "entries": {
                    "type": "array",
                    "items": {
                        "type": "object",
                        "properties": {
                            "initial_balance": {
                                "type": "string"
                            },
                            "balance": {
                                "type": "string"
                            },
                            "creation_height": {
                                "type": "string"
                            },
                            "min_time": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        },
        "UnbondingEntries": {
            "type": "object",
            "properties": {
                "initial_balance": {
                    "type": "string"
                },
                "balance": {
                    "type": "string"
                },
                "creation_height": {
                    "type": "string"
                },
                "min_time": {
                    "type": "string"
                }
            }
        },
        "UnbondingDelegation": {
            "type": "object",
            "properties": {
                "delegator_address": {
                    "type": "string"
                },
                "validator_address": {
                    "type": "string"
                },
                "initial_balance": {
                    "type": "string"
                },
                "balance": {
                    "type": "string"
                },
                "creation_height": {
                    "type": "integer"
                },
                "min_time": {
                    "type": "integer"
                }
            }
        },
        "Redelegation": {
            "type": "object",
            "properties": {
                "delegator_address": {
                    "type": "string"
                },
                "validator_src_address": {
                    "type": "string"
                },
                "validator_dst_address": {
                    "type": "string"
                },
                "entries": {
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/Redelegation"
                    }
                }
            }
        },
        "RedelegationEntry": {
            "type": "object",
            "properties": {
                "creation_height": {
                    "type": "integer"
                },
                "completion_time": {
                    "type": "integer"
                },
                "initial_balance": {
                    "type": "string"
                },
                "balance": {
                    "type": "string"
                },
                "shares_dst": {
                    "type": "string"
                }
            }
        },
        "ValidatorDistInfo": {
            "type": "object",
            "properties": {
                "operator_address": {
                    "description": "bech32 encoded address",
                    "type": "string",
                    "example": "cosmosvaloper16xyempempp92x9hyzz9wrgf94r6j9h5f2w4n2l"
                },
                "self_bond_rewards": {
                    "type": "array",
                    "items": {
                        "type": "object",
                        "properties": {
                            "denom": {
                                "type": "string",
                                "example": "stake"
                            },
                            "amount": {
                                "type": "string",
                                "example": "50"
                            }
                        }
                    }
                },
                "val_commission": {
                    "type": "array",
                    "items": {
                        "type": "object",
                        "properties": {
                            "denom": {
                                "type": "string",
                                "example": "stake"
                            },
                            "amount": {
                                "type": "string",
                                "example": "50"
                            }
                        }
                    }
                }
            }
        },
        "PublicKey": {
            "type": "object",
            "properties": {
                "type": {
                    "type": "string"
                },
                "value": {
                    "type": "string"
                }
            }
        },
        "SigningInfo": {
            "type": "object",
            "properties": {
                "start_height": {
                    "type": "string"
                },
                "index_offset": {
                    "type": "string"
                },
                "jailed_until": {
                    "type": "string"
                },
                "missed_blocks_counter": {
                    "type": "string"
                }
            }
        },
        "ParamChange": {
            "type": "object",
            "properties": {
                "subspace": {
                    "type": "string",
                    "example": "staking"
                },
                "key": {
                    "type": "string",
                    "example": "MaxValidators"
                },
                "subkey": {
                    "type": "string",
                    "example": ""
                },
                "value": {
                    "type": "object"
                }
            }
        },
        "Supply": {
            "type": "object",
            "properties": {
                "total": {
                    "type": "array",
                    "items": {
                        "type": "object",
                        "properties": {
                            "denom": {
                                "type": "string",
                                "example": "stake"
                            },
                            "amount": {
                                "type": "string",
                                "example": "50"
                            }
                        }
                    }
                }
            }
        },
        "cosmos.auth.v1beta1.Params": {
            "description": "Params defines the parameters for the auth module.",
            "type": "object",
            "properties": {
                "max_memo_characters": {
                    "format": "uint64",
                    "type": "string"
                },
                "tx_sig_limit": {
                    "format": "uint64",
                    "type": "string"
                },
                "tx_size_cost_per_byte": {
                    "format": "uint64",
                    "type": "string"
                },
                "sig_verify_cost_ed25519": {
                    "format": "uint64",
                    "type": "string"
                },
                "sig_verify_cost_secp256k1": {
                    "format": "uint64",
                    "type": "string"
                }
            }
        },
        "cosmos.auth.v1beta1.QueryAccountResponse": {
            "description": "QueryAccountResponse is the response type for the Query/Account RPC method.",
            "type": "object",
            "properties": {
                "account": {
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                    "type": "object",
                    "properties": {
                        "type_url": {
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                            "type": "string"
                        },
                        "value": {
                            "format": "byte",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string"
                        }
                    }
                }
            }
        },
        "cosmos.auth.v1beta1.QueryAccountsResponse": {
            "description": "QueryAccountsResponse is the response type for the Query/Accounts RPC method.",
            "type": "object",
            "properties": {
                "accounts": {
                    "title": "accounts are the existing accounts",
                    "type": "array",
                    "items": {
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                        "type": "object",
                        "properties": {
                            "type_url": {
                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                "type": "string"
                            },
                            "value": {
                                "format": "byte",
                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                "type": "string"
                            }
                        }
                    }
                },
                "pagination": {
                    "description": "pagination defines the pagination in the response.",
                    "type": "object",
                    "properties": {
                        "next_key": {
                            "format": "byte",
                            "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently",
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string"
                        },
                        "total": {
                            "format": "uint64",
                            "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                            "type": "string"
                        }
                    }
                }
            }
        },
        "cosmos.auth.v1beta1.QueryParamsResponse": {
            "description": "QueryParamsResponse is the response type for the Query/Params RPC method.",
            "type": "object",
            "properties": {
                "params": {
                    "description": "params defines the parameters of the module.",
                    "type": "object",
                    "properties": {
                        "max_memo_characters": {
                            "format": "uint64",
                            "type": "string"
                        },
                        "tx_sig_limit": {
                            "format": "uint64",
                            "type": "string"
                        },
                        "tx_size_cost_per_byte": {
                            "format": "uint64",
                            "type": "string"
                        },
                        "sig_verify_cost_ed25519": {
                            "format": "uint64",
                            "type": "string"
                        },
                        "sig_verify_cost_secp256k1": {
                            "format": "uint64",
                            "type": "string"
                        }
                    }
                }
            }
        },
        "cosmos.base.query.v1beta1.PageRequest": {
            "title": "PageRequest is to be embedded in gRPC request messages for efficient\npagination. Ex:",
            "description": "message SomeRequest {\n         Foo some_parameter = 1;\n         PageRequest pagination = 2;\n }",
            "type": "object",
            "properties": {
                "key": {
                    "format": "byte",
                    "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string"
                },
                "offset": {
                    "format": "uint64",
                    "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
                    "type": "string"
                },
                "limit": {
                    "format": "uint64",
                    "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
                    "type": "string"
                },
                "count_total": {
                    "format": "boolean",
                    "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
                    "type": "boolean"
                },
                "reverse": {
                    "format": "boolean",
                    "description": "reverse is set to true if results are to be returned in the descending order.",
                    "type": "boolean"
                }
            }
        },
        "cosmos.base.query.v1beta1.PageResponse": {
            "description": "PageResponse is to be embedded in gRPC response messages where the\ncorresponding request message has used PageRequest.\n\n message SomeResponse {\n         repeated Bar results = 1;\n         PageResponse page = 2;\n }",
            "type": "object",
            "properties": {
                "next_key": {
                    "format": "byte",
                    "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently",
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string"
                },
                "total": {
                    "format": "uint64",
                    "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                    "type": "string"
                }
            }
        },
        "google.protobuf.Any": {
            "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
            "type": "object",
            "properties": {
                "type_url": {
                    "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                    "type": "string"
                },
                "value": {
                    "format": "byte",
                    "description": "Must be a valid serialized protocol buffer of the above specified type.",
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string"
                }
            }
        },
        "grpc.gateway.runtime.Error": {
            "type": "object",
            "properties": {
                "error": {
                    "type": "string"
                },
                "code": {
                    "format": "int32",
                    "type": "integer"
                },
                "message": {
                    "type": "string"
                },
                "details": {
                    "type": "array",
                    "items": {
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                        "type": "object",
                        "properties": {
                            "type_url": {
                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                "type": "string"
                            },
                            "value": {
                                "format": "byte",
                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                "type": "string"
                            }
                        }
                    }
                }
            }
        },
        "cosmos.bank.v1beta1.DenomUnit": {
            "description": "DenomUnit represents a struct that describes a given\ndenomination unit of the basic token.",
            "type": "object",
            "properties": {
                "denom": {
                    "description": "denom represents the string name of the given denom unit (e.g uatom).",
                    "type": "string"
                },
                "exponent": {
                    "format": "int64",
                    "description": "exponent represents power of 10 exponent that one must\nraise the base_denom to in order to equal the given DenomUnit's denom\n1 denom = 1^exponent base_denom\n(e.g. with a base_denom of uatom, one can create a DenomUnit of 'atom' with\nexponent = 6, thus: 1 atom = 10^6 uatom).",
                    "type": "integer"
                },
                "aliases": {
                    "title": "aliases is a list of string aliases for the given denom",
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            }
        },
        "cosmos.bank.v1beta1.Metadata": {
            "description": "Metadata represents a struct that describes\na basic token.",
            "type": "object",
            "properties": {
                "description": {
                    "type": "string"
                },
                "denom_units": {
                    "title": "denom_units represents the list of DenomUnit's for a given coin",
                    "type": "array",
                    "items": {
                        "description": "DenomUnit represents a struct that describes a given\ndenomination unit of the basic token.",
                        "type": "object",
                        "properties": {
                            "denom": {
                                "description": "denom represents the string name of the given denom unit (e.g uatom).",
                                "type": "string"
                            },
                            "exponent": {
                                "format": "int64",
                                "description": "exponent represents power of 10 exponent that one must\nraise the base_denom to in order to equal the given DenomUnit's denom\n1 denom = 1^exponent base_denom\n(e.g. with a base_denom of uatom, one can create a DenomUnit of 'atom' with\nexponent = 6, thus: 1 atom = 10^6 uatom).",
                                "type": "integer"
                            },
                            "aliases": {
                                "title": "aliases is a list of string aliases for the given denom",
                                "type": "array",
                                "items": {
                                    "type": "string"
                                }
                            }
                        }
                    }
                },
                "base": {
                    "description": "base represents the base denom (should be the DenomUnit with exponent = 0).",
                    "type": "string"
                },
                "display": {
                    "description": "display indicates the suggested denom that should be\ndisplayed in clients.",
                    "type": "string"
                },
                "name": {
                    "title": "name defines the name of the token (eg: Cosmos Atom)",
                    "type": "string"
                },
                "symbol": {
                    "description": "symbol is the token symbol usually shown on exchanges (eg: ATOM). This can\nbe the same as the display.",
                    "type": "string"
                }
            }
        },
        "cosmos.bank.v1beta1.Params": {
            "description": "Params defines the parameters for the bank module.",
            "type": "object",
            "properties": {
                "send_enabled": {
                    "type": "array",
                    "items": {
                        "description": "SendEnabled maps coin denom to a send_enabled status (whether a denom is\nsendable).",
                        "type": "object",
                        "properties": {
                            "denom": {
                                "type": "string"
                            },
                            "enabled": {
                                "format": "boolean",
                                "type": "boolean"
                            }
                        }
                    }
                },
                "default_send_enabled": {
                    "format": "boolean",
                    "type": "boolean"
                }
            }
        },
        "cosmos.bank.v1beta1.QueryAllBalancesResponse": {
            "description": "QueryAllBalancesResponse is the response type for the Query/AllBalances RPC\nmethod.",
            "type": "object",
            "properties": {
                "balances": {
                    "description": "balances is the balances of all the coins.",
                    "type": "array",
                    "items": {
                        "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto.",
                        "type": "object",
                        "properties": {
                            "denom": {
                                "type": "string"
                            },
                            "amount": {
                                "type": "string"
                            }
                        }
                    }
                },
                "pagination": {
                    "description": "pagination defines the pagination in the response.",
                    "type": "object",
                    "properties": {
                        "next_key": {
                            "format": "byte",
                            "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently",
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string"
                        },
                        "total": {
                            "format": "uint64",
                            "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                            "type": "string"
                        }
                    }
                }
            }
        },
        "cosmos.bank.v1beta1.QueryBalanceResponse": {
            "description": "QueryBalanceResponse is the response type for the Query/Balance RPC method.",
            "type": "object",
            "properties": {
                "balance": {
                    "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto.",
                    "type": "object",
                    "properties": {
                        "denom": {
                            "type": "string"
                        },
                        "amount": {
                            "type": "string"
                        }
                    }
                }
            }
        },
        "cosmos.bank.v1beta1.QueryDenomMetadataResponse": {
            "description": "QueryDenomMetadataResponse is the response type for the Query/DenomMetadata RPC\nmethod.",
            "type": "object",
            "properties": {
                "metadata": {
                    "description": "Metadata represents a struct that describes\na basic token.",
                    "type": "object",
                    "properties": {
                        "description": {
                            "type": "string"
                        },
                        "denom_units": {
                            "title": "denom_units represents the list of DenomUnit's for a given coin",
                            "type": "array",
                            "items": {
                                "description": "DenomUnit represents a struct that describes a given\ndenomination unit of the basic token.",
                                "type": "object",
                                "properties": {
                                    "denom": {
                                        "description": "denom represents the string name of the given denom unit (e.g uatom).",
                                        "type": "string"
                                    },
                                    "exponent": {
                                        "format": "int64",
                                        "description": "exponent represents power of 10 exponent that one must\nraise the base_denom to in order to equal the given DenomUnit's denom\n1 denom = 1^exponent base_denom\n(e.g. with a base_denom of uatom, one can create a DenomUnit of 'atom' with\nexponent = 6, thus: 1 atom = 10^6 uatom).",
                                        "type": "integer"
                                    },
                                    "aliases": {
                                        "title": "aliases is a list of string aliases for the given denom",
                                        "type": "array",
                                        "items": {
                                            "type": "string"
                                        }
                                    }
                                }
                            }
                        },
                        "base": {
                            "description": "base represents the base denom (should be the DenomUnit with exponent = 0).",
                            "type": "string"
                        },
                        "display": {
                            "description": "display indicates the suggested denom that should be\ndisplayed in clients.",
                            "type": "string"
                        },
                        "name": {
                            "title": "name defines the name of the token (eg: Cosmos Atom)",
                            "type": "string"
                        },
                        "symbol": {
                            "description": "symbol is the token symbol usually shown on exchanges (eg: ATOM). This can\nbe the same as the display.",
                            "type": "string"
                        }
                    }
                }
            }
        },
        "cosmos.bank.v1beta1.QueryDenomsMetadataResponse": {
            "description": "QueryDenomsMetadataResponse is the response type for the Query/DenomsMetadata RPC\nmethod.",
            "type": "object",
            "properties": {
                "metadatas": {
                    "description": "metadata provides the client information for all the registered tokens.",
                    "type": "array",
                    "items": {
                        "description": "Metadata represents a struct that describes\na basic token.",
                        "type": "object",
                        "properties": {
                            "description": {
                                "type": "string"
                            },
                            "denom_units": {
                                "title": "denom_units represents the list of DenomUnit's for a given coin",
                                "type": "array",
                                "items": {
                                    "description": "DenomUnit represents a struct that describes a given\ndenomination unit of the basic token.",
                                    "type": "object",
                                    "properties": {
                                        "denom": {
                                            "description": "denom represents the string name of the given denom unit (e.g uatom).",
                                            "type": "string"
                                        },
                                        "exponent": {
                                            "format": "int64",
                                            "description": "exponent represents power of 10 exponent that one must\nraise the base_denom to in order to equal the given DenomUnit's denom\n1 denom = 1^exponent base_denom\n(e.g. with a base_denom of uatom, one can create a DenomUnit of 'atom' with\nexponent = 6, thus: 1 atom = 10^6 uatom).",
                                            "type": "integer"
                                        },
                                        "aliases": {
                                            "title": "aliases is a list of string aliases for the given denom",
                                            "type": "array",
                                            "items": {
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            },
                            "base": {
                                "description": "base represents the base denom (should be the DenomUnit with exponent = 0).",
                                "type": "string"
                            },
                            "display": {
                                "description": "display indicates the suggested denom that should be\ndisplayed in clients.",
                                "type": "string"
                            },
                            "name": {
                                "title": "name defines the name of the token (eg: Cosmos Atom)",
                                "type": "string"
                            },
                            "symbol": {
                                "description": "symbol is the token symbol usually shown on exchanges (eg: ATOM). This can\nbe the same as the display.",
                                "type": "string"
                            }
                        }
                    }
                },
                "pagination": {
                    "description": "pagination defines the pagination in the response.",
                    "type": "object",
                    "properties": {
                        "next_key": {
                            "format": "byte",
                            "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently",
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string"
                        },
                        "total": {
                            "format": "uint64",
                            "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                            "type": "string"
                        }
                    }
                }
            }
        },
        "cosmos.bank.v1beta1.QueryParamsResponse": {
            "description": "QueryParamsResponse defines the response type for querying x/bank parameters.",
            "type": "object",
            "properties": {
                "params": {
                    "description": "Params defines the parameters for the bank module.",
                    "type": "object",
                    "properties": {
                        "send_enabled": {
                            "type": "array",
                            "items": {
                                "description": "SendEnabled maps coin denom to a send_enabled status (whether a denom is\nsendable).",
                                "type": "object",
                                "properties": {
                                    "denom": {
                                        "type": "string"
                                    },
                                    "enabled": {
                                        "format": "boolean",
                                        "type": "boolean"
                                    }
                                }
                            }
                        },
                        "default_send_enabled": {
                            "format": "boolean",
                            "type": "boolean"
                        }
                    }
                }
            }
        },
        "cosmos.bank.v1beta1.QuerySupplyOfResponse": {
            "description": "QuerySupplyOfResponse is the response type for the Query/SupplyOf RPC method.",
            "type": "object",
            "properties": {
                "amount": {
                    "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto.",
                    "type": "object",
                    "properties": {
                        "denom": {
                            "type": "string"
                        },
                        "amount": {
                            "type": "string"
                        }
                    }
                }
            }
        },
        "cosmos.bank.v1beta1.QueryTotalSupplyResponse": {
            "title": "QueryTotalSupplyResponse is the response type for the Query/TotalSupply RPC\nmethod",
            "type": "object",
            "properties": {
                "supply": {
                    "title": "supply is the supply of the coins",
                    "type": "array",
                    "items": {
                        "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto.",
                        "type": "object",
                        "properties": {
                            "denom": {
                                "type": "string"
                            },
                            "amount": {
                                "type": "string"
                            }
                        }
                    }
                },
                "pagination": {
                    "description": "pagination defines the pagination in the response.",
                    "type": "object",
                    "properties": {
                        "next_key": {
                            "format": "byte",
                            "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently",
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string"
                        },
                        "total": {
                            "format": "uint64",
                            "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                            "type": "string"
                        }
                    }
                }
            }
        },
        "cosmos.bank.v1beta1.SendEnabled": {
            "description": "SendEnabled maps coin denom to a send_enabled status (whether a denom is\nsendable).",
            "type": "object",
            "properties": {
                "denom": {
                    "type": "string"
                },
                "enabled": {
                    "format": "boolean",
                    "type": "boolean"
                }
            }
        },
        "cosmos.base.v1beta1.Coin": {
            "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto.",
            "type": "object",
            "properties": {
                "denom": {
                    "type": "string"
                },
                "amount": {
                    "type": "string"
                }
            }
        },
        "cosmos.base.tendermint.v1beta1.GetBlockByHeightResponse": {
            "description": "GetBlockByHeightResponse is the response type for the Query/GetBlockByHeight RPC method.",
            "type": "object",
            "properties": {
                "block_id": {
                    "title": "BlockID",
                    "type": "object",
                    "properties": {
                        "hash": {
                            "format": "byte",
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string"
                        },
                        "part_set_header": {
                            "title": "PartsetHeader",
                            "type": "object",
                            "properties": {
                                "total": {
                                    "format": "int64",
                                    "type": "integer"
                                },
                                "hash": {
                                    "format": "byte",
                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                    "type": "string"
                                }
                            }
                        }
                    }
                },
                "block": {
                    "type": "object",
                    "properties": {
                        "header": {
                            "description": "Header defines the structure of a Tendermint block header.",
                            "type": "object",
                            "properties": {
                                "version": {
                                    "title": "basic block info",
                                    "description": "Consensus captures the consensus rules for processing a block in the blockchain,\nincluding all blockchain data structures and the rules of the application's\nstate transition machine.",
                                    "type": "object",
                                    "properties": {
                                        "block": {
                                            "format": "uint64",
                                            "type": "string"
                                        },
                                        "app": {
                                            "format": "uint64",
                                            "type": "string"
                                        }
                                    }
                                },
                                "chain_id": {
                                    "type": "string"
                                },
                                "height": {
                                    "format": "int64",
                                    "type": "string"
                                },
                                "time": {
                                    "format": "date-time",
                                    "type": "string"
                                },
                                "last_block_id": {
                                    "title": "BlockID",
                                    "type": "object",
                                    "properties": {
                                        "hash": {
                                            "format": "byte",
                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                            "type": "string"
                                        },
                                        "part_set_header": {
                                            "title": "PartsetHeader",
                                            "type": "object",
                                            "properties": {
                                                "total": {
                                                    "format": "int64",
                                                    "type": "integer"
                                                },
                                                "hash": {
                                                    "format": "byte",
                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                    "type": "string"
                                                }
                                            }
                                        }
                                    }
                                },
                                "last_commit_hash": {
                                    "format": "byte",
                                    "title": "hashes of block data",
                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                    "type": "string"
                                },
                                "data_hash": {
                                    "format": "byte",
                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                    "type": "string"
                                },
                                "validators_hash": {
                                    "format": "byte",
                                    "title": "hashes from the app output from the prev block",
                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                    "type": "string"
                                },
                                "next_validators_hash": {
                                    "format": "byte",
                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                    "type": "string"
                                },
                                "consensus_hash": {
                                    "format": "byte",
                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                    "type": "string"
                                },
                                "app_hash": {
                                    "format": "byte",
                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                    "type": "string"
                                },
                                "last_results_hash": {
                                    "format": "byte",
                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                    "type": "string"
                                },
                                "evidence_hash": {
                                    "format": "byte",
                                    "title": "consensus info",
                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                    "type": "string"
                                },
                                "proposer_address": {
                                    "format": "byte",
                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                    "type": "string"
                                }
                            }
                        },
                        "data": {
                            "title": "Data contains the set of transactions included in the block",
                            "type": "object",
                            "properties": {
                                "txs": {
                                    "description": "Txs that will be applied by state @ block.Height+1.\nNOTE: not all txs here are valid.  We're just agreeing on the order first.\nThis means that block.AppHash does not include these txs.",
                                    "type": "array",
                                    "items": {
                                        "format": "byte",
                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                        "type": "string"
                                    }
                                }
                            }
                        },
                        "evidence": {
                            "type": "object",
                            "properties": {
                                "evidence": {
                                    "type": "array",
                                    "items": {
                                        "type": "object",
                                        "properties": {
                                            "duplicate_vote_evidence": {
                                                "description": "DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes.",
                                                "type": "object",
                                                "properties": {
                                                    "vote_a": {
                                                        "description": "Vote represents a prevote, precommit, or commit vote from validators for\nconsensus.",
                                                        "type": "object",
                                                        "properties": {
                                                            "type": {
                                                                "description": "SignedMsgType is a type of signed message in the consensus.\n\n - SIGNED_MSG_TYPE_PREVOTE: Votes\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals",
                                                                "default": "SIGNED_MSG_TYPE_UNKNOWN",
                                                                "enum": [
                                                                    "SIGNED_MSG_TYPE_UNKNOWN",
                                                                    "SIGNED_MSG_TYPE_PREVOTE",
                                                                    "SIGNED_MSG_TYPE_PRECOMMIT",
                                                                    "SIGNED_MSG_TYPE_PROPOSAL"
                                                                ],
                                                                "type": "string"
                                                            },
                                                            "height": {
                                                                "format": "int64",
                                                                "type": "string"
                                                            },
                                                            "round": {
                                                                "format": "int32",
                                                                "type": "integer"
                                                            },
                                                            "block_id": {
                                                                "title": "BlockID",
                                                                "type": "object",
                                                                "properties": {
                                                                    "hash": {
                                                                        "format": "byte",
                                                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                        "type": "string"
                                                                    },
                                                                    "part_set_header": {
                                                                        "title": "PartsetHeader",
                                                                        "type": "object",
                                                                        "properties": {
                                                                            "total": {
                                                                                "format": "int64",
                                                                                "type": "integer"
                                                                            },
                                                                            "hash": {
                                                                                "format": "byte",
                                                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                "type": "string"
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            },
                                                            "timestamp": {
                                                                "format": "date-time",
                                                                "type": "string"
                                                            },
                                                            "validator_address": {
                                                                "format": "byte",
                                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                "type": "string"
                                                            },
                                                            "validator_index": {
                                                                "format": "int32",
                                                                "type": "integer"
                                                            },
                                                            "signature": {
                                                                "format": "byte",
                                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                "type": "string"
                                                            }
                                                        }
                                                    },
                                                    "vote_b": {
                                                        "description": "Vote represents a prevote, precommit, or commit vote from validators for\nconsensus.",
                                                        "type": "object",
                                                        "properties": {
                                                            "type": {
                                                                "description": "SignedMsgType is a type of signed message in the consensus.\n\n - SIGNED_MSG_TYPE_PREVOTE: Votes\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals",
                                                                "default": "SIGNED_MSG_TYPE_UNKNOWN",
                                                                "enum": [
                                                                    "SIGNED_MSG_TYPE_UNKNOWN",
                                                                    "SIGNED_MSG_TYPE_PREVOTE",
                                                                    "SIGNED_MSG_TYPE_PRECOMMIT",
                                                                    "SIGNED_MSG_TYPE_PROPOSAL"
                                                                ],
                                                                "type": "string"
                                                            },
                                                            "height": {
                                                                "format": "int64",
                                                                "type": "string"
                                                            },
                                                            "round": {
                                                                "format": "int32",
                                                                "type": "integer"
                                                            },
                                                            "block_id": {
                                                                "title": "BlockID",
                                                                "type": "object",
                                                                "properties": {
                                                                    "hash": {
                                                                        "format": "byte",
                                                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                        "type": "string"
                                                                    },
                                                                    "part_set_header": {
                                                                        "title": "PartsetHeader",
                                                                        "type": "object",
                                                                        "properties": {
                                                                            "total": {
                                                                                "format": "int64",
                                                                                "type": "integer"
                                                                            },
                                                                            "hash": {
                                                                                "format": "byte",
                                                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                "type": "string"
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            },
                                                            "timestamp": {
                                                                "format": "date-time",
                                                                "type": "string"
                                                            },
                                                            "validator_address": {
                                                                "format": "byte",
                                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                "type": "string"
                                                            },
                                                            "validator_index": {
                                                                "format": "int32",
                                                                "type": "integer"
                                                            },
                                                            "signature": {
                                                                "format": "byte",
                                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                "type": "string"
                                                            }
                                                        }
                                                    },
                                                    "total_voting_power": {
                                                        "format": "int64",
                                                        "type": "string"
                                                    },
                                                    "validator_power": {
                                                        "format": "int64",
                                                        "type": "string"
                                                    },
                                                    "timestamp": {
                                                        "format": "date-time",
                                                        "type": "string"
                                                    }
                                                }
                                            },
                                            "light_client_attack_evidence": {
                                                "description": "LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client.",
                                                "type": "object",
                                                "properties": {
                                                    "conflicting_block": {
                                                        "type": "object",
                                                        "properties": {
                                                            "signed_header": {
                                                                "type": "object",
                                                                "properties": {
                                                                    "header": {
                                                                        "description": "Header defines the structure of a Tendermint block header.",
                                                                        "type": "object",
                                                                        "properties": {
                                                                            "version": {
                                                                                "title": "basic block info",
                                                                                "description": "Consensus captures the consensus rules for processing a block in the blockchain,\nincluding all blockchain data structures and the rules of the application's\nstate transition machine.",
                                                                                "type": "object",
                                                                                "properties": {
                                                                                    "block": {
                                                                                        "format": "uint64",
                                                                                        "type": "string"
                                                                                    },
                                                                                    "app": {
                                                                                        "format": "uint64",
                                                                                        "type": "string"
                                                                                    }
                                                                                }
                                                                            },
                                                                            "chain_id": {
                                                                                "type": "string"
                                                                            },
                                                                            "height": {
                                                                                "format": "int64",
                                                                                "type": "string"
                                                                            },
                                                                            "time": {
                                                                                "format": "date-time",
                                                                                "type": "string"
                                                                            },
                                                                            "last_block_id": {
                                                                                "title": "BlockID",
                                                                                "type": "object",
                                                                                "properties": {
                                                                                    "hash": {
                                                                                        "format": "byte",
                                                                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                        "type": "string"
                                                                                    },
                                                                                    "part_set_header": {
                                                                                        "title": "PartsetHeader",
                                                                                        "type": "object",
                                                                                        "properties": {
                                                                                            "total": {
                                                                                                "format": "int64",
                                                                                                "type": "integer"
                                                                                            },
                                                                                            "hash": {
                                                                                                "format": "byte",
                                                                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                                "type": "string"
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            },
                                                                            "last_commit_hash": {
                                                                                "format": "byte",
                                                                                "title": "hashes of block data",
                                                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                "type": "string"
                                                                            },
                                                                            "data_hash": {
                                                                                "format": "byte",
                                                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                "type": "string"
                                                                            },
                                                                            "validators_hash": {
                                                                                "format": "byte",
                                                                                "title": "hashes from the app output from the prev block",
                                                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                "type": "string"
                                                                            },
                                                                            "next_validators_hash": {
                                                                                "format": "byte",
                                                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                "type": "string"
                                                                            },
                                                                            "consensus_hash": {
                                                                                "format": "byte",
                                                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                "type": "string"
                                                                            },
                                                                            "app_hash": {
                                                                                "format": "byte",
                                                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                "type": "string"
                                                                            },
                                                                            "last_results_hash": {
                                                                                "format": "byte",
                                                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                "type": "string"
                                                                            },
                                                                            "evidence_hash": {
                                                                                "format": "byte",
                                                                                "title": "consensus info",
                                                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                "type": "string"
                                                                            },
                                                                            "proposer_address": {
                                                                                "format": "byte",
                                                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                "type": "string"
                                                                            }
                                                                        }
                                                                    },
                                                                    "commit": {
                                                                        "description": "Commit contains the evidence that a block was committed by a set of validators.",
                                                                        "type": "object",
                                                                        "properties": {
                                                                            "height": {
                                                                                "format": "int64",
                                                                                "type": "string"
                                                                            },
                                                                            "round": {
                                                                                "format": "int32",
                                                                                "type": "integer"
                                                                            },
                                                                            "block_id": {
                                                                                "title": "BlockID",
                                                                                "type": "object",
                                                                                "properties": {
                                                                                    "hash": {
                                                                                        "format": "byte",
                                                                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                        "type": "string"
                                                                                    },
                                                                                    "part_set_header": {
                                                                                        "title": "PartsetHeader",
                                                                                        "type": "object",
                                                                                        "properties": {
                                                                                            "total": {
                                                                                                "format": "int64",
                                                                                                "type": "integer"
                                                                                            },
                                                                                            "hash": {
                                                                                                "format": "byte",
                                                                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                                "type": "string"
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            },
                                                                            "signatures": {
                                                                                "type": "array",
                                                                                "items": {
                                                                                    "description": "CommitSig is a part of the Vote included in a Commit.",
                                                                                    "type": "object",
                                                                                    "properties": {
                                                                                        "block_id_flag": {
                                                                                            "title": "BlockIdFlag indicates which BlcokID the signature is for",
                                                                                            "default": "BLOCK_ID_FLAG_UNKNOWN",
                                                                                            "enum": [
                                                                                                "BLOCK_ID_FLAG_UNKNOWN",
                                                                                                "BLOCK_ID_FLAG_ABSENT",
                                                                                                "BLOCK_ID_FLAG_COMMIT",
                                                                                                "BLOCK_ID_FLAG_NIL"
                                                                                            ],
                                                                                            "type": "string"
                                                                                        },
                                                                                        "validator_address": {
                                                                                            "format": "byte",
                                                                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                            "type": "string"
                                                                                        },
                                                                                        "timestamp": {
                                                                                            "format": "date-time",
                                                                                            "type": "string"
                                                                                        },
                                                                                        "signature": {
                                                                                            "format": "byte",
                                                                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                            "type": "string"
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            },
                                                            "validator_set": {
                                                                "type": "object",
                                                                "properties": {
                                                                    "validators": {
                                                                        "type": "array",
                                                                        "items": {
                                                                            "type": "object",
                                                                            "properties": {
                                                                                "address": {
                                                                                    "format": "byte",
                                                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                    "type": "string"
                                                                                },
                                                                                "pub_key": {
                                                                                    "title": "PublicKey defines the keys available for use with Tendermint Validators",
                                                                                    "type": "object",
                                                                                    "properties": {
                                                                                        "ed25519": {
                                                                                            "format": "byte",
                                                                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                            "type": "string"
                                                                                        },
                                                                                        "secp256k1": {
                                                                                            "format": "byte",
                                                                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                            "type": "string"
                                                                                        }
                                                                                    }
                                                                                },
                                                                                "voting_power": {
                                                                                    "format": "int64",
                                                                                    "type": "string"
                                                                                },
                                                                                "proposer_priority": {
                                                                                    "format": "int64",
                                                                                    "type": "string"
                                                                                }
                                                                            }
                                                                        }
                                                                    },
                                                                    "proposer": {
                                                                        "type": "object",
                                                                        "properties": {
                                                                            "address": {
                                                                                "format": "byte",
                                                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                "type": "string"
                                                                            },
                                                                            "pub_key": {
                                                                                "title": "PublicKey defines the keys available for use with Tendermint Validators",
                                                                                "type": "object",
                                                                                "properties": {
                                                                                    "ed25519": {
                                                                                        "format": "byte",
                                                                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                        "type": "string"
                                                                                    },
                                                                                    "secp256k1": {
                                                                                        "format": "byte",
                                                                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                        "type": "string"
                                                                                    }
                                                                                }
                                                                            },
                                                                            "voting_power": {
                                                                                "format": "int64",
                                                                                "type": "string"
                                                                            },
                                                                            "proposer_priority": {
                                                                                "format": "int64",
                                                                                "type": "string"
                                                                            }
                                                                        }
                                                                    },
                                                                    "total_voting_power": {
                                                                        "format": "int64",
                                                                        "type": "string"
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    },
                                                    "common_height": {
                                                        "format": "int64",
                                                        "type": "string"
                                                    },
                                                    "byzantine_validators": {
                                                        "type": "array",
                                                        "items": {
                                                            "type": "object",
                                                            "properties": {
                                                                "address": {
                                                                    "format": "byte",
                                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                    "type": "string"
                                                                },
                                                                "pub_key": {
                                                                    "title": "PublicKey defines the keys available for use with Tendermint Validators",
                                                                    "type": "object",
                                                                    "properties": {
                                                                        "ed25519": {
                                                                            "format": "byte",
                                                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                            "type": "string"
                                                                        },
                                                                        "secp256k1": {
                                                                            "format": "byte",
                                                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                            "type": "string"
                                                                        }
                                                                    }
                                                                },
                                                                "voting_power": {
                                                                    "format": "int64",
                                                                    "type": "string"
                                                                },
                                                                "proposer_priority": {
                                                                    "format": "int64",
                                                                    "type": "string"
                                                                }
                                                            }
                                                        }
                                                    },
                                                    "total_voting_power": {
                                                        "format": "int64",
                                                        "type": "string"
                                                    },
                                                    "timestamp": {
                                                        "format": "date-time",
                                                        "type": "string"
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        },
                        "last_commit": {
                            "description": "Commit contains the evidence that a block was committed by a set of validators.",
                            "type": "object",
                            "properties": {
                                "height": {
                                    "format": "int64",
                                    "type": "string"
                                },
                                "round": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "block_id": {
                                    "title": "BlockID",
                                    "type": "object",
                                    "properties": {
                                        "hash": {
                                            "format": "byte",
                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                            "type": "string"
                                        },
                                        "part_set_header": {
                                            "title": "PartsetHeader",
                                            "type": "object",
                                            "properties": {
                                                "total": {
                                                    "format": "int64",
                                                    "type": "integer"
                                                },
                                                "hash": {
                                                    "format": "byte",
                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                    "type": "string"
                                                }
                                            }
                                        }
                                    }
                                },
                                "signatures": {
                                    "type": "array",
                                    "items": {
                                        "description": "CommitSig is a part of the Vote included in a Commit.",
                                        "type": "object",
                                        "properties": {
                                            "block_id_flag": {
                                                "title": "BlockIdFlag indicates which BlcokID the signature is for",
                                                "default": "BLOCK_ID_FLAG_UNKNOWN",
                                                "enum": [
                                                    "BLOCK_ID_FLAG_UNKNOWN",
                                                    "BLOCK_ID_FLAG_ABSENT",
                                                    "BLOCK_ID_FLAG_COMMIT",
                                                    "BLOCK_ID_FLAG_NIL"
                                                ],
                                                "type": "string"
                                            },
                                            "validator_address": {
                                                "format": "byte",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            },
                                            "timestamp": {
                                                "format": "date-time",
                                                "type": "string"
                                            },
                                            "signature": {
                                                "format": "byte",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        },
        "cosmos.base.tendermint.v1beta1.GetLatestBlockResponse": {
            "description": "GetLatestBlockResponse is the response type for the Query/GetLatestBlock RPC method.",
            "type": "object",
            "properties": {
                "block_id": {
                    "title": "BlockID",
                    "type": "object",
                    "properties": {
                        "hash": {
                            "format": "byte",
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string"
                        },
                        "part_set_header": {
                            "title": "PartsetHeader",
                            "type": "object",
                            "properties": {
                                "total": {
                                    "format": "int64",
                                    "type": "integer"
                                },
                                "hash": {
                                    "format": "byte",
                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                    "type": "string"
                                }
                            }
                        }
                    }
                },
                "block": {
                    "type": "object",
                    "properties": {
                        "header": {
                            "description": "Header defines the structure of a Tendermint block header.",
                            "type": "object",
                            "properties": {
                                "version": {
                                    "title": "basic block info",
                                    "description": "Consensus captures the consensus rules for processing a block in the blockchain,\nincluding all blockchain data structures and the rules of the application's\nstate transition machine.",
                                    "type": "object",
                                    "properties": {
                                        "block": {
                                            "format": "uint64",
                                            "type": "string"
                                        },
                                        "app": {
                                            "format": "uint64",
                                            "type": "string"
                                        }
                                    }
                                },
                                "chain_id": {
                                    "type": "string"
                                },
                                "height": {
                                    "format": "int64",
                                    "type": "string"
                                },
                                "time": {
                                    "format": "date-time",
                                    "type": "string"
                                },
                                "last_block_id": {
                                    "title": "BlockID",
                                    "type": "object",
                                    "properties": {
                                        "hash": {
                                            "format": "byte",
                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                            "type": "string"
                                        },
                                        "part_set_header": {
                                            "title": "PartsetHeader",
                                            "type": "object",
                                            "properties": {
                                                "total": {
                                                    "format": "int64",
                                                    "type": "integer"
                                                },
                                                "hash": {
                                                    "format": "byte",
                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                    "type": "string"
                                                }
                                            }
                                        }
                                    }
                                },
                                "last_commit_hash": {
                                    "format": "byte",
                                    "title": "hashes of block data",
                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                    "type": "string"
                                },
                                "data_hash": {
                                    "format": "byte",
                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                    "type": "string"
                                },
                                "validators_hash": {
                                    "format": "byte",
                                    "title": "hashes from the app output from the prev block",
                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                    "type": "string"
                                },
                                "next_validators_hash": {
                                    "format": "byte",
                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                    "type": "string"
                                },
                                "consensus_hash": {
                                    "format": "byte",
                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                    "type": "string"
                                },
                                "app_hash": {
                                    "format": "byte",
                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                    "type": "string"
                                },
                                "last_results_hash": {
                                    "format": "byte",
                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                    "type": "string"
                                },
                                "evidence_hash": {
                                    "format": "byte",
                                    "title": "consensus info",
                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                    "type": "string"
                                },
                                "proposer_address": {
                                    "format": "byte",
                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                    "type": "string"
                                }
                            }
                        },
                        "data": {
                            "title": "Data contains the set of transactions included in the block",
                            "type": "object",
                            "properties": {
                                "txs": {
                                    "description": "Txs that will be applied by state @ block.Height+1.\nNOTE: not all txs here are valid.  We're just agreeing on the order first.\nThis means that block.AppHash does not include these txs.",
                                    "type": "array",
                                    "items": {
                                        "format": "byte",
                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                        "type": "string"
                                    }
                                }
                            }
                        },
                        "evidence": {
                            "type": "object",
                            "properties": {
                                "evidence": {
                                    "type": "array",
                                    "items": {
                                        "type": "object",
                                        "properties": {
                                            "duplicate_vote_evidence": {
                                                "description": "DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes.",
                                                "type": "object",
                                                "properties": {
                                                    "vote_a": {
                                                        "description": "Vote represents a prevote, precommit, or commit vote from validators for\nconsensus.",
                                                        "type": "object",
                                                        "properties": {
                                                            "type": {
                                                                "description": "SignedMsgType is a type of signed message in the consensus.\n\n - SIGNED_MSG_TYPE_PREVOTE: Votes\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals",
                                                                "default": "SIGNED_MSG_TYPE_UNKNOWN",
                                                                "enum": [
                                                                    "SIGNED_MSG_TYPE_UNKNOWN",
                                                                    "SIGNED_MSG_TYPE_PREVOTE",
                                                                    "SIGNED_MSG_TYPE_PRECOMMIT",
                                                                    "SIGNED_MSG_TYPE_PROPOSAL"
                                                                ],
                                                                "type": "string"
                                                            },
                                                            "height": {
                                                                "format": "int64",
                                                                "type": "string"
                                                            },
                                                            "round": {
                                                                "format": "int32",
                                                                "type": "integer"
                                                            },
                                                            "block_id": {
                                                                "title": "BlockID",
                                                                "type": "object",
                                                                "properties": {
                                                                    "hash": {
                                                                        "format": "byte",
                                                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                        "type": "string"
                                                                    },
                                                                    "part_set_header": {
                                                                        "title": "PartsetHeader",
                                                                        "type": "object",
                                                                        "properties": {
                                                                            "total": {
                                                                                "format": "int64",
                                                                                "type": "integer"
                                                                            },
                                                                            "hash": {
                                                                                "format": "byte",
                                                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                "type": "string"
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            },
                                                            "timestamp": {
                                                                "format": "date-time",
                                                                "type": "string"
                                                            },
                                                            "validator_address": {
                                                                "format": "byte",
                                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                "type": "string"
                                                            },
                                                            "validator_index": {
                                                                "format": "int32",
                                                                "type": "integer"
                                                            },
                                                            "signature": {
                                                                "format": "byte",
                                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                "type": "string"
                                                            }
                                                        }
                                                    },
                                                    "vote_b": {
                                                        "description": "Vote represents a prevote, precommit, or commit vote from validators for\nconsensus.",
                                                        "type": "object",
                                                        "properties": {
                                                            "type": {
                                                                "description": "SignedMsgType is a type of signed message in the consensus.\n\n - SIGNED_MSG_TYPE_PREVOTE: Votes\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals",
                                                                "default": "SIGNED_MSG_TYPE_UNKNOWN",
                                                                "enum": [
                                                                    "SIGNED_MSG_TYPE_UNKNOWN",
                                                                    "SIGNED_MSG_TYPE_PREVOTE",
                                                                    "SIGNED_MSG_TYPE_PRECOMMIT",
                                                                    "SIGNED_MSG_TYPE_PROPOSAL"
                                                                ],
                                                                "type": "string"
                                                            },
                                                            "height": {
                                                                "format": "int64",
                                                                "type": "string"
                                                            },
                                                            "round": {
                                                                "format": "int32",
                                                                "type": "integer"
                                                            },
                                                            "block_id": {
                                                                "title": "BlockID",
                                                                "type": "object",
                                                                "properties": {
                                                                    "hash": {
                                                                        "format": "byte",
                                                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                        "type": "string"
                                                                    },
                                                                    "part_set_header": {
                                                                        "title": "PartsetHeader",
                                                                        "type": "object",
                                                                        "properties": {
                                                                            "total": {
                                                                                "format": "int64",
                                                                                "type": "integer"
                                                                            },
                                                                            "hash": {
                                                                                "format": "byte",
                                                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                "type": "string"
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            },
                                                            "timestamp": {
                                                                "format": "date-time",
                                                                "type": "string"
                                                            },
                                                            "validator_address": {
                                                                "format": "byte",
                                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                "type": "string"
                                                            },
                                                            "validator_index": {
                                                                "format": "int32",
                                                                "type": "integer"
                                                            },
                                                            "signature": {
                                                                "format": "byte",
                                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                "type": "string"
                                                            }
                                                        }
                                                    },
                                                    "total_voting_power": {
                                                        "format": "int64",
                                                        "type": "string"
                                                    },
                                                    "validator_power": {
                                                        "format": "int64",
                                                        "type": "string"
                                                    },
                                                    "timestamp": {
                                                        "format": "date-time",
                                                        "type": "string"
                                                    }
                                                }
                                            },
                                            "light_client_attack_evidence": {
                                                "description": "LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client.",
                                                "type": "object",
                                                "properties": {
                                                    "conflicting_block": {
                                                        "type": "object",
                                                        "properties": {
                                                            "signed_header": {
                                                                "type": "object",
                                                                "properties": {
                                                                    "header": {
                                                                        "description": "Header defines the structure of a Tendermint block header.",
                                                                        "type": "object",
                                                                        "properties": {
                                                                            "version": {
                                                                                "title": "basic block info",
                                                                                "description": "Consensus captures the consensus rules for processing a block in the blockchain,\nincluding all blockchain data structures and the rules of the application's\nstate transition machine.",
                                                                                "type": "object",
                                                                                "properties": {
                                                                                    "block": {
                                                                                        "format": "uint64",
                                                                                        "type": "string"
                                                                                    },
                                                                                    "app": {
                                                                                        "format": "uint64",
                                                                                        "type": "string"
                                                                                    }
                                                                                }
                                                                            },
                                                                            "chain_id": {
                                                                                "type": "string"
                                                                            },
                                                                            "height": {
                                                                                "format": "int64",
                                                                                "type": "string"
                                                                            },
                                                                            "time": {
                                                                                "format": "date-time",
                                                                                "type": "string"
                                                                            },
                                                                            "last_block_id": {
                                                                                "title": "BlockID",
                                                                                "type": "object",
                                                                                "properties": {
                                                                                    "hash": {
                                                                                        "format": "byte",
                                                                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                        "type": "string"
                                                                                    },
                                                                                    "part_set_header": {
                                                                                        "title": "PartsetHeader",
                                                                                        "type": "object",
                                                                                        "properties": {
                                                                                            "total": {
                                                                                                "format": "int64",
                                                                                                "type": "integer"
                                                                                            },
                                                                                            "hash": {
                                                                                                "format": "byte",
                                                                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                                "type": "string"
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            },
                                                                            "last_commit_hash": {
                                                                                "format": "byte",
                                                                                "title": "hashes of block data",
                                                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                "type": "string"
                                                                            },
                                                                            "data_hash": {
                                                                                "format": "byte",
                                                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                "type": "string"
                                                                            },
                                                                            "validators_hash": {
                                                                                "format": "byte",
                                                                                "title": "hashes from the app output from the prev block",
                                                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                "type": "string"
                                                                            },
                                                                            "next_validators_hash": {
                                                                                "format": "byte",
                                                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                "type": "string"
                                                                            },
                                                                            "consensus_hash": {
                                                                                "format": "byte",
                                                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                "type": "string"
                                                                            },
                                                                            "app_hash": {
                                                                                "format": "byte",
                                                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                "type": "string"
                                                                            },
                                                                            "last_results_hash": {
                                                                                "format": "byte",
                                                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                "type": "string"
                                                                            },
                                                                            "evidence_hash": {
                                                                                "format": "byte",
                                                                                "title": "consensus info",
                                                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                "type": "string"
                                                                            },
                                                                            "proposer_address": {
                                                                                "format": "byte",
                                                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                "type": "string"
                                                                            }
                                                                        }
                                                                    },
                                                                    "commit": {
                                                                        "description": "Commit contains the evidence that a block was committed by a set of validators.",
                                                                        "type": "object",
                                                                        "properties": {
                                                                            "height": {
                                                                                "format": "int64",
                                                                                "type": "string"
                                                                            },
                                                                            "round": {
                                                                                "format": "int32",
                                                                                "type": "integer"
                                                                            },
                                                                            "block_id": {
                                                                                "title": "BlockID",
                                                                                "type": "object",
                                                                                "properties": {
                                                                                    "hash": {
                                                                                        "format": "byte",
                                                                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                        "type": "string"
                                                                                    },
                                                                                    "part_set_header": {
                                                                                        "title": "PartsetHeader",
                                                                                        "type": "object",
                                                                                        "properties": {
                                                                                            "total": {
                                                                                                "format": "int64",
                                                                                                "type": "integer"
                                                                                            },
                                                                                            "hash": {
                                                                                                "format": "byte",
                                                                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                                "type": "string"
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            },
                                                                            "signatures": {
                                                                                "type": "array",
                                                                                "items": {
                                                                                    "description": "CommitSig is a part of the Vote included in a Commit.",
                                                                                    "type": "object",
                                                                                    "properties": {
                                                                                        "block_id_flag": {
                                                                                            "title": "BlockIdFlag indicates which BlcokID the signature is for",
                                                                                            "default": "BLOCK_ID_FLAG_UNKNOWN",
                                                                                            "enum": [
                                                                                                "BLOCK_ID_FLAG_UNKNOWN",
                                                                                                "BLOCK_ID_FLAG_ABSENT",
                                                                                                "BLOCK_ID_FLAG_COMMIT",
                                                                                                "BLOCK_ID_FLAG_NIL"
                                                                                            ],
                                                                                            "type": "string"
                                                                                        },
                                                                                        "validator_address": {
                                                                                            "format": "byte",
                                                                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                            "type": "string"
                                                                                        },
                                                                                        "timestamp": {
                                                                                            "format": "date-time",
                                                                                            "type": "string"
                                                                                        },
                                                                                        "signature": {
                                                                                            "format": "byte",
                                                                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                            "type": "string"
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            },
                                                            "validator_set": {
                                                                "type": "object",
                                                                "properties": {
                                                                    "validators": {
                                                                        "type": "array",
                                                                        "items": {
                                                                            "type": "object",
                                                                            "properties": {
                                                                                "address": {
                                                                                    "format": "byte",
                                                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                    "type": "string"
                                                                                },
                                                                                "pub_key": {
                                                                                    "title": "PublicKey defines the keys available for use with Tendermint Validators",
                                                                                    "type": "object",
                                                                                    "properties": {
                                                                                        "ed25519": {
                                                                                            "format": "byte",
                                                                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                            "type": "string"
                                                                                        },
                                                                                        "secp256k1": {
                                                                                            "format": "byte",
                                                                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                            "type": "string"
                                                                                        }
                                                                                    }
                                                                                },
                                                                                "voting_power": {
                                                                                    "format": "int64",
                                                                                    "type": "string"
                                                                                },
                                                                                "proposer_priority": {
                                                                                    "format": "int64",
                                                                                    "type": "string"
                                                                                }
                                                                            }
                                                                        }
                                                                    },
                                                                    "proposer": {
                                                                        "type": "object",
                                                                        "properties": {
                                                                            "address": {
                                                                                "format": "byte",
                                                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                "type": "string"
                                                                            },
                                                                            "pub_key": {
                                                                                "title": "PublicKey defines the keys available for use with Tendermint Validators",
                                                                                "type": "object",
                                                                                "properties": {
                                                                                    "ed25519": {
                                                                                        "format": "byte",
                                                                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                        "type": "string"
                                                                                    },
                                                                                    "secp256k1": {
                                                                                        "format": "byte",
                                                                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                        "type": "string"
                                                                                    }
                                                                                }
                                                                            },
                                                                            "voting_power": {
                                                                                "format": "int64",
                                                                                "type": "string"
                                                                            },
                                                                            "proposer_priority": {
                                                                                "format": "int64",
                                                                                "type": "string"
                                                                            }
                                                                        }
                                                                    },
                                                                    "total_voting_power": {
                                                                        "format": "int64",
                                                                        "type": "string"
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    },
                                                    "common_height": {
                                                        "format": "int64",
                                                        "type": "string"
                                                    },
                                                    "byzantine_validators": {
                                                        "type": "array",
                                                        "items": {
                                                            "type": "object",
                                                            "properties": {
                                                                "address": {
                                                                    "format": "byte",
                                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                    "type": "string"
                                                                },
                                                                "pub_key": {
                                                                    "title": "PublicKey defines the keys available for use with Tendermint Validators",
                                                                    "type": "object",
                                                                    "properties": {
                                                                        "ed25519": {
                                                                            "format": "byte",
                                                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                            "type": "string"
                                                                        },
                                                                        "secp256k1": {
                                                                            "format": "byte",
                                                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                            "type": "string"
                                                                        }
                                                                    }
                                                                },
                                                                "voting_power": {
                                                                    "format": "int64",
                                                                    "type": "string"
                                                                },
                                                                "proposer_priority": {
                                                                    "format": "int64",
                                                                    "type": "string"
                                                                }
                                                            }
                                                        }
                                                    },
                                                    "total_voting_power": {
                                                        "format": "int64",
                                                        "type": "string"
                                                    },
                                                    "timestamp": {
                                                        "format": "date-time",
                                                        "type": "string"
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        },
                        "last_commit": {
                            "description": "Commit contains the evidence that a block was committed by a set of validators.",
                            "type": "object",
                            "properties": {
                                "height": {
                                    "format": "int64",
                                    "type": "string"
                                },
                                "round": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "block_id": {
                                    "title": "BlockID",
                                    "type": "object",
                                    "properties": {
                                        "hash": {
                                            "format": "byte",
                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                            "type": "string"
                                        },
                                        "part_set_header": {
                                            "title": "PartsetHeader",
                                            "type": "object",
                                            "properties": {
                                                "total": {
                                                    "format": "int64",
                                                    "type": "integer"
                                                },
                                                "hash": {
                                                    "format": "byte",
                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                    "type": "string"
                                                }
                                            }
                                        }
                                    }
                                },
                                "signatures": {
                                    "type": "array",
                                    "items": {
                                        "description": "CommitSig is a part of the Vote included in a Commit.",
                                        "type": "object",
                                        "properties": {
                                            "block_id_flag": {
                                                "title": "BlockIdFlag indicates which BlcokID the signature is for",
                                                "default": "BLOCK_ID_FLAG_UNKNOWN",
                                                "enum": [
                                                    "BLOCK_ID_FLAG_UNKNOWN",
                                                    "BLOCK_ID_FLAG_ABSENT",
                                                    "BLOCK_ID_FLAG_COMMIT",
                                                    "BLOCK_ID_FLAG_NIL"
                                                ],
                                                "type": "string"
                                            },
                                            "validator_address": {
                                                "format": "byte",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            },
                                            "timestamp": {
                                                "format": "date-time",
                                                "type": "string"
                                            },
                                            "signature": {
                                                "format": "byte",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        },
        "cosmos.base.tendermint.v1beta1.GetLatestValidatorSetResponse": {
            "description": "GetLatestValidatorSetResponse is the response type for the Query/GetValidatorSetByHeight RPC method.",
            "type": "object",
            "properties": {
                "block_height": {
                    "format": "int64",
                    "type": "string"
                },
                "validators": {
                    "type": "array",
                    "items": {
                        "description": "Validator is the type for the validator-set.",
                        "type": "object",
                        "properties": {
                            "address": {
                                "type": "string"
                            },
                            "pub_key": {
                                "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                "type": "object",
                                "properties": {
                                    "type_url": {
                                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                        "type": "string"
                                    },
                                    "value": {
                                        "format": "byte",
                                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                        "type": "string"
                                    }
                                }
                            },
                            "voting_power": {
                                "format": "int64",
                                "type": "string"
                            },
                            "proposer_priority": {
                                "format": "int64",
                                "type": "string"
                            }
                        }
                    }
                },
                "pagination": {
                    "description": "pagination defines an pagination for the response.",
                    "type": "object",
                    "properties": {
                        "next_key": {
                            "format": "byte",
                            "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently",
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string"
                        },
                        "total": {
                            "format": "uint64",
                            "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                            "type": "string"
                        }
                    }
                }
            }
        },
        "cosmos.base.tendermint.v1beta1.GetNodeInfoResponse": {
            "description": "GetNodeInfoResponse is the request type for the Query/GetNodeInfo RPC method.",
            "type": "object",
            "properties": {
                "default_node_info": {
                    "type": "object",
                    "properties": {
                        "protocol_version": {
                            "type": "object",
                            "properties": {
                                "p2p": {
                                    "format": "uint64",
                                    "type": "string"
                                },
                                "block": {
                                    "format": "uint64",
                                    "type": "string"
                                },
                                "app": {
                                    "format": "uint64",
                                    "type": "string"
                                }
                            }
                        },
                        "default_node_id": {
                            "type": "string"
                        },
                        "listen_addr": {
                            "type": "string"
                        },
                        "network": {
                            "type": "string"
                        },
                        "version": {
                            "type": "string"
                        },
                        "channels": {
                            "format": "byte",
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string"
                        },
                        "moniker": {
                            "type": "string"
                        },
                        "other": {
                            "type": "object",
                            "properties": {
                                "tx_index": {
                                    "type": "string"
                                },
                                "rpc_address": {
                                    "type": "string"
                                }
                            }
                        }
                    }
                },
                "application_version": {
                    "description": "VersionInfo is the type for the GetNodeInfoResponse message.",
                    "type": "object",
                    "properties": {
                        "name": {
                            "type": "string"
                        },
                        "app_name": {
                            "type": "string"
                        },
                        "version": {
                            "type": "string"
                        },
                        "git_commit": {
                            "type": "string"
                        },
                        "build_tags": {
                            "type": "string"
                        },
                        "go_version": {
                            "type": "string"
                        },
                        "build_deps": {
                            "type": "array",
                            "items": {
                                "title": "Module is the type for VersionInfo",
                                "type": "object",
                                "properties": {
                                    "path": {
                                        "title": "module path",
                                        "type": "string"
                                    },
                                    "version": {
                                        "title": "module version",
                                        "type": "string"
                                    },
                                    "sum": {
                                        "title": "checksum",
                                        "type": "string"
                                    }
                                }
                            }
                        },
                        "cosmos_sdk_version": {
                            "type": "string"
                        }
                    }
                }
            }
        },
        "cosmos.base.tendermint.v1beta1.GetSyncingResponse": {
            "description": "GetSyncingResponse is the response type for the Query/GetSyncing RPC method.",
            "type": "object",
            "properties": {
                "syncing": {
                    "format": "boolean",
                    "type": "boolean"
                }
            }
        },
        "cosmos.base.tendermint.v1beta1.GetValidatorSetByHeightResponse": {
            "description": "GetValidatorSetByHeightResponse is the response type for the Query/GetValidatorSetByHeight RPC method.",
            "type": "object",
            "properties": {
                "block_height": {
                    "format": "int64",
                    "type": "string"
                },
                "validators": {
                    "type": "array",
                    "items": {
                        "description": "Validator is the type for the validator-set.",
                        "type": "object",
                        "properties": {
                            "address": {
                                "type": "string"
                            },
                            "pub_key": {
                                "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                "type": "object",
                                "properties": {
                                    "type_url": {
                                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                        "type": "string"
                                    },
                                    "value": {
                                        "format": "byte",
                                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                        "type": "string"
                                    }
                                }
                            },
                            "voting_power": {
                                "format": "int64",
                                "type": "string"
                            },
                            "proposer_priority": {
                                "format": "int64",
                                "type": "string"
                            }
                        }
                    }
                },
                "pagination": {
                    "description": "pagination defines an pagination for the response.",
                    "type": "object",
                    "properties": {
                        "next_key": {
                            "format": "byte",
                            "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently",
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string"
                        },
                        "total": {
                            "format": "uint64",
                            "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                            "type": "string"
                        }
                    }
                }
            }
        },
        "cosmos.base.tendermint.v1beta1.Module": {
            "title": "Module is the type for VersionInfo",
            "type": "object",
            "properties": {
                "path": {
                    "title": "module path",
                    "type": "string"
                },
                "version": {
                    "title": "module version",
                    "type": "string"
                },
                "sum": {
                    "title": "checksum",
                    "type": "string"
                }
            }
        },
        "cosmos.base.tendermint.v1beta1.Validator": {
            "description": "Validator is the type for the validator-set.",
            "type": "object",
            "properties": {
                "address": {
                    "type": "string"
                },
                "pub_key": {
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                    "type": "object",
                    "properties": {
                        "type_url": {
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                            "type": "string"
                        },
                        "value": {
                            "format": "byte",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string"
                        }
                    }
                },
                "voting_power": {
                    "format": "int64",
                    "type": "string"
                },
                "proposer_priority": {
                    "format": "int64",
                    "type": "string"
                }
            }
        },
        "cosmos.base.tendermint.v1beta1.VersionInfo": {
            "description": "VersionInfo is the type for the GetNodeInfoResponse message.",
            "type": "object",
            "properties": {
                "name": {
                    "type": "string"
                },
                "app_name": {
                    "type": "string"
                },
                "version": {
                    "type": "string"
                },
                "git_commit": {
                    "type": "string"
                },
                "build_tags": {
                    "type": "string"
                },
                "go_version": {
                    "type": "string"
                },
                "build_deps": {
                    "type": "array",
                    "items": {
                        "title": "Module is the type for VersionInfo",
                        "type": "object",
                        "properties": {
                            "path": {
                                "title": "module path",
                                "type": "string"
                            },
                            "version": {
                                "title": "module version",
                                "type": "string"
                            },
                            "sum": {
                                "title": "checksum",
                                "type": "string"
                            }
                        }
                    }
                },
                "cosmos_sdk_version": {
                    "type": "string"
                }
            }
        },
        "tendermint.crypto.PublicKey": {
            "title": "PublicKey defines the keys available for use with Tendermint Validators",
            "type": "object",
            "properties": {
                "ed25519": {
                    "format": "byte",
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string"
                },
                "secp256k1": {
                    "format": "byte",
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string"
                }
            }
        },
        "tendermint.p2p.DefaultNodeInfo": {
            "type": "object",
            "properties": {
                "protocol_version": {
                    "type": "object",
                    "properties": {
                        "p2p": {
                            "format": "uint64",
                            "type": "string"
                        },
                        "block": {
                            "format": "uint64",
                            "type": "string"
                        },
                        "app": {
                            "format": "uint64",
                            "type": "string"
                        }
                    }
                },
                "default_node_id": {
                    "type": "string"
                },
                "listen_addr": {
                    "type": "string"
                },
                "network": {
                    "type": "string"
                },
                "version": {
                    "type": "string"
                },
                "channels": {
                    "format": "byte",
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string"
                },
                "moniker": {
                    "type": "string"
                },
                "other": {
                    "type": "object",
                    "properties": {
                        "tx_index": {
                            "type": "string"
                        },
                        "rpc_address": {
                            "type": "string"
                        }
                    }
                }
            }
        },
        "tendermint.p2p.DefaultNodeInfoOther": {
            "type": "object",
            "properties": {
                "tx_index": {
                    "type": "string"
                },
                "rpc_address": {
                    "type": "string"
                }
            }
        },
        "tendermint.p2p.ProtocolVersion": {
            "type": "object",
            "properties": {
                "p2p": {
                    "format": "uint64",
                    "type": "string"
                },
                "block": {
                    "format": "uint64",
                    "type": "string"
                },
                "app": {
                    "format": "uint64",
                    "type": "string"
                }
            }
        },
        "tendermint.types.Block": {
            "type": "object",
            "properties": {
                "header": {
                    "description": "Header defines the structure of a Tendermint block header.",
                    "type": "object",
                    "properties": {
                        "version": {
                            "title": "basic block info",
                            "description": "Consensus captures the consensus rules for processing a block in the blockchain,\nincluding all blockchain data structures and the rules of the application's\nstate transition machine.",
                            "type": "object",
                            "properties": {
                                "block": {
                                    "format": "uint64",
                                    "type": "string"
                                },
                                "app": {
                                    "format": "uint64",
                                    "type": "string"
                                }
                            }
                        },
                        "chain_id": {
                            "type": "string"
                        },
                        "height": {
                            "format": "int64",
                            "type": "string"
                        },
                        "time": {
                            "format": "date-time",
                            "type": "string"
                        },
                        "last_block_id": {
                            "title": "BlockID",
                            "type": "object",
                            "properties": {
                                "hash": {
                                    "format": "byte",
                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                    "type": "string"
                                },
                                "part_set_header": {
                                    "title": "PartsetHeader",
                                    "type": "object",
                                    "properties": {
                                        "total": {
                                            "format": "int64",
                                            "type": "integer"
                                        },
                                        "hash": {
                                            "format": "byte",
                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                            "type": "string"
                                        }
                                    }
                                }
                            }
                        },
                        "last_commit_hash": {
                            "format": "byte",
                            "title": "hashes of block data",
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string"
                        },
                        "data_hash": {
                            "format": "byte",
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string"
                        },
                        "validators_hash": {
                            "format": "byte",
                            "title": "hashes from the app output from the prev block",
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string"
                        },
                        "next_validators_hash": {
                            "format": "byte",
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string"
                        },
                        "consensus_hash": {
                            "format": "byte",
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string"
                        },
                        "app_hash": {
                            "format": "byte",
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string"
                        },
                        "last_results_hash": {
                            "format": "byte",
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string"
                        },
                        "evidence_hash": {
                            "format": "byte",
                            "title": "consensus info",
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string"
                        },
                        "proposer_address": {
                            "format": "byte",
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string"
                        }
                    }
                },
                "data": {
                    "title": "Data contains the set of transactions included in the block",
                    "type": "object",
                    "properties": {
                        "txs": {
                            "description": "Txs that will be applied by state @ block.Height+1.\nNOTE: not all txs here are valid.  We're just agreeing on the order first.\nThis means that block.AppHash does not include these txs.",
                            "type": "array",
                            "items": {
                                "format": "byte",
                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                "type": "string"
                            }
                        }
                    }
                },
                "evidence": {
                    "type": "object",
                    "properties": {
                        "evidence": {
                            "type": "array",
                            "items": {
                                "type": "object",
                                "properties": {
                                    "duplicate_vote_evidence": {
                                        "description": "DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes.",
                                        "type": "object",
                                        "properties": {
                                            "vote_a": {
                                                "description": "Vote represents a prevote, precommit, or commit vote from validators for\nconsensus.",
                                                "type": "object",
                                                "properties": {
                                                    "type": {
                                                        "description": "SignedMsgType is a type of signed message in the consensus.\n\n - SIGNED_MSG_TYPE_PREVOTE: Votes\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals",
                                                        "default": "SIGNED_MSG_TYPE_UNKNOWN",
                                                        "enum": [
                                                            "SIGNED_MSG_TYPE_UNKNOWN",
                                                            "SIGNED_MSG_TYPE_PREVOTE",
                                                            "SIGNED_MSG_TYPE_PRECOMMIT",
                                                            "SIGNED_MSG_TYPE_PROPOSAL"
                                                        ],
                                                        "type": "string"
                                                    },
                                                    "height": {
                                                        "format": "int64",
                                                        "type": "string"
                                                    },
                                                    "round": {
                                                        "format": "int32",
                                                        "type": "integer"
                                                    },
                                                    "block_id": {
                                                        "title": "BlockID",
                                                        "type": "object",
                                                        "properties": {
                                                            "hash": {
                                                                "format": "byte",
                                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                "type": "string"
                                                            },
                                                            "part_set_header": {
                                                                "title": "PartsetHeader",
                                                                "type": "object",
                                                                "properties": {
                                                                    "total": {
                                                                        "format": "int64",
                                                                        "type": "integer"
                                                                    },
                                                                    "hash": {
                                                                        "format": "byte",
                                                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                        "type": "string"
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    },
                                                    "timestamp": {
                                                        "format": "date-time",
                                                        "type": "string"
                                                    },
                                                    "validator_address": {
                                                        "format": "byte",
                                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                        "type": "string"
                                                    },
                                                    "validator_index": {
                                                        "format": "int32",
                                                        "type": "integer"
                                                    },
                                                    "signature": {
                                                        "format": "byte",
                                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                        "type": "string"
                                                    }
                                                }
                                            },
                                            "vote_b": {
                                                "description": "Vote represents a prevote, precommit, or commit vote from validators for\nconsensus.",
                                                "type": "object",
                                                "properties": {
                                                    "type": {
                                                        "description": "SignedMsgType is a type of signed message in the consensus.\n\n - SIGNED_MSG_TYPE_PREVOTE: Votes\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals",
                                                        "default": "SIGNED_MSG_TYPE_UNKNOWN",
                                                        "enum": [
                                                            "SIGNED_MSG_TYPE_UNKNOWN",
                                                            "SIGNED_MSG_TYPE_PREVOTE",
                                                            "SIGNED_MSG_TYPE_PRECOMMIT",
                                                            "SIGNED_MSG_TYPE_PROPOSAL"
                                                        ],
                                                        "type": "string"
                                                    },
                                                    "height": {
                                                        "format": "int64",
                                                        "type": "string"
                                                    },
                                                    "round": {
                                                        "format": "int32",
                                                        "type": "integer"
                                                    },
                                                    "block_id": {
                                                        "title": "BlockID",
                                                        "type": "object",
                                                        "properties": {
                                                            "hash": {
                                                                "format": "byte",
                                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                "type": "string"
                                                            },
                                                            "part_set_header": {
                                                                "title": "PartsetHeader",
                                                                "type": "object",
                                                                "properties": {
                                                                    "total": {
                                                                        "format": "int64",
                                                                        "type": "integer"
                                                                    },
                                                                    "hash": {
                                                                        "format": "byte",
                                                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                        "type": "string"
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    },
                                                    "timestamp": {
                                                        "format": "date-time",
                                                        "type": "string"
                                                    },
                                                    "validator_address": {
                                                        "format": "byte",
                                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                        "type": "string"
                                                    },
                                                    "validator_index": {
                                                        "format": "int32",
                                                        "type": "integer"
                                                    },
                                                    "signature": {
                                                        "format": "byte",
                                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                        "type": "string"
                                                    }
                                                }
                                            },
                                            "total_voting_power": {
                                                "format": "int64",
                                                "type": "string"
                                            },
                                            "validator_power": {
                                                "format": "int64",
                                                "type": "string"
                                            },
                                            "timestamp": {
                                                "format": "date-time",
                                                "type": "string"
                                            }
                                        }
                                    },
                                    "light_client_attack_evidence": {
                                        "description": "LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client.",
                                        "type": "object",
                                        "properties": {
                                            "conflicting_block": {
                                                "type": "object",
                                                "properties": {
                                                    "signed_header": {
                                                        "type": "object",
                                                        "properties": {
                                                            "header": {
                                                                "description": "Header defines the structure of a Tendermint block header.",
                                                                "type": "object",
                                                                "properties": {
                                                                    "version": {
                                                                        "title": "basic block info",
                                                                        "description": "Consensus captures the consensus rules for processing a block in the blockchain,\nincluding all blockchain data structures and the rules of the application's\nstate transition machine.",
                                                                        "type": "object",
                                                                        "properties": {
                                                                            "block": {
                                                                                "format": "uint64",
                                                                                "type": "string"
                                                                            },
                                                                            "app": {
                                                                                "format": "uint64",
                                                                                "type": "string"
                                                                            }
                                                                        }
                                                                    },
                                                                    "chain_id": {
                                                                        "type": "string"
                                                                    },
                                                                    "height": {
                                                                        "format": "int64",
                                                                        "type": "string"
                                                                    },
                                                                    "time": {
                                                                        "format": "date-time",
                                                                        "type": "string"
                                                                    },
                                                                    "last_block_id": {
                                                                        "title": "BlockID",
                                                                        "type": "object",
                                                                        "properties": {
                                                                            "hash": {
                                                                                "format": "byte",
                                                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                "type": "string"
                                                                            },
                                                                            "part_set_header": {
                                                                                "title": "PartsetHeader",
                                                                                "type": "object",
                                                                                "properties": {
                                                                                    "total": {
                                                                                        "format": "int64",
                                                                                        "type": "integer"
                                                                                    },
                                                                                    "hash": {
                                                                                        "format": "byte",
                                                                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                        "type": "string"
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    },
                                                                    "last_commit_hash": {
                                                                        "format": "byte",
                                                                        "title": "hashes of block data",
                                                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                        "type": "string"
                                                                    },
                                                                    "data_hash": {
                                                                        "format": "byte",
                                                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                        "type": "string"
                                                                    },
                                                                    "validators_hash": {
                                                                        "format": "byte",
                                                                        "title": "hashes from the app output from the prev block",
                                                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                        "type": "string"
                                                                    },
                                                                    "next_validators_hash": {
                                                                        "format": "byte",
                                                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                        "type": "string"
                                                                    },
                                                                    "consensus_hash": {
                                                                        "format": "byte",
                                                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                        "type": "string"
                                                                    },
                                                                    "app_hash": {
                                                                        "format": "byte",
                                                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                        "type": "string"
                                                                    },
                                                                    "last_results_hash": {
                                                                        "format": "byte",
                                                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                        "type": "string"
                                                                    },
                                                                    "evidence_hash": {
                                                                        "format": "byte",
                                                                        "title": "consensus info",
                                                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                        "type": "string"
                                                                    },
                                                                    "proposer_address": {
                                                                        "format": "byte",
                                                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                        "type": "string"
                                                                    }
                                                                }
                                                            },
                                                            "commit": {
                                                                "description": "Commit contains the evidence that a block was committed by a set of validators.",
                                                                "type": "object",
                                                                "properties": {
                                                                    "height": {
                                                                        "format": "int64",
                                                                        "type": "string"
                                                                    },
                                                                    "round": {
                                                                        "format": "int32",
                                                                        "type": "integer"
                                                                    },
                                                                    "block_id": {
                                                                        "title": "BlockID",
                                                                        "type": "object",
                                                                        "properties": {
                                                                            "hash": {
                                                                                "format": "byte",
                                                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                "type": "string"
                                                                            },
                                                                            "part_set_header": {
                                                                                "title": "PartsetHeader",
                                                                                "type": "object",
                                                                                "properties": {
                                                                                    "total": {
                                                                                        "format": "int64",
                                                                                        "type": "integer"
                                                                                    },
                                                                                    "hash": {
                                                                                        "format": "byte",
                                                                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                        "type": "string"
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    },
                                                                    "signatures": {
                                                                        "type": "array",
                                                                        "items": {
                                                                            "description": "CommitSig is a part of the Vote included in a Commit.",
                                                                            "type": "object",
                                                                            "properties": {
                                                                                "block_id_flag": {
                                                                                    "title": "BlockIdFlag indicates which BlcokID the signature is for",
                                                                                    "default": "BLOCK_ID_FLAG_UNKNOWN",
                                                                                    "enum": [
                                                                                        "BLOCK_ID_FLAG_UNKNOWN",
                                                                                        "BLOCK_ID_FLAG_ABSENT",
                                                                                        "BLOCK_ID_FLAG_COMMIT",
                                                                                        "BLOCK_ID_FLAG_NIL"
                                                                                    ],
                                                                                    "type": "string"
                                                                                },
                                                                                "validator_address": {
                                                                                    "format": "byte",
                                                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                    "type": "string"
                                                                                },
                                                                                "timestamp": {
                                                                                    "format": "date-time",
                                                                                    "type": "string"
                                                                                },
                                                                                "signature": {
                                                                                    "format": "byte",
                                                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                    "type": "string"
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    },
                                                    "validator_set": {
                                                        "type": "object",
                                                        "properties": {
                                                            "validators": {
                                                                "type": "array",
                                                                "items": {
                                                                    "type": "object",
                                                                    "properties": {
                                                                        "address": {
                                                                            "format": "byte",
                                                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                            "type": "string"
                                                                        },
                                                                        "pub_key": {
                                                                            "title": "PublicKey defines the keys available for use with Tendermint Validators",
                                                                            "type": "object",
                                                                            "properties": {
                                                                                "ed25519": {
                                                                                    "format": "byte",
                                                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                    "type": "string"
                                                                                },
                                                                                "secp256k1": {
                                                                                    "format": "byte",
                                                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                    "type": "string"
                                                                                }
                                                                            }
                                                                        },
                                                                        "voting_power": {
                                                                            "format": "int64",
                                                                            "type": "string"
                                                                        },
                                                                        "proposer_priority": {
                                                                            "format": "int64",
                                                                            "type": "string"
                                                                        }
                                                                    }
                                                                }
                                                            },
                                                            "proposer": {
                                                                "type": "object",
                                                                "properties": {
                                                                    "address": {
                                                                        "format": "byte",
                                                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                        "type": "string"
                                                                    },
                                                                    "pub_key": {
                                                                        "title": "PublicKey defines the keys available for use with Tendermint Validators",
                                                                        "type": "object",
                                                                        "properties": {
                                                                            "ed25519": {
                                                                                "format": "byte",
                                                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                "type": "string"
                                                                            },
                                                                            "secp256k1": {
                                                                                "format": "byte",
                                                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                "type": "string"
                                                                            }
                                                                        }
                                                                    },
                                                                    "voting_power": {
                                                                        "format": "int64",
                                                                        "type": "string"
                                                                    },
                                                                    "proposer_priority": {
                                                                        "format": "int64",
                                                                        "type": "string"
                                                                    }
                                                                }
                                                            },
                                                            "total_voting_power": {
                                                                "format": "int64",
                                                                "type": "string"
                                                            }
                                                        }
                                                    }
                                                }
                                            },
                                            "common_height": {
                                                "format": "int64",
                                                "type": "string"
                                            },
                                            "byzantine_validators": {
                                                "type": "array",
                                                "items": {
                                                    "type": "object",
                                                    "properties": {
                                                        "address": {
                                                            "format": "byte",
                                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                            "type": "string"
                                                        },
                                                        "pub_key": {
                                                            "title": "PublicKey defines the keys available for use with Tendermint Validators",
                                                            "type": "object",
                                                            "properties": {
                                                                "ed25519": {
                                                                    "format": "byte",
                                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                    "type": "string"
                                                                },
                                                                "secp256k1": {
                                                                    "format": "byte",
                                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                    "type": "string"
                                                                }
                                                            }
                                                        },
                                                        "voting_power": {
                                                            "format": "int64",
                                                            "type": "string"
                                                        },
                                                        "proposer_priority": {
                                                            "format": "int64",
                                                            "type": "string"
                                                        }
                                                    }
                                                }
                                            },
                                            "total_voting_power": {
                                                "format": "int64",
                                                "type": "string"
                                            },
                                            "timestamp": {
                                                "format": "date-time",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                },
                "last_commit": {
                    "description": "Commit contains the evidence that a block was committed by a set of validators.",
                    "type": "object",
                    "properties": {
                        "height": {
                            "format": "int64",
                            "type": "string"
                        },
                        "round": {
                            "format": "int32",
                            "type": "integer"
                        },
                        "block_id": {
                            "title": "BlockID",
                            "type": "object",
                            "properties": {
                                "hash": {
                                    "format": "byte",
                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                    "type": "string"
                                },
                                "part_set_header": {
                                    "title": "PartsetHeader",
                                    "type": "object",
                                    "properties": {
                                        "total": {
                                            "format": "int64",
                                            "type": "integer"
                                        },
                                        "hash": {
                                            "format": "byte",
                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                            "type": "string"
                                        }
                                    }
                                }
                            }
                        },
                        "signatures": {
                            "type": "array",
                            "items": {
                                "description": "CommitSig is a part of the Vote included in a Commit.",
                                "type": "object",
                                "properties": {
                                    "block_id_flag": {
                                        "title": "BlockIdFlag indicates which BlcokID the signature is for",
                                        "default": "BLOCK_ID_FLAG_UNKNOWN",
                                        "enum": [
                                            "BLOCK_ID_FLAG_UNKNOWN",
                                            "BLOCK_ID_FLAG_ABSENT",
                                            "BLOCK_ID_FLAG_COMMIT",
                                            "BLOCK_ID_FLAG_NIL"
                                        ],
                                        "type": "string"
                                    },
                                    "validator_address": {
                                        "format": "byte",
                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                        "type": "string"
                                    },
                                    "timestamp": {
                                        "format": "date-time",
                                        "type": "string"
                                    },
                                    "signature": {
                                        "format": "byte",
                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                        "type": "string"
                                    }
                                }
                            }
                        }
                    }
                }
            }
        },
        "tendermint.types.BlockID": {
            "title": "BlockID",
            "type": "object",
            "properties": {
                "hash": {
                    "format": "byte",
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string"
                },
                "part_set_header": {
                    "title": "PartsetHeader",
                    "type": "object",
                    "properties": {
                        "total": {
                            "format": "int64",
                            "type": "integer"
                        },
                        "hash": {
                            "format": "byte",
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string"
                        }
                    }
                }
            }
        },
        "tendermint.types.BlockIDFlag": {
            "title": "BlockIdFlag indicates which BlcokID the signature is for",
            "default": "BLOCK_ID_FLAG_UNKNOWN",
            "enum": [
                "BLOCK_ID_FLAG_UNKNOWN",
                "BLOCK_ID_FLAG_ABSENT",
                "BLOCK_ID_FLAG_COMMIT",
                "BLOCK_ID_FLAG_NIL"
            ],
            "type": "string"
        },
        "tendermint.types.Commit": {
            "description": "Commit contains the evidence that a block was committed by a set of validators.",
            "type": "object",
            "properties": {
                "height": {
                    "format": "int64",
                    "type": "string"
                },
                "round": {
                    "format": "int32",
                    "type": "integer"
                },
                "block_id": {
                    "title": "BlockID",
                    "type": "object",
                    "properties": {
                        "hash": {
                            "format": "byte",
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string"
                        },
                        "part_set_header": {
                            "title": "PartsetHeader",
                            "type": "object",
                            "properties": {
                                "total": {
                                    "format": "int64",
                                    "type": "integer"
                                },
                                "hash": {
                                    "format": "byte",
                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                    "type": "string"
                                }
                            }
                        }
                    }
                },
                "signatures": {
                    "type": "array",
                    "items": {
                        "description": "CommitSig is a part of the Vote included in a Commit.",
                        "type": "object",
                        "properties": {
                            "block_id_flag": {
                                "title": "BlockIdFlag indicates which BlcokID the signature is for",
                                "default": "BLOCK_ID_FLAG_UNKNOWN",
                                "enum": [
                                    "BLOCK_ID_FLAG_UNKNOWN",
                                    "BLOCK_ID_FLAG_ABSENT",
                                    "BLOCK_ID_FLAG_COMMIT",
                                    "BLOCK_ID_FLAG_NIL"
                                ],
                                "type": "string"
                            },
                            "validator_address": {
                                "format": "byte",
                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                "type": "string"
                            },
                            "timestamp": {
                                "format": "date-time",
                                "type": "string"
                            },
                            "signature": {
                                "format": "byte",
                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                "type": "string"
                            }
                        }
                    }
                }
            }
        },
        "tendermint.types.CommitSig": {
            "description": "CommitSig is a part of the Vote included in a Commit.",
            "type": "object",
            "properties": {
                "block_id_flag": {
                    "title": "BlockIdFlag indicates which BlcokID the signature is for",
                    "default": "BLOCK_ID_FLAG_UNKNOWN",
                    "enum": [
                        "BLOCK_ID_FLAG_UNKNOWN",
                        "BLOCK_ID_FLAG_ABSENT",
                        "BLOCK_ID_FLAG_COMMIT",
                        "BLOCK_ID_FLAG_NIL"
                    ],
                    "type": "string"
                },
                "validator_address": {
                    "format": "byte",
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string"
                },
                "timestamp": {
                    "format": "date-time",
                    "type": "string"
                },
                "signature": {
                    "format": "byte",
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string"
                }
            }
        },
        "tendermint.types.Data": {
            "title": "Data contains the set of transactions included in the block",
            "type": "object",
            "properties": {
                "txs": {
                    "description": "Txs that will be applied by state @ block.Height+1.\nNOTE: not all txs here are valid.  We're just agreeing on the order first.\nThis means that block.AppHash does not include these txs.",
                    "type": "array",
                    "items": {
                        "format": "byte",
                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                        "type": "string"
                    }
                }
            }
        },
        "tendermint.types.DuplicateVoteEvidence": {
            "description": "DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes.",
            "type": "object",
            "properties": {
                "vote_a": {
                    "description": "Vote represents a prevote, precommit, or commit vote from validators for\nconsensus.",
                    "type": "object",
                    "properties": {
                        "type": {
                            "description": "SignedMsgType is a type of signed message in the consensus.\n\n - SIGNED_MSG_TYPE_PREVOTE: Votes\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals",
                            "default": "SIGNED_MSG_TYPE_UNKNOWN",
                            "enum": [
                                "SIGNED_MSG_TYPE_UNKNOWN",
                                "SIGNED_MSG_TYPE_PREVOTE",
                                "SIGNED_MSG_TYPE_PRECOMMIT",
                                "SIGNED_MSG_TYPE_PROPOSAL"
                            ],
                            "type": "string"
                        },
                        "height": {
                            "format": "int64",
                            "type": "string"
                        },
                        "round": {
                            "format": "int32",
                            "type": "integer"
                        },
                        "block_id": {
                            "title": "BlockID",
                            "type": "object",
                            "properties": {
                                "hash": {
                                    "format": "byte",
                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                    "type": "string"
                                },
                                "part_set_header": {
                                    "title": "PartsetHeader",
                                    "type": "object",
                                    "properties": {
                                        "total": {
                                            "format": "int64",
                                            "type": "integer"
                                        },
                                        "hash": {
                                            "format": "byte",
                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                            "type": "string"
                                        }
                                    }
                                }
                            }
                        },
                        "timestamp": {
                            "format": "date-time",
                            "type": "string"
                        },
                        "validator_address": {
                            "format": "byte",
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string"
                        },
                        "validator_index": {
                            "format": "int32",
                            "type": "integer"
                        },
                        "signature": {
                            "format": "byte",
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string"
                        }
                    }
                },
                "vote_b": {
                    "description": "Vote represents a prevote, precommit, or commit vote from validators for\nconsensus.",
                    "type": "object",
                    "properties": {
                        "type": {
                            "description": "SignedMsgType is a type of signed message in the consensus.\n\n - SIGNED_MSG_TYPE_PREVOTE: Votes\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals",
                            "default": "SIGNED_MSG_TYPE_UNKNOWN",
                            "enum": [
                                "SIGNED_MSG_TYPE_UNKNOWN",
                                "SIGNED_MSG_TYPE_PREVOTE",
                                "SIGNED_MSG_TYPE_PRECOMMIT",
                                "SIGNED_MSG_TYPE_PROPOSAL"
                            ],
                            "type": "string"
                        },
                        "height": {
                            "format": "int64",
                            "type": "string"
                        },
                        "round": {
                            "format": "int32",
                            "type": "integer"
                        },
                        "block_id": {
                            "title": "BlockID",
                            "type": "object",
                            "properties": {
                                "hash": {
                                    "format": "byte",
                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                    "type": "string"
                                },
                                "part_set_header": {
                                    "title": "PartsetHeader",
                                    "type": "object",
                                    "properties": {
                                        "total": {
                                            "format": "int64",
                                            "type": "integer"
                                        },
                                        "hash": {
                                            "format": "byte",
                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                            "type": "string"
                                        }
                                    }
                                }
                            }
                        },
                        "timestamp": {
                            "format": "date-time",
                            "type": "string"
                        },
                        "validator_address": {
                            "format": "byte",
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string"
                        },
                        "validator_index": {
                            "format": "int32",
                            "type": "integer"
                        },
                        "signature": {
                            "format": "byte",
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string"
                        }
                    }
                },
                "total_voting_power": {
                    "format": "int64",
                    "type": "string"
                },
                "validator_power": {
                    "format": "int64",
                    "type": "string"
                },
                "timestamp": {
                    "format": "date-time",
                    "type": "string"
                }
            }
        },
        "tendermint.types.Evidence": {
            "type": "object",
            "properties": {
                "duplicate_vote_evidence": {
                    "description": "DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes.",
                    "type": "object",
                    "properties": {
                        "vote_a": {
                            "description": "Vote represents a prevote, precommit, or commit vote from validators for\nconsensus.",
                            "type": "object",
                            "properties": {
                                "type": {
                                    "description": "SignedMsgType is a type of signed message in the consensus.\n\n - SIGNED_MSG_TYPE_PREVOTE: Votes\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals",
                                    "default": "SIGNED_MSG_TYPE_UNKNOWN",
                                    "enum": [
                                        "SIGNED_MSG_TYPE_UNKNOWN",
                                        "SIGNED_MSG_TYPE_PREVOTE",
                                        "SIGNED_MSG_TYPE_PRECOMMIT",
                                        "SIGNED_MSG_TYPE_PROPOSAL"
                                    ],
                                    "type": "string"
                                },
                                "height": {
                                    "format": "int64",
                                    "type": "string"
                                },
                                "round": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "block_id": {
                                    "title": "BlockID",
                                    "type": "object",
                                    "properties": {
                                        "hash": {
                                            "format": "byte",
                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                            "type": "string"
                                        },
                                        "part_set_header": {
                                            "title": "PartsetHeader",
                                            "type": "object",
                                            "properties": {
                                                "total": {
                                                    "format": "int64",
                                                    "type": "integer"
                                                },
                                                "hash": {
                                                    "format": "byte",
                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                    "type": "string"
                                                }
                                            }
                                        }
                                    }
                                },
                                "timestamp": {
                                    "format": "date-time",
                                    "type": "string"
                                },
                                "validator_address": {
                                    "format": "byte",
                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                    "type": "string"
                                },
                                "validator_index": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "signature": {
                                    "format": "byte",
                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                    "type": "string"
                                }
                            }
                        },
                        "vote_b": {
                            "description": "Vote represents a prevote, precommit, or commit vote from validators for\nconsensus.",
                            "type": "object",
                            "properties": {
                                "type": {
                                    "description": "SignedMsgType is a type of signed message in the consensus.\n\n - SIGNED_MSG_TYPE_PREVOTE: Votes\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals",
                                    "default": "SIGNED_MSG_TYPE_UNKNOWN",
                                    "enum": [
                                        "SIGNED_MSG_TYPE_UNKNOWN",
                                        "SIGNED_MSG_TYPE_PREVOTE",
                                        "SIGNED_MSG_TYPE_PRECOMMIT",
                                        "SIGNED_MSG_TYPE_PROPOSAL"
                                    ],
                                    "type": "string"
                                },
                                "height": {
                                    "format": "int64",
                                    "type": "string"
                                },
                                "round": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "block_id": {
                                    "title": "BlockID",
                                    "type": "object",
                                    "properties": {
                                        "hash": {
                                            "format": "byte",
                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                            "type": "string"
                                        },
                                        "part_set_header": {
                                            "title": "PartsetHeader",
                                            "type": "object",
                                            "properties": {
                                                "total": {
                                                    "format": "int64",
                                                    "type": "integer"
                                                },
                                                "hash": {
                                                    "format": "byte",
                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                    "type": "string"
                                                }
                                            }
                                        }
                                    }
                                },
                                "timestamp": {
                                    "format": "date-time",
                                    "type": "string"
                                },
                                "validator_address": {
                                    "format": "byte",
                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                    "type": "string"
                                },
                                "validator_index": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "signature": {
                                    "format": "byte",
                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                    "type": "string"
                                }
                            }
                        },
                        "total_voting_power": {
                            "format": "int64",
                            "type": "string"
                        },
                        "validator_power": {
                            "format": "int64",
                            "type": "string"
                        },
                        "timestamp": {
                            "format": "date-time",
                            "type": "string"
                        }
                    }
                },
                "light_client_attack_evidence": {
                    "description": "LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client.",
                    "type": "object",
                    "properties": {
                        "conflicting_block": {
                            "type": "object",
                            "properties": {
                                "signed_header": {
                                    "type": "object",
                                    "properties": {
                                        "header": {
                                            "description": "Header defines the structure of a Tendermint block header.",
                                            "type": "object",
                                            "properties": {
                                                "version": {
                                                    "title": "basic block info",
                                                    "description": "Consensus captures the consensus rules for processing a block in the blockchain,\nincluding all blockchain data structures and the rules of the application's\nstate transition machine.",
                                                    "type": "object",
                                                    "properties": {
                                                        "block": {
                                                            "format": "uint64",
                                                            "type": "string"
                                                        },
                                                        "app": {
                                                            "format": "uint64",
                                                            "type": "string"
                                                        }
                                                    }
                                                },
                                                "chain_id": {
                                                    "type": "string"
                                                },
                                                "height": {
                                                    "format": "int64",
                                                    "type": "string"
                                                },
                                                "time": {
                                                    "format": "date-time",
                                                    "type": "string"
                                                },
                                                "last_block_id": {
                                                    "title": "BlockID",
                                                    "type": "object",
                                                    "properties": {
                                                        "hash": {
                                                            "format": "byte",
                                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                            "type": "string"
                                                        },
                                                        "part_set_header": {
                                                            "title": "PartsetHeader",
                                                            "type": "object",
                                                            "properties": {
                                                                "total": {
                                                                    "format": "int64",
                                                                    "type": "integer"
                                                                },
                                                                "hash": {
                                                                    "format": "byte",
                                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                    "type": "string"
                                                                }
                                                            }
                                                        }
                                                    }
                                                },
                                                "last_commit_hash": {
                                                    "format": "byte",
                                                    "title": "hashes of block data",
                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                    "type": "string"
                                                },
                                                "data_hash": {
                                                    "format": "byte",
                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                    "type": "string"
                                                },
                                                "validators_hash": {
                                                    "format": "byte",
                                                    "title": "hashes from the app output from the prev block",
                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                    "type": "string"
                                                },
                                                "next_validators_hash": {
                                                    "format": "byte",
                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                    "type": "string"
                                                },
                                                "consensus_hash": {
                                                    "format": "byte",
                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                    "type": "string"
                                                },
                                                "app_hash": {
                                                    "format": "byte",
                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                    "type": "string"
                                                },
                                                "last_results_hash": {
                                                    "format": "byte",
                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                    "type": "string"
                                                },
                                                "evidence_hash": {
                                                    "format": "byte",
                                                    "title": "consensus info",
                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                    "type": "string"
                                                },
                                                "proposer_address": {
                                                    "format": "byte",
                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                    "type": "string"
                                                }
                                            }
                                        },
                                        "commit": {
                                            "description": "Commit contains the evidence that a block was committed by a set of validators.",
                                            "type": "object",
                                            "properties": {
                                                "height": {
                                                    "format": "int64",
                                                    "type": "string"
                                                },
                                                "round": {
                                                    "format": "int32",
                                                    "type": "integer"
                                                },
                                                "block_id": {
                                                    "title": "BlockID",
                                                    "type": "object",
                                                    "properties": {
                                                        "hash": {
                                                            "format": "byte",
                                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                            "type": "string"
                                                        },
                                                        "part_set_header": {
                                                            "title": "PartsetHeader",
                                                            "type": "object",
                                                            "properties": {
                                                                "total": {
                                                                    "format": "int64",
                                                                    "type": "integer"
                                                                },
                                                                "hash": {
                                                                    "format": "byte",
                                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                    "type": "string"
                                                                }
                                                            }
                                                        }
                                                    }
                                                },
                                                "signatures": {
                                                    "type": "array",
                                                    "items": {
                                                        "description": "CommitSig is a part of the Vote included in a Commit.",
                                                        "type": "object",
                                                        "properties": {
                                                            "block_id_flag": {
                                                                "title": "BlockIdFlag indicates which BlcokID the signature is for",
                                                                "default": "BLOCK_ID_FLAG_UNKNOWN",
                                                                "enum": [
                                                                    "BLOCK_ID_FLAG_UNKNOWN",
                                                                    "BLOCK_ID_FLAG_ABSENT",
                                                                    "BLOCK_ID_FLAG_COMMIT",
                                                                    "BLOCK_ID_FLAG_NIL"
                                                                ],
                                                                "type": "string"
                                                            },
                                                            "validator_address": {
                                                                "format": "byte",
                                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                "type": "string"
                                                            },
                                                            "timestamp": {
                                                                "format": "date-time",
                                                                "type": "string"
                                                            },
                                                            "signature": {
                                                                "format": "byte",
                                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                "type": "string"
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                },
                                "validator_set": {
                                    "type": "object",
                                    "properties": {
                                        "validators": {
                                            "type": "array",
                                            "items": {
                                                "type": "object",
                                                "properties": {
                                                    "address": {
                                                        "format": "byte",
                                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                        "type": "string"
                                                    },
                                                    "pub_key": {
                                                        "title": "PublicKey defines the keys available for use with Tendermint Validators",
                                                        "type": "object",
                                                        "properties": {
                                                            "ed25519": {
                                                                "format": "byte",
                                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                "type": "string"
                                                            },
                                                            "secp256k1": {
                                                                "format": "byte",
                                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                "type": "string"
                                                            }
                                                        }
                                                    },
                                                    "voting_power": {
                                                        "format": "int64",
                                                        "type": "string"
                                                    },
                                                    "proposer_priority": {
                                                        "format": "int64",
                                                        "type": "string"
                                                    }
                                                }
                                            }
                                        },
                                        "proposer": {
                                            "type": "object",
                                            "properties": {
                                                "address": {
                                                    "format": "byte",
                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                    "type": "string"
                                                },
                                                "pub_key": {
                                                    "title": "PublicKey defines the keys available for use with Tendermint Validators",
                                                    "type": "object",
                                                    "properties": {
                                                        "ed25519": {
                                                            "format": "byte",
                                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                            "type": "string"
                                                        },
                                                        "secp256k1": {
                                                            "format": "byte",
                                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                            "type": "string"
                                                        }
                                                    }
                                                },
                                                "voting_power": {
                                                    "format": "int64",
                                                    "type": "string"
                                                },
                                                "proposer_priority": {
                                                    "format": "int64",
                                                    "type": "string"
                                                }
                                            }
                                        },
                                        "total_voting_power": {
                                            "format": "int64",
                                            "type": "string"
                                        }
                                    }
                                }
                            }
                        },
                        "common_height": {
                            "format": "int64",
                            "type": "string"
                        },
                        "byzantine_validators": {
                            "type": "array",
                            "items": {
                                "type": "object",
                                "properties": {
                                    "address": {
                                        "format": "byte",
                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                        "type": "string"
                                    },
                                    "pub_key": {
                                        "title": "PublicKey defines the keys available for use with Tendermint Validators",
                                        "type": "object",
                                        "properties": {
                                            "ed25519": {
                                                "format": "byte",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            },
                                            "secp256k1": {
                                                "format": "byte",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    },
                                    "voting_power": {
                                        "format": "int64",
                                        "type": "string"
                                    },
                                    "proposer_priority": {
                                        "format": "int64",
                                        "type": "string"
                                    }
                                }
                            }
                        },
                        "total_voting_power": {
                            "format": "int64",
                            "type": "string"
                        },
                        "timestamp": {
                            "format": "date-time",
                            "type": "string"
                        }
                    }
                }
            }
        },
        "tendermint.types.EvidenceList": {
            "type": "object",
            "properties": {
                "evidence": {
                    "type": "array",
                    "items": {
                        "type": "object",
                        "properties": {
                            "duplicate_vote_evidence": {
                                "description": "DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes.",
                                "type": "object",
                                "properties": {
                                    "vote_a": {
                                        "description": "Vote represents a prevote, precommit, or commit vote from validators for\nconsensus.",
                                        "type": "object",
                                        "properties": {
                                            "type": {
                                                "description": "SignedMsgType is a type of signed message in the consensus.\n\n - SIGNED_MSG_TYPE_PREVOTE: Votes\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals",
                                                "default": "SIGNED_MSG_TYPE_UNKNOWN",
                                                "enum": [
                                                    "SIGNED_MSG_TYPE_UNKNOWN",
                                                    "SIGNED_MSG_TYPE_PREVOTE",
                                                    "SIGNED_MSG_TYPE_PRECOMMIT",
                                                    "SIGNED_MSG_TYPE_PROPOSAL"
                                                ],
                                                "type": "string"
                                            },
                                            "height": {
                                                "format": "int64",
                                                "type": "string"
                                            },
                                            "round": {
                                                "format": "int32",
                                                "type": "integer"
                                            },
                                            "block_id": {
                                                "title": "BlockID",
                                                "type": "object",
                                                "properties": {
                                                    "hash": {
                                                        "format": "byte",
                                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                        "type": "string"
                                                    },
                                                    "part_set_header": {
                                                        "title": "PartsetHeader",
                                                        "type": "object",
                                                        "properties": {
                                                            "total": {
                                                                "format": "int64",
                                                                "type": "integer"
                                                            },
                                                            "hash": {
                                                                "format": "byte",
                                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                "type": "string"
                                                            }
                                                        }
                                                    }
                                                }
                                            },
                                            "timestamp": {
                                                "format": "date-time",
                                                "type": "string"
                                            },
                                            "validator_address": {
                                                "format": "byte",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            },
                                            "validator_index": {
                                                "format": "int32",
                                                "type": "integer"
                                            },
                                            "signature": {
                                                "format": "byte",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    },
                                    "vote_b": {
                                        "description": "Vote represents a prevote, precommit, or commit vote from validators for\nconsensus.",
                                        "type": "object",
                                        "properties": {
                                            "type": {
                                                "description": "SignedMsgType is a type of signed message in the consensus.\n\n - SIGNED_MSG_TYPE_PREVOTE: Votes\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals",
                                                "default": "SIGNED_MSG_TYPE_UNKNOWN",
                                                "enum": [
                                                    "SIGNED_MSG_TYPE_UNKNOWN",
                                                    "SIGNED_MSG_TYPE_PREVOTE",
                                                    "SIGNED_MSG_TYPE_PRECOMMIT",
                                                    "SIGNED_MSG_TYPE_PROPOSAL"
                                                ],
                                                "type": "string"
                                            },
                                            "height": {
                                                "format": "int64",
                                                "type": "string"
                                            },
                                            "round": {
                                                "format": "int32",
                                                "type": "integer"
                                            },
                                            "block_id": {
                                                "title": "BlockID",
                                                "type": "object",
                                                "properties": {
                                                    "hash": {
                                                        "format": "byte",
                                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                        "type": "string"
                                                    },
                                                    "part_set_header": {
                                                        "title": "PartsetHeader",
                                                        "type": "object",
                                                        "properties": {
                                                            "total": {
                                                                "format": "int64",
                                                                "type": "integer"
                                                            },
                                                            "hash": {
                                                                "format": "byte",
                                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                "type": "string"
                                                            }
                                                        }
                                                    }
                                                }
                                            },
                                            "timestamp": {
                                                "format": "date-time",
                                                "type": "string"
                                            },
                                            "validator_address": {
                                                "format": "byte",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            },
                                            "validator_index": {
                                                "format": "int32",
                                                "type": "integer"
                                            },
                                            "signature": {
                                                "format": "byte",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    },
                                    "total_voting_power": {
                                        "format": "int64",
                                        "type": "string"
                                    },
                                    "validator_power": {
                                        "format": "int64",
                                        "type": "string"
                                    },
                                    "timestamp": {
                                        "format": "date-time",
                                        "type": "string"
                                    }
                                }
                            },
                            "light_client_attack_evidence": {
                                "description": "LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client.",
                                "type": "object",
                                "properties": {
                                    "conflicting_block": {
                                        "type": "object",
                                        "properties": {
                                            "signed_header": {
                                                "type": "object",
                                                "properties": {
                                                    "header": {
                                                        "description": "Header defines the structure of a Tendermint block header.",
                                                        "type": "object",
                                                        "properties": {
                                                            "version": {
                                                                "title": "basic block info",
                                                                "description": "Consensus captures the consensus rules for processing a block in the blockchain,\nincluding all blockchain data structures and the rules of the application's\nstate transition machine.",
                                                                "type": "object",
                                                                "properties": {
                                                                    "block": {
                                                                        "format": "uint64",
                                                                        "type": "string"
                                                                    },
                                                                    "app": {
                                                                        "format": "uint64",
                                                                        "type": "string"
                                                                    }
                                                                }
                                                            },
                                                            "chain_id": {
                                                                "type": "string"
                                                            },
                                                            "height": {
                                                                "format": "int64",
                                                                "type": "string"
                                                            },
                                                            "time": {
                                                                "format": "date-time",
                                                                "type": "string"
                                                            },
                                                            "last_block_id": {
                                                                "title": "BlockID",
                                                                "type": "object",
                                                                "properties": {
                                                                    "hash": {
                                                                        "format": "byte",
                                                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                        "type": "string"
                                                                    },
                                                                    "part_set_header": {
                                                                        "title": "PartsetHeader",
                                                                        "type": "object",
                                                                        "properties": {
                                                                            "total": {
                                                                                "format": "int64",
                                                                                "type": "integer"
                                                                            },
                                                                            "hash": {
                                                                                "format": "byte",
                                                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                "type": "string"
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            },
                                                            "last_commit_hash": {
                                                                "format": "byte",
                                                                "title": "hashes of block data",
                                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                "type": "string"
                                                            },
                                                            "data_hash": {
                                                                "format": "byte",
                                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                "type": "string"
                                                            },
                                                            "validators_hash": {
                                                                "format": "byte",
                                                                "title": "hashes from the app output from the prev block",
                                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                "type": "string"
                                                            },
                                                            "next_validators_hash": {
                                                                "format": "byte",
                                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                "type": "string"
                                                            },
                                                            "consensus_hash": {
                                                                "format": "byte",
                                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                "type": "string"
                                                            },
                                                            "app_hash": {
                                                                "format": "byte",
                                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                "type": "string"
                                                            },
                                                            "last_results_hash": {
                                                                "format": "byte",
                                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                "type": "string"
                                                            },
                                                            "evidence_hash": {
                                                                "format": "byte",
                                                                "title": "consensus info",
                                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                "type": "string"
                                                            },
                                                            "proposer_address": {
                                                                "format": "byte",
                                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                "type": "string"
                                                            }
                                                        }
                                                    },
                                                    "commit": {
                                                        "description": "Commit contains the evidence that a block was committed by a set of validators.",
                                                        "type": "object",
                                                        "properties": {
                                                            "height": {
                                                                "format": "int64",
                                                                "type": "string"
                                                            },
                                                            "round": {
                                                                "format": "int32",
                                                                "type": "integer"
                                                            },
                                                            "block_id": {
                                                                "title": "BlockID",
                                                                "type": "object",
                                                                "properties": {
                                                                    "hash": {
                                                                        "format": "byte",
                                                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                        "type": "string"
                                                                    },
                                                                    "part_set_header": {
                                                                        "title": "PartsetHeader",
                                                                        "type": "object",
                                                                        "properties": {
                                                                            "total": {
                                                                                "format": "int64",
                                                                                "type": "integer"
                                                                            },
                                                                            "hash": {
                                                                                "format": "byte",
                                                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                                "type": "string"
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            },
                                                            "signatures": {
                                                                "type": "array",
                                                                "items": {
                                                                    "description": "CommitSig is a part of the Vote included in a Commit.",
                                                                    "type": "object",
                                                                    "properties": {
                                                                        "block_id_flag": {
                                                                            "title": "BlockIdFlag indicates which BlcokID the signature is for",
                                                                            "default": "BLOCK_ID_FLAG_UNKNOWN",
                                                                            "enum": [
                                                                                "BLOCK_ID_FLAG_UNKNOWN",
                                                                                "BLOCK_ID_FLAG_ABSENT",
                                                                                "BLOCK_ID_FLAG_COMMIT",
                                                                                "BLOCK_ID_FLAG_NIL"
                                                                            ],
                                                                            "type": "string"
                                                                        },
                                                                        "validator_address": {
                                                                            "format": "byte",
                                                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                            "type": "string"
                                                                        },
                                                                        "timestamp": {
                                                                            "format": "date-time",
                                                                            "type": "string"
                                                                        },
                                                                        "signature": {
                                                                            "format": "byte",
                                                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                            "type": "string"
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            },
                                            "validator_set": {
                                                "type": "object",
                                                "properties": {
                                                    "validators": {
                                                        "type": "array",
                                                        "items": {
                                                            "type": "object",
                                                            "properties": {
                                                                "address": {
                                                                    "format": "byte",
                                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                    "type": "string"
                                                                },
                                                                "pub_key": {
                                                                    "title": "PublicKey defines the keys available for use with Tendermint Validators",
                                                                    "type": "object",
                                                                    "properties": {
                                                                        "ed25519": {
                                                                            "format": "byte",
                                                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                            "type": "string"
                                                                        },
                                                                        "secp256k1": {
                                                                            "format": "byte",
                                                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                            "type": "string"
                                                                        }
                                                                    }
                                                                },
                                                                "voting_power": {
                                                                    "format": "int64",
                                                                    "type": "string"
                                                                },
                                                                "proposer_priority": {
                                                                    "format": "int64",
                                                                    "type": "string"
                                                                }
                                                            }
                                                        }
                                                    },
                                                    "proposer": {
                                                        "type": "object",
                                                        "properties": {
                                                            "address": {
                                                                "format": "byte",
                                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                "type": "string"
                                                            },
                                                            "pub_key": {
                                                                "title": "PublicKey defines the keys available for use with Tendermint Validators",
                                                                "type": "object",
                                                                "properties": {
                                                                    "ed25519": {
                                                                        "format": "byte",
                                                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                        "type": "string"
                                                                    },
                                                                    "secp256k1": {
                                                                        "format": "byte",
                                                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                                        "type": "string"
                                                                    }
                                                                }
                                                            },
                                                            "voting_power": {
                                                                "format": "int64",
                                                                "type": "string"
                                                            },
                                                            "proposer_priority": {
                                                                "format": "int64",
                                                                "type": "string"
                                                            }
                                                        }
                                                    },
                                                    "total_voting_power": {
                                                        "format": "int64",
                                                        "type": "string"
                                                    }
                                                }
                                            }
                                        }
                                    },
                                    "common_height": {
                                        "format": "int64",
                                        "type": "string"
                                    },
                                    "byzantine_validators": {
                                        "type": "array",
                                        "items": {
                                            "type": "object",
                                            "properties": {
                                                "address": {
                                                    "format": "byte",
                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                    "type": "string"
                                                },
                                                "pub_key": {
                                                    "title": "PublicKey defines the keys available for use with Tendermint Validators",
                                                    "type": "object",
                                                    "properties": {
                                                        "ed25519": {
                                                            "format": "byte",
                                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                            "type": "string"
                                                        },
                                                        "secp256k1": {
                                                            "format": "byte",
                                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                            "type": "string"
                                                        }
                                                    }
                                                },
                                                "voting_power": {
                                                    "format": "int64",
                                                    "type": "string"
                                                },
                                                "proposer_priority": {
                                                    "format": "int64",
                                                    "type": "string"
                                                }
                                            }
                                        }
                                    },
                                    "total_voting_power": {
                                        "format": "int64",
                                        "type": "string"
                                    },
                                    "timestamp": {
                                        "format": "date-time",
                                        "type": "string"
                                    }
                                }
                            }
                        }
                    }
                }
            }
        },
        "tendermint.types.Header": {
            "description": "Header defines the structure of a Tendermint block header.",
            "type": "object",
            "properties": {
                "version": {
                    "title": "basic block info",
                    "description": "Consensus captures the consensus rules for processing a block in the blockchain,\nincluding all blockchain data structures and the rules of the application's\nstate transition machine.",
                    "type": "object",
                    "properties": {
                        "block": {
                            "format": "uint64",
                            "type": "string"
                        },
                        "app": {
                            "format": "uint64",
                            "type": "string"
                        }
                    }
                },
                "chain_id": {
                    "type": "string"
                },
                "height": {
                    "format": "int64",
                    "type": "string"
                },
                "time": {
                    "format": "date-time",
                    "type": "string"
                },
                "last_block_id": {
                    "title": "BlockID",
                    "type": "object",
                    "properties": {
                        "hash": {
                            "format": "byte",
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string"
                        },
                        "part_set_header": {
                            "title": "PartsetHeader",
                            "type": "object",
                            "properties": {
                                "total": {
                                    "format": "int64",
                                    "type": "integer"
                                },
                                "hash": {
                                    "format": "byte",
                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                    "type": "string"
                                }
                            }
                        }
                    }
                },
                "last_commit_hash": {
                    "format": "byte",
                    "title": "hashes of block data",
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string"
                },
                "data_hash": {
                    "format": "byte",
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string"
                },
                "validators_hash": {
                    "format": "byte",
                    "title": "hashes from the app output from the prev block",
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string"
                },
                "next_validators_hash": {
                    "format": "byte",
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string"
                },
                "consensus_hash": {
                    "format": "byte",
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string"
                },
                "app_hash": {
                    "format": "byte",
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string"
                },
                "last_results_hash": {
                    "format": "byte",
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string"
                },
                "evidence_hash": {
                    "format": "byte",
                    "title": "consensus info",
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string"
                },
                "proposer_address": {
                    "format": "byte",
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string"
                }
            }
        },
        "tendermint.types.LightBlock": {
            "type": "object",
            "properties": {
                "signed_header": {
                    "type": "object",
                    "properties": {
                        "header": {
                            "description": "Header defines the structure of a Tendermint block header.",
                            "type": "object",
                            "properties": {
                                "version": {
                                    "title": "basic block info",
                                    "description": "Consensus captures the consensus rules for processing a block in the blockchain,\nincluding all blockchain data structures and the rules of the application's\nstate transition machine.",
                                    "type": "object",
                                    "properties": {
                                        "block": {
                                            "format": "uint64",
                                            "type": "string"
                                        },
                                        "app": {
                                            "format": "uint64",
                                            "type": "string"
                                        }
                                    }
                                },
                                "chain_id": {
                                    "type": "string"
                                },
                                "height": {
                                    "format": "int64",
                                    "type": "string"
                                },
                                "time": {
                                    "format": "date-time",
                                    "type": "string"
                                },
                                "last_block_id": {
                                    "title": "BlockID",
                                    "type": "object",
                                    "properties": {
                                        "hash": {
                                            "format": "byte",
                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                            "type": "string"
                                        },
                                        "part_set_header": {
                                            "title": "PartsetHeader",
                                            "type": "object",
                                            "properties": {
                                                "total": {
                                                    "format": "int64",
                                                    "type": "integer"
                                                },
                                                "hash": {
                                                    "format": "byte",
                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                    "type": "string"
                                                }
                                            }
                                        }
                                    }
                                },
                                "last_commit_hash": {
                                    "format": "byte",
                                    "title": "hashes of block data",
                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                    "type": "string"
                                },
                                "data_hash": {
                                    "format": "byte",
                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                    "type": "string"
                                },
                                "validators_hash": {
                                    "format": "byte",
                                    "title": "hashes from the app output from the prev block",
                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                    "type": "string"
                                },
                                "next_validators_hash": {
                                    "format": "byte",
                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                    "type": "string"
                                },
                                "consensus_hash": {
                                    "format": "byte",
                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                    "type": "string"
                                },
                                "app_hash": {
                                    "format": "byte",
                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                    "type": "string"
                                },
                                "last_results_hash": {
                                    "format": "byte",
                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                    "type": "string"
                                },
                                "evidence_hash": {
                                    "format": "byte",
                                    "title": "consensus info",
                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                    "type": "string"
                                },
                                "proposer_address": {
                                    "format": "byte",
                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                    "type": "string"
                                }
                            }
                        },
                        "commit": {
                            "description": "Commit contains the evidence that a block was committed by a set of validators.",
                            "type": "object",
                            "properties": {
                                "height": {
                                    "format": "int64",
                                    "type": "string"
                                },
                                "round": {
                                    "format": "int32",
                                    "type": "integer"
                                },
                                "block_id": {
                                    "title": "BlockID",
                                    "type": "object",
                                    "properties": {
                                        "hash": {
                                            "format": "byte",
                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                            "type": "string"
                                        },
                                        "part_set_header": {
                                            "title": "PartsetHeader",
                                            "type": "object",
                                            "properties": {
                                                "total": {
                                                    "format": "int64",
                                                    "type": "integer"
                                                },
                                                "hash": {
                                                    "format": "byte",
                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                    "type": "string"
                                                }
                                            }
                                        }
                                    }
                                },
                                "signatures": {
                                    "type": "array",
                                    "items": {
                                        "description": "CommitSig is a part of the Vote included in a Commit.",
                                        "type": "object",
                                        "properties": {
                                            "block_id_flag": {
                                                "title": "BlockIdFlag indicates which BlcokID the signature is for",
                                                "default": "BLOCK_ID_FLAG_UNKNOWN",
                                                "enum": [
                                                    "BLOCK_ID_FLAG_UNKNOWN",
                                                    "BLOCK_ID_FLAG_ABSENT",
                                                    "BLOCK_ID_FLAG_COMMIT",
                                                    "BLOCK_ID_FLAG_NIL"
                                                ],
                                                "type": "string"
                                            },
                                            "validator_address": {
                                                "format": "byte",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            },
                                            "timestamp": {
                                                "format": "date-time",
                                                "type": "string"
                                            },
                                            "signature": {
                                                "format": "byte",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                },
                "validator_set": {
                    "type": "object",
                    "properties": {
                        "validators": {
                            "type": "array",
                            "items": {
                                "type": "object",
                                "properties": {
                                    "address": {
                                        "format": "byte",
                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                        "type": "string"
                                    },
                                    "pub_key": {
                                        "title": "PublicKey defines the keys available for use with Tendermint Validators",
                                        "type": "object",
                                        "properties": {
                                            "ed25519": {
                                                "format": "byte",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            },
                                            "secp256k1": {
                                                "format": "byte",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    },
                                    "voting_power": {
                                        "format": "int64",
                                        "type": "string"
                                    },
                                    "proposer_priority": {
                                        "format": "int64",
                                        "type": "string"
                                    }
                                }
                            }
                        },
                        "proposer": {
                            "type": "object",
                            "properties": {
                                "address": {
                                    "format": "byte",
                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                    "type": "string"
                                },
                                "pub_key": {
                                    "title": "PublicKey defines the keys available for use with Tendermint Validators",
                                    "type": "object",
                                    "properties": {
                                        "ed25519": {
                                            "format": "byte",
                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                            "type": "string"
                                        },
                                        "secp256k1": {
                                            "format": "byte",
                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                            "type": "string"
                                        }
                                    }
                                },
                                "voting_power": {
                                    "format": "int64",
                                    "type": "string"
                                },
                                "proposer_priority": {
                                    "format": "int64",
                                    "type": "string"
                                }
                            }
                        },
                        "total_voting_power": {
                            "format": "int64",
                            "type": "string"
                        }
                    }
                }
            }
        },
        "tendermint.types.LightClientAttackEvidence": {
            "description": "LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client.",
            "type": "object",
            "properties": {
                "conflicting_block": {
                    "type": "object",
                    "properties": {
                        "signed_header": {
                            "type": "object",
                            "properties": {
                                "header": {
                                    "description": "Header defines the structure of a Tendermint block header.",
                                    "type": "object",
                                    "properties": {
                                        "version": {
                                            "title": "basic block info",
                                            "description": "Consensus captures the consensus rules for processing a block in the blockchain,\nincluding all blockchain data structures and the rules of the application's\nstate transition machine.",
                                            "type": "object",
                                            "properties": {
                                                "block": {
                                                    "format": "uint64",
                                                    "type": "string"
                                                },
                                                "app": {
                                                    "format": "uint64",
                                                    "type": "string"
                                                }
                                            }
                                        },
                                        "chain_id": {
                                            "type": "string"
                                        },
                                        "height": {
                                            "format": "int64",
                                            "type": "string"
                                        },
                                        "time": {
                                            "format": "date-time",
                                            "type": "string"
                                        },
                                        "last_block_id": {
                                            "title": "BlockID",
                                            "type": "object",
                                            "properties": {
                                                "hash": {
                                                    "format": "byte",
                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                    "type": "string"
                                                },
                                                "part_set_header": {
                                                    "title": "PartsetHeader",
                                                    "type": "object",
                                                    "properties": {
                                                        "total": {
                                                            "format": "int64",
                                                            "type": "integer"
                                                        },
                                                        "hash": {
                                                            "format": "byte",
                                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                            "type": "string"
                                                        }
                                                    }
                                                }
                                            }
                                        },
                                        "last_commit_hash": {
                                            "format": "byte",
                                            "title": "hashes of block data",
                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                            "type": "string"
                                        },
                                        "data_hash": {
                                            "format": "byte",
                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                            "type": "string"
                                        },
                                        "validators_hash": {
                                            "format": "byte",
                                            "title": "hashes from the app output from the prev block",
                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                            "type": "string"
                                        },
                                        "next_validators_hash": {
                                            "format": "byte",
                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                            "type": "string"
                                        },
                                        "consensus_hash": {
                                            "format": "byte",
                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                            "type": "string"
                                        },
                                        "app_hash": {
                                            "format": "byte",
                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                            "type": "string"
                                        },
                                        "last_results_hash": {
                                            "format": "byte",
                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                            "type": "string"
                                        },
                                        "evidence_hash": {
                                            "format": "byte",
                                            "title": "consensus info",
                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                            "type": "string"
                                        },
                                        "proposer_address": {
                                            "format": "byte",
                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                            "type": "string"
                                        }
                                    }
                                },
                                "commit": {
                                    "description": "Commit contains the evidence that a block was committed by a set of validators.",
                                    "type": "object",
                                    "properties": {
                                        "height": {
                                            "format": "int64",
                                            "type": "string"
                                        },
                                        "round": {
                                            "format": "int32",
                                            "type": "integer"
                                        },
                                        "block_id": {
                                            "title": "BlockID",
                                            "type": "object",
                                            "properties": {
                                                "hash": {
                                                    "format": "byte",
                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                    "type": "string"
                                                },
                                                "part_set_header": {
                                                    "title": "PartsetHeader",
                                                    "type": "object",
                                                    "properties": {
                                                        "total": {
                                                            "format": "int64",
                                                            "type": "integer"
                                                        },
                                                        "hash": {
                                                            "format": "byte",
                                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                            "type": "string"
                                                        }
                                                    }
                                                }
                                            }
                                        },
                                        "signatures": {
                                            "type": "array",
                                            "items": {
                                                "description": "CommitSig is a part of the Vote included in a Commit.",
                                                "type": "object",
                                                "properties": {
                                                    "block_id_flag": {
                                                        "title": "BlockIdFlag indicates which BlcokID the signature is for",
                                                        "default": "BLOCK_ID_FLAG_UNKNOWN",
                                                        "enum": [
                                                            "BLOCK_ID_FLAG_UNKNOWN",
                                                            "BLOCK_ID_FLAG_ABSENT",
                                                            "BLOCK_ID_FLAG_COMMIT",
                                                            "BLOCK_ID_FLAG_NIL"
                                                        ],
                                                        "type": "string"
                                                    },
                                                    "validator_address": {
                                                        "format": "byte",
                                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                        "type": "string"
                                                    },
                                                    "timestamp": {
                                                        "format": "date-time",
                                                        "type": "string"
                                                    },
                                                    "signature": {
                                                        "format": "byte",
                                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                        "type": "string"
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        },
                        "validator_set": {
                            "type": "object",
                            "properties": {
                                "validators": {
                                    "type": "array",
                                    "items": {
                                        "type": "object",
                                        "properties": {
                                            "address": {
                                                "format": "byte",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            },
                                            "pub_key": {
                                                "title": "PublicKey defines the keys available for use with Tendermint Validators",
                                                "type": "object",
                                                "properties": {
                                                    "ed25519": {
                                                        "format": "byte",
                                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                        "type": "string"
                                                    },
                                                    "secp256k1": {
                                                        "format": "byte",
                                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                        "type": "string"
                                                    }
                                                }
                                            },
                                            "voting_power": {
                                                "format": "int64",
                                                "type": "string"
                                            },
                                            "proposer_priority": {
                                                "format": "int64",
                                                "type": "string"
                                            }
                                        }
                                    }
                                },
                                "proposer": {
                                    "type": "object",
                                    "properties": {
                                        "address": {
                                            "format": "byte",
                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                            "type": "string"
                                        },
                                        "pub_key": {
                                            "title": "PublicKey defines the keys available for use with Tendermint Validators",
                                            "type": "object",
                                            "properties": {
                                                "ed25519": {
                                                    "format": "byte",
                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                    "type": "string"
                                                },
                                                "secp256k1": {
                                                    "format": "byte",
                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                    "type": "string"
                                                }
                                            }
                                        },
                                        "voting_power": {
                                            "format": "int64",
                                            "type": "string"
                                        },
                                        "proposer_priority": {
                                            "format": "int64",
                                            "type": "string"
                                        }
                                    }
                                },
                                "total_voting_power": {
                                    "format": "int64",
                                    "type": "string"
                                }
                            }
                        }
                    }
                },
                "common_height": {
                    "format": "int64",
                    "type": "string"
                },
                "byzantine_validators": {
                    "type": "array",
                    "items": {
                        "type": "object",
                        "properties": {
                            "address": {
                                "format": "byte",
                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                "type": "string"
                            },
                            "pub_key": {
                                "title": "PublicKey defines the keys available for use with Tendermint Validators",
                                "type": "object",
                                "properties": {
                                    "ed25519": {
                                        "format": "byte",
                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                        "type": "string"
                                    },
                                    "secp256k1": {
                                        "format": "byte",
                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                        "type": "string"
                                    }
                                }
                            },
                            "voting_power": {
                                "format": "int64",
                                "type": "string"
                            },
                            "proposer_priority": {
                                "format": "int64",
                                "type": "string"
                            }
                        }
                    }
                },
                "total_voting_power": {
                    "format": "int64",
                    "type": "string"
                },
                "timestamp": {
                    "format": "date-time",
                    "type": "string"
                }
            }
        },
        "tendermint.types.PartSetHeader": {
            "title": "PartsetHeader",
            "type": "object",
            "properties": {
                "total": {
                    "format": "int64",
                    "type": "integer"
                },
                "hash": {
                    "format": "byte",
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string"
                }
            }
        },
        "tendermint.types.SignedHeader": {
            "type": "object",
            "properties": {
                "header": {
                    "description": "Header defines the structure of a Tendermint block header.",
                    "type": "object",
                    "properties": {
                        "version": {
                            "title": "basic block info",
                            "description": "Consensus captures the consensus rules for processing a block in the blockchain,\nincluding all blockchain data structures and the rules of the application's\nstate transition machine.",
                            "type": "object",
                            "properties": {
                                "block": {
                                    "format": "uint64",
                                    "type": "string"
                                },
                                "app": {
                                    "format": "uint64",
                                    "type": "string"
                                }
                            }
                        },
                        "chain_id": {
                            "type": "string"
                        },
                        "height": {
                            "format": "int64",
                            "type": "string"
                        },
                        "time": {
                            "format": "date-time",
                            "type": "string"
                        },
                        "last_block_id": {
                            "title": "BlockID",
                            "type": "object",
                            "properties": {
                                "hash": {
                                    "format": "byte",
                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                    "type": "string"
                                },
                                "part_set_header": {
                                    "title": "PartsetHeader",
                                    "type": "object",
                                    "properties": {
                                        "total": {
                                            "format": "int64",
                                            "type": "integer"
                                        },
                                        "hash": {
                                            "format": "byte",
                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                            "type": "string"
                                        }
                                    }
                                }
                            }
                        },
                        "last_commit_hash": {
                            "format": "byte",
                            "title": "hashes of block data",
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string"
                        },
                        "data_hash": {
                            "format": "byte",
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string"
                        },
                        "validators_hash": {
                            "format": "byte",
                            "title": "hashes from the app output from the prev block",
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string"
                        },
                        "next_validators_hash": {
                            "format": "byte",
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string"
                        },
                        "consensus_hash": {
                            "format": "byte",
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string"
                        },
                        "app_hash": {
                            "format": "byte",
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string"
                        },
                        "last_results_hash": {
                            "format": "byte",
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string"
                        },
                        "evidence_hash": {
                            "format": "byte",
                            "title": "consensus info",
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string"
                        },
                        "proposer_address": {
                            "format": "byte",
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string"
                        }
                    }
                },
                "commit": {
                    "description": "Commit contains the evidence that a block was committed by a set of validators.",
                    "type": "object",
                    "properties": {
                        "height": {
                            "format": "int64",
                            "type": "string"
                        },
                        "round": {
                            "format": "int32",
                            "type": "integer"
                        },
                        "block_id": {
                            "title": "BlockID",
                            "type": "object",
                            "properties": {
                                "hash": {
                                    "format": "byte",
                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                    "type": "string"
                                },
                                "part_set_header": {
                                    "title": "PartsetHeader",
                                    "type": "object",
                                    "properties": {
                                        "total": {
                                            "format": "int64",
                                            "type": "integer"
                                        },
                                        "hash": {
                                            "format": "byte",
                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                            "type": "string"
                                        }
                                    }
                                }
                            }
                        },
                        "signatures": {
                            "type": "array",
                            "items": {
                                "description": "CommitSig is a part of the Vote included in a Commit.",
                                "type": "object",
                                "properties": {
                                    "block_id_flag": {
                                        "title": "BlockIdFlag indicates which BlcokID the signature is for",
                                        "default": "BLOCK_ID_FLAG_UNKNOWN",
                                        "enum": [
                                            "BLOCK_ID_FLAG_UNKNOWN",
                                            "BLOCK_ID_FLAG_ABSENT",
                                            "BLOCK_ID_FLAG_COMMIT",
                                            "BLOCK_ID_FLAG_NIL"
                                        ],
                                        "type": "string"
                                    },
                                    "validator_address": {
                                        "format": "byte",
                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                        "type": "string"
                                    },
                                    "timestamp": {
                                        "format": "date-time",
                                        "type": "string"
                                    },
                                    "signature": {
                                        "format": "byte",
                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                        "type": "string"
                                    }
                                }
                            }
                        }
                    }
                }
            }
        },
        "tendermint.types.SignedMsgType": {
            "description": "SignedMsgType is a type of signed message in the consensus.\n\n - SIGNED_MSG_TYPE_PREVOTE: Votes\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals",
            "default": "SIGNED_MSG_TYPE_UNKNOWN",
            "enum": [
                "SIGNED_MSG_TYPE_UNKNOWN",
                "SIGNED_MSG_TYPE_PREVOTE",
                "SIGNED_MSG_TYPE_PRECOMMIT",
                "SIGNED_MSG_TYPE_PROPOSAL"
            ],
            "type": "string"
        },
        "tendermint.types.Validator": {
            "type": "object",
            "properties": {
                "address": {
                    "format": "byte",
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string"
                },
                "pub_key": {
                    "title": "PublicKey defines the keys available for use with Tendermint Validators",
                    "type": "object",
                    "properties": {
                        "ed25519": {
                            "format": "byte",
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string"
                        },
                        "secp256k1": {
                            "format": "byte",
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string"
                        }
                    }
                },
                "voting_power": {
                    "format": "int64",
                    "type": "string"
                },
                "proposer_priority": {
                    "format": "int64",
                    "type": "string"
                }
            }
        },
        "tendermint.types.ValidatorSet": {
            "type": "object",
            "properties": {
                "validators": {
                    "type": "array",
                    "items": {
                        "type": "object",
                        "properties": {
                            "address": {
                                "format": "byte",
                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                "type": "string"
                            },
                            "pub_key": {
                                "title": "PublicKey defines the keys available for use with Tendermint Validators",
                                "type": "object",
                                "properties": {
                                    "ed25519": {
                                        "format": "byte",
                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                        "type": "string"
                                    },
                                    "secp256k1": {
                                        "format": "byte",
                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                        "type": "string"
                                    }
                                }
                            },
                            "voting_power": {
                                "format": "int64",
                                "type": "string"
                            },
                            "proposer_priority": {
                                "format": "int64",
                                "type": "string"
                            }
                        }
                    }
                },
                "proposer": {
                    "type": "object",
                    "properties": {
                        "address": {
                            "format": "byte",
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string"
                        },
                        "pub_key": {
                            "title": "PublicKey defines the keys available for use with Tendermint Validators",
                            "type": "object",
                            "properties": {
                                "ed25519": {
                                    "format": "byte",
                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                    "type": "string"
                                },
                                "secp256k1": {
                                    "format": "byte",
                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                    "type": "string"
                                }
                            }
                        },
                        "voting_power": {
                            "format": "int64",
                            "type": "string"
                        },
                        "proposer_priority": {
                            "format": "int64",
                            "type": "string"
                        }
                    }
                },
                "total_voting_power": {
                    "format": "int64",
                    "type": "string"
                }
            }
        },
        "tendermint.types.Vote": {
            "description": "Vote represents a prevote, precommit, or commit vote from validators for\nconsensus.",
            "type": "object",
            "properties": {
                "type": {
                    "description": "SignedMsgType is a type of signed message in the consensus.\n\n - SIGNED_MSG_TYPE_PREVOTE: Votes\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals",
                    "default": "SIGNED_MSG_TYPE_UNKNOWN",
                    "enum": [
                        "SIGNED_MSG_TYPE_UNKNOWN",
                        "SIGNED_MSG_TYPE_PREVOTE",
                        "SIGNED_MSG_TYPE_PRECOMMIT",
                        "SIGNED_MSG_TYPE_PROPOSAL"
                    ],
                    "type": "string"
                },
                "height": {
                    "format": "int64",
                    "type": "string"
                },
                "round": {
                    "format": "int32",
                    "type": "integer"
                },
                "block_id": {
                    "title": "BlockID",
                    "type": "object",
                    "properties": {
                        "hash": {
                            "format": "byte",
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string"
                        },
                        "part_set_header": {
                            "title": "PartsetHeader",
                            "type": "object",
                            "properties": {
                                "total": {
                                    "format": "int64",
                                    "type": "integer"
                                },
                                "hash": {
                                    "format": "byte",
                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                    "type": "string"
                                }
                            }
                        }
                    }
                },
                "timestamp": {
                    "format": "date-time",
                    "type": "string"
                },
                "validator_address": {
                    "format": "byte",
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string"
                },
                "validator_index": {
                    "format": "int32",
                    "type": "integer"
                },
                "signature": {
                    "format": "byte",
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string"
                }
            }
        },
        "tendermint.version.Consensus": {
            "description": "Consensus captures the consensus rules for processing a block in the blockchain,\nincluding all blockchain data structures and the rules of the application's\nstate transition machine.",
            "type": "object",
            "properties": {
                "block": {
                    "format": "uint64",
                    "type": "string"
                },
                "app": {
                    "format": "uint64",
                    "type": "string"
                }
            }
        },
        "cosmos.base.v1beta1.DecCoin": {
            "description": "DecCoin defines a token with a denomination and a decimal amount.\n\nNOTE: The amount field is an Dec which implements the custom method\nsignatures required by gogoproto.",
            "type": "object",
            "properties": {
                "denom": {
                    "type": "string"
                },
                "amount": {
                    "type": "string"
                }
            }
        },
        "cosmos.distribution.v1beta1.DelegationDelegatorReward": {
            "description": "DelegationDelegatorReward represents the properties\nof a delegator's delegation reward.",
            "type": "object",
            "properties": {
                "validator_address": {
                    "type": "string"
                },
                "reward": {
                    "type": "array",
                    "items": {
                        "description": "DecCoin defines a token with a denomination and a decimal amount.\n\nNOTE: The amount field is an Dec which implements the custom method\nsignatures required by gogoproto.",
                        "type": "object",
                        "properties": {
                            "denom": {
                                "type": "string"
                            },
                            "amount": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        },
        "cosmos.distribution.v1beta1.Params": {
            "description": "Params defines the set of params for the distribution module.",
            "type": "object",
            "properties": {
                "community_tax": {
                    "type": "string"
                },
                "base_proposer_reward": {
                    "type": "string"
                },
                "bonus_proposer_reward": {
                    "type": "string"
                },
                "withdraw_addr_enabled": {
                    "format": "boolean",
                    "type": "boolean"
                },
                "secret_foundation_tax": {
                    "type": "string"
                },
                "secret_foundation_address": {
                    "type": "string"
                }
            }
        },
        "cosmos.distribution.v1beta1.QueryCommunityPoolResponse": {
            "description": "QueryCommunityPoolResponse is the response type for the Query/CommunityPool\nRPC method.",
            "type": "object",
            "properties": {
                "pool": {
                    "description": "pool defines community pool's coins.",
                    "type": "array",
                    "items": {
                        "description": "DecCoin defines a token with a denomination and a decimal amount.\n\nNOTE: The amount field is an Dec which implements the custom method\nsignatures required by gogoproto.",
                        "type": "object",
                        "properties": {
                            "denom": {
                                "type": "string"
                            },
                            "amount": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        },
        "cosmos.distribution.v1beta1.QueryDelegationRewardsResponse": {
            "description": "QueryDelegationRewardsResponse is the response type for the\nQuery/DelegationRewards RPC method.",
            "type": "object",
            "properties": {
                "rewards": {
                    "description": "rewards defines the rewards accrued by a delegation.",
                    "type": "array",
                    "items": {
                        "description": "DecCoin defines a token with a denomination and a decimal amount.\n\nNOTE: The amount field is an Dec which implements the custom method\nsignatures required by gogoproto.",
                        "type": "object",
                        "properties": {
                            "denom": {
                                "type": "string"
                            },
                            "amount": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        },
        "cosmos.distribution.v1beta1.QueryDelegationTotalRewardsResponse": {
            "description": "QueryDelegationTotalRewardsResponse is the response type for the\nQuery/DelegationTotalRewards RPC method.",
            "type": "object",
            "properties": {
                "rewards": {
                    "description": "rewards defines all the rewards accrued by a delegator.",
                    "type": "array",
                    "items": {
                        "description": "DelegationDelegatorReward represents the properties\nof a delegator's delegation reward.",
                        "type": "object",
                        "properties": {
                            "validator_address": {
                                "type": "string"
                            },
                            "reward": {
                                "type": "array",
                                "items": {
                                    "description": "DecCoin defines a token with a denomination and a decimal amount.\n\nNOTE: The amount field is an Dec which implements the custom method\nsignatures required by gogoproto.",
                                    "type": "object",
                                    "properties": {
                                        "denom": {
                                            "type": "string"
                                        },
                                        "amount": {
                                            "type": "string"
                                        }
                                    }
                                }
                            }
                        }
                    }
                },
                "total": {
                    "description": "total defines the sum of all the rewards.",
                    "type": "array",
                    "items": {
                        "description": "DecCoin defines a token with a denomination and a decimal amount.\n\nNOTE: The amount field is an Dec which implements the custom method\nsignatures required by gogoproto.",
                        "type": "object",
                        "properties": {
                            "denom": {
                                "type": "string"
                            },
                            "amount": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        },
        "cosmos.distribution.v1beta1.QueryDelegatorValidatorsResponse": {
            "description": "QueryDelegatorValidatorsResponse is the response type for the\nQuery/DelegatorValidators RPC method.",
            "type": "object",
            "properties": {
                "validators": {
                    "description": "validators defines the validators a delegator is delegating for.",
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            }
        },
        "cosmos.distribution.v1beta1.QueryDelegatorWithdrawAddressResponse": {
            "description": "QueryDelegatorWithdrawAddressResponse is the response type for the\nQuery/DelegatorWithdrawAddress RPC method.",
            "type": "object",
            "properties": {
                "withdraw_address": {
                    "description": "withdraw_address defines the delegator address to query for.",
                    "type": "string"
                }
            }
        },
        "cosmos.distribution.v1beta1.QueryFoundationTaxResponse": {
            "description": "QueryDelegatorWithdrawAddressResponse is the response type for the\nQuery/DelegatorWithdrawAddress RPC method.",
            "type": "object",
            "properties": {
                "tax": {
                    "description": "withdraw_address defines the delegator address to query for.",
                    "type": "string"
                },
                "foundation_address": {
                    "type": "string"
                }
            }
        },
        "cosmos.distribution.v1beta1.QueryParamsResponse": {
            "description": "QueryParamsResponse is the response type for the Query/Params RPC method.",
            "type": "object",
            "properties": {
                "params": {
                    "description": "params defines the parameters of the module.",
                    "type": "object",
                    "properties": {
                        "community_tax": {
                            "type": "string"
                        },
                        "base_proposer_reward": {
                            "type": "string"
                        },
                        "bonus_proposer_reward": {
                            "type": "string"
                        },
                        "withdraw_addr_enabled": {
                            "format": "boolean",
                            "type": "boolean"
                        },
                        "secret_foundation_tax": {
                            "type": "string"
                        },
                        "secret_foundation_address": {
                            "type": "string"
                        }
                    }
                }
            }
        },
        "cosmos.distribution.v1beta1.QueryValidatorCommissionResponse": {
            "title": "QueryValidatorCommissionResponse is the response type for the\nQuery/ValidatorCommission RPC method",
            "type": "object",
            "properties": {
                "commission": {
                    "description": "commission defines the commision the validator received.",
                    "type": "object",
                    "properties": {
                        "commission": {
                            "type": "array",
                            "items": {
                                "description": "DecCoin defines a token with a denomination and a decimal amount.\n\nNOTE: The amount field is an Dec which implements the custom method\nsignatures required by gogoproto.",
                                "type": "object",
                                "properties": {
                                    "denom": {
                                        "type": "string"
                                    },
                                    "amount": {
                                        "type": "string"
                                    }
                                }
                            }
                        }
                    }
                }
            }
        },
        "cosmos.distribution.v1beta1.QueryValidatorOutstandingRewardsResponse": {
            "description": "QueryValidatorOutstandingRewardsResponse is the response type for the\nQuery/ValidatorOutstandingRewards RPC method.",
            "type": "object",
            "properties": {
                "rewards": {
                    "description": "ValidatorOutstandingRewards represents outstanding (un-withdrawn) rewards\nfor a validator inexpensive to track, allows simple sanity checks.",
                    "type": "object",
                    "properties": {
                        "rewards": {
                            "type": "array",
                            "items": {
                                "description": "DecCoin defines a token with a denomination and a decimal amount.\n\nNOTE: The amount field is an Dec which implements the custom method\nsignatures required by gogoproto.",
                                "type": "object",
                                "properties": {
                                    "denom": {
                                        "type": "string"
                                    },
                                    "amount": {
                                        "type": "string"
                                    }
                                }
                            }
                        }
                    }
                }
            }
        },
        "cosmos.distribution.v1beta1.QueryValidatorSlashesResponse": {
            "description": "QueryValidatorSlashesResponse is the response type for the\nQuery/ValidatorSlashes RPC method.",
            "type": "object",
            "properties": {
                "slashes": {
                    "description": "slashes defines the slashes the validator received.",
                    "type": "array",
                    "items": {
                        "description": "ValidatorSlashEvent represents a validator slash event.\nHeight is implicit within the store key.\nThis is needed to calculate appropriate amount of staking tokens\nfor delegations which are withdrawn after a slash has occurred.",
                        "type": "object",
                        "properties": {
                            "validator_period": {
                                "format": "uint64",
                                "type": "string"
                            },
                            "fraction": {
                                "type": "string"
                            }
                        }
                    }
                },
                "pagination": {
                    "description": "pagination defines the pagination in the response.",
                    "type": "object",
                    "properties": {
                        "next_key": {
                            "format": "byte",
                            "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently",
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string"
                        },
                        "total": {
                            "format": "uint64",
                            "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                            "type": "string"
                        }
                    }
                }
            }
        },
        "cosmos.distribution.v1beta1.ValidatorAccumulatedCommission": {
            "description": "ValidatorAccumulatedCommission represents accumulated commission\nfor a validator kept as a running counter, can be withdrawn at any time.",
            "type": "object",
            "properties": {
                "commission": {
                    "type": "array",
                    "items": {
                        "description": "DecCoin defines a token with a denomination and a decimal amount.\n\nNOTE: The amount field is an Dec which implements the custom method\nsignatures required by gogoproto.",
                        "type": "object",
                        "properties": {
                            "denom": {
                                "type": "string"
                            },
                            "amount": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        },
        "cosmos.distribution.v1beta1.ValidatorOutstandingRewards": {
            "description": "ValidatorOutstandingRewards represents outstanding (un-withdrawn) rewards\nfor a validator inexpensive to track, allows simple sanity checks.",
            "type": "object",
            "properties": {
                "rewards": {
                    "type": "array",
                    "items": {
                        "description": "DecCoin defines a token with a denomination and a decimal amount.\n\nNOTE: The amount field is an Dec which implements the custom method\nsignatures required by gogoproto.",
                        "type": "object",
                        "properties": {
                            "denom": {
                                "type": "string"
                            },
                            "amount": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        },
        "cosmos.distribution.v1beta1.ValidatorSlashEvent": {
            "description": "ValidatorSlashEvent represents a validator slash event.\nHeight is implicit within the store key.\nThis is needed to calculate appropriate amount of staking tokens\nfor delegations which are withdrawn after a slash has occurred.",
            "type": "object",
            "properties": {
                "validator_period": {
                    "format": "uint64",
                    "type": "string"
                },
                "fraction": {
                    "type": "string"
                }
            }
        },
        "cosmos.evidence.v1beta1.QueryAllEvidenceResponse": {
            "description": "QueryAllEvidenceResponse is the response type for the Query/AllEvidence RPC\nmethod.",
            "type": "object",
            "properties": {
                "evidence": {
                    "description": "evidence returns all evidences.",
                    "type": "array",
                    "items": {
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                        "type": "object",
                        "properties": {
                            "type_url": {
                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                "type": "string"
                            },
                            "value": {
                                "format": "byte",
                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                "type": "string"
                            }
                        }
                    }
                },
                "pagination": {
                    "description": "pagination defines the pagination in the response.",
                    "type": "object",
                    "properties": {
                        "next_key": {
                            "format": "byte",
                            "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently",
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string"
                        },
                        "total": {
                            "format": "uint64",
                            "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                            "type": "string"
                        }
                    }
                }
            }
        },
        "cosmos.evidence.v1beta1.QueryEvidenceResponse": {
            "description": "QueryEvidenceResponse is the response type for the Query/Evidence RPC method.",
            "type": "object",
            "properties": {
                "evidence": {
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                    "type": "object",
                    "properties": {
                        "type_url": {
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                            "type": "string"
                        },
                        "value": {
                            "format": "byte",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string"
                        }
                    }
                }
            }
        },
        "cosmos.gov.v1beta1.Deposit": {
            "description": "Deposit defines an amount deposited by an account address to an active\nproposal.",
            "type": "object",
            "properties": {
                "proposal_id": {
                    "format": "uint64",
                    "type": "string"
                },
                "depositor": {
                    "type": "string"
                },
                "amount": {
                    "type": "array",
                    "items": {
                        "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto.",
                        "type": "object",
                        "properties": {
                            "denom": {
                                "type": "string"
                            },
                            "amount": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        },
        "cosmos.gov.v1beta1.DepositParams": {
            "description": "DepositParams defines the params for deposits on governance proposals.",
            "type": "object",
            "properties": {
                "min_deposit": {
                    "description": "Minimum deposit for a proposal to enter voting period.",
                    "type": "array",
                    "items": {
                        "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto.",
                        "type": "object",
                        "properties": {
                            "denom": {
                                "type": "string"
                            },
                            "amount": {
                                "type": "string"
                            }
                        }
                    }
                },
                "max_deposit_period": {
                    "description": "Maximum period for Atom holders to deposit on a proposal. Initial value: 2\n months.",
                    "type": "string"
                }
            }
        },
        "cosmos.gov.v1beta1.Proposal": {
            "description": "Proposal defines the core field members of a governance proposal.",
            "type": "object",
            "properties": {
                "proposal_id": {
                    "format": "uint64",
                    "type": "string"
                },
                "content": {
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                    "type": "object",
                    "properties": {
                        "type_url": {
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                            "type": "string"
                        },
                        "value": {
                            "format": "byte",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string"
                        }
                    }
                },
                "status": {
                    "description": "ProposalStatus enumerates the valid statuses of a proposal.\n\n - PROPOSAL_STATUS_UNSPECIFIED: PROPOSAL_STATUS_UNSPECIFIED defines the default propopsal status.\n - PROPOSAL_STATUS_DEPOSIT_PERIOD: PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit\nperiod.\n - PROPOSAL_STATUS_VOTING_PERIOD: PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting\nperiod.\n - PROPOSAL_STATUS_PASSED: PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has\npassed.\n - PROPOSAL_STATUS_REJECTED: PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has\nbeen rejected.\n - PROPOSAL_STATUS_FAILED: PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has\nfailed.",
                    "default": "PROPOSAL_STATUS_UNSPECIFIED",
                    "enum": [
                        "PROPOSAL_STATUS_UNSPECIFIED",
                        "PROPOSAL_STATUS_DEPOSIT_PERIOD",
                        "PROPOSAL_STATUS_VOTING_PERIOD",
                        "PROPOSAL_STATUS_PASSED",
                        "PROPOSAL_STATUS_REJECTED",
                        "PROPOSAL_STATUS_FAILED"
                    ],
                    "type": "string"
                },
                "final_tally_result": {
                    "description": "TallyResult defines a standard tally for a governance proposal.",
                    "type": "object",
                    "properties": {
                        "yes": {
                            "type": "string"
                        },
                        "abstain": {
                            "type": "string"
                        },
                        "no": {
                            "type": "string"
                        },
                        "no_with_veto": {
                            "type": "string"
                        }
                    }
                },
                "submit_time": {
                    "format": "date-time",
                    "type": "string"
                },
                "deposit_end_time": {
                    "format": "date-time",
                    "type": "string"
                },
                "total_deposit": {
                    "type": "array",
                    "items": {
                        "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto.",
                        "type": "object",
                        "properties": {
                            "denom": {
                                "type": "string"
                            },
                            "amount": {
                                "type": "string"
                            }
                        }
                    }
                },
                "voting_start_time": {
                    "format": "date-time",
                    "type": "string"
                },
                "voting_end_time": {
                    "format": "date-time",
                    "type": "string"
                }
            }
        },
        "cosmos.gov.v1beta1.ProposalStatus": {
            "description": "ProposalStatus enumerates the valid statuses of a proposal.\n\n - PROPOSAL_STATUS_UNSPECIFIED: PROPOSAL_STATUS_UNSPECIFIED defines the default propopsal status.\n - PROPOSAL_STATUS_DEPOSIT_PERIOD: PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit\nperiod.\n - PROPOSAL_STATUS_VOTING_PERIOD: PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting\nperiod.\n - PROPOSAL_STATUS_PASSED: PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has\npassed.\n - PROPOSAL_STATUS_REJECTED: PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has\nbeen rejected.\n - PROPOSAL_STATUS_FAILED: PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has\nfailed.",
            "default": "PROPOSAL_STATUS_UNSPECIFIED",
            "enum": [
                "PROPOSAL_STATUS_UNSPECIFIED",
                "PROPOSAL_STATUS_DEPOSIT_PERIOD",
                "PROPOSAL_STATUS_VOTING_PERIOD",
                "PROPOSAL_STATUS_PASSED",
                "PROPOSAL_STATUS_REJECTED",
                "PROPOSAL_STATUS_FAILED"
            ],
            "type": "string"
        },
        "cosmos.gov.v1beta1.QueryDepositResponse": {
            "description": "QueryDepositResponse is the response type for the Query/Deposit RPC method.",
            "type": "object",
            "properties": {
                "deposit": {
                    "description": "Deposit defines an amount deposited by an account address to an active\nproposal.",
                    "type": "object",
                    "properties": {
                        "proposal_id": {
                            "format": "uint64",
                            "type": "string"
                        },
                        "depositor": {
                            "type": "string"
                        },
                        "amount": {
                            "type": "array",
                            "items": {
                                "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto.",
                                "type": "object",
                                "properties": {
                                    "denom": {
                                        "type": "string"
                                    },
                                    "amount": {
                                        "type": "string"
                                    }
                                }
                            }
                        }
                    }
                }
            }
        },
        "cosmos.gov.v1beta1.QueryDepositsResponse": {
            "description": "QueryDepositsResponse is the response type for the Query/Deposits RPC method.",
            "type": "object",
            "properties": {
                "deposits": {
                    "type": "array",
                    "items": {
                        "description": "Deposit defines an amount deposited by an account address to an active\nproposal.",
                        "type": "object",
                        "properties": {
                            "proposal_id": {
                                "format": "uint64",
                                "type": "string"
                            },
                            "depositor": {
                                "type": "string"
                            },
                            "amount": {
                                "type": "array",
                                "items": {
                                    "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto.",
                                    "type": "object",
                                    "properties": {
                                        "denom": {
                                            "type": "string"
                                        },
                                        "amount": {
                                            "type": "string"
                                        }
                                    }
                                }
                            }
                        }
                    }
                },
                "pagination": {
                    "description": "pagination defines the pagination in the response.",
                    "type": "object",
                    "properties": {
                        "next_key": {
                            "format": "byte",
                            "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently",
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string"
                        },
                        "total": {
                            "format": "uint64",
                            "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                            "type": "string"
                        }
                    }
                }
            }
        },
        "cosmos.gov.v1beta1.QueryParamsResponse": {
            "description": "QueryParamsResponse is the response type for the Query/Params RPC method.",
            "type": "object",
            "properties": {
                "voting_params": {
                    "description": "voting_params defines the parameters related to voting.",
                    "type": "object",
                    "properties": {
                        "voting_period": {
                            "description": "Length of the voting period.",
                            "type": "string"
                        }
                    }
                },
                "deposit_params": {
                    "description": "deposit_params defines the parameters related to deposit.",
                    "type": "object",
                    "properties": {
                        "min_deposit": {
                            "description": "Minimum deposit for a proposal to enter voting period.",
                            "type": "array",
                            "items": {
                                "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto.",
                                "type": "object",
                                "properties": {
                                    "denom": {
                                        "type": "string"
                                    },
                                    "amount": {
                                        "type": "string"
                                    }
                                }
                            }
                        },
                        "max_deposit_period": {
                            "description": "Maximum period for Atom holders to deposit on a proposal. Initial value: 2\n months.",
                            "type": "string"
                        }
                    }
                },
                "tally_params": {
                    "description": "tally_params defines the parameters related to tally.",
                    "type": "object",
                    "properties": {
                        "quorum": {
                            "format": "byte",
                            "description": "Minimum percentage of total stake needed to vote for a result to be\n considered valid.",
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string"
                        },
                        "threshold": {
                            "format": "byte",
                            "description": "Minimum proportion of Yes votes for proposal to pass. Default value: 0.5.",
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string"
                        },
                        "veto_threshold": {
                            "format": "byte",
                            "description": "Minimum value of Veto votes to Total votes ratio for proposal to be\n vetoed. Default value: 1/3.",
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string"
                        }
                    }
                }
            }
        },
        "cosmos.gov.v1beta1.QueryProposalResponse": {
            "description": "QueryProposalResponse is the response type for the Query/Proposal RPC method.",
            "type": "object",
            "properties": {
                "proposal": {
                    "description": "Proposal defines the core field members of a governance proposal.",
                    "type": "object",
                    "properties": {
                        "proposal_id": {
                            "format": "uint64",
                            "type": "string"
                        },
                        "content": {
                            "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                            "type": "object",
                            "properties": {
                                "type_url": {
                                    "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                    "type": "string"
                                },
                                "value": {
                                    "format": "byte",
                                    "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                    "type": "string"
                                }
                            }
                        },
                        "status": {
                            "description": "ProposalStatus enumerates the valid statuses of a proposal.\n\n - PROPOSAL_STATUS_UNSPECIFIED: PROPOSAL_STATUS_UNSPECIFIED defines the default propopsal status.\n - PROPOSAL_STATUS_DEPOSIT_PERIOD: PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit\nperiod.\n - PROPOSAL_STATUS_VOTING_PERIOD: PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting\nperiod.\n - PROPOSAL_STATUS_PASSED: PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has\npassed.\n - PROPOSAL_STATUS_REJECTED: PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has\nbeen rejected.\n - PROPOSAL_STATUS_FAILED: PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has\nfailed.",
                            "default": "PROPOSAL_STATUS_UNSPECIFIED",
                            "enum": [
                                "PROPOSAL_STATUS_UNSPECIFIED",
                                "PROPOSAL_STATUS_DEPOSIT_PERIOD",
                                "PROPOSAL_STATUS_VOTING_PERIOD",
                                "PROPOSAL_STATUS_PASSED",
                                "PROPOSAL_STATUS_REJECTED",
                                "PROPOSAL_STATUS_FAILED"
                            ],
                            "type": "string"
                        },
                        "final_tally_result": {
                            "description": "TallyResult defines a standard tally for a governance proposal.",
                            "type": "object",
                            "properties": {
                                "yes": {
                                    "type": "string"
                                },
                                "abstain": {
                                    "type": "string"
                                },
                                "no": {
                                    "type": "string"
                                },
                                "no_with_veto": {
                                    "type": "string"
                                }
                            }
                        },
                        "submit_time": {
                            "format": "date-time",
                            "type": "string"
                        },
                        "deposit_end_time": {
                            "format": "date-time",
                            "type": "string"
                        },
                        "total_deposit": {
                            "type": "array",
                            "items": {
                                "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto.",
                                "type": "object",
                                "properties": {
                                    "denom": {
                                        "type": "string"
                                    },
                                    "amount": {
                                        "type": "string"
                                    }
                                }
                            }
                        },
                        "voting_start_time": {
                            "format": "date-time",
                            "type": "string"
                        },
                        "voting_end_time": {
                            "format": "date-time",
                            "type": "string"
                        }
                    }
                }
            }
        },
        "cosmos.gov.v1beta1.QueryProposalsResponse": {
            "description": "QueryProposalsResponse is the response type for the Query/Proposals RPC\nmethod.",
            "type": "object",
            "properties": {
                "proposals": {
                    "type": "array",
                    "items": {
                        "description": "Proposal defines the core field members of a governance proposal.",
                        "type": "object",
                        "properties": {
                            "proposal_id": {
                                "format": "uint64",
                                "type": "string"
                            },
                            "content": {
                                "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                "type": "object",
                                "properties": {
                                    "type_url": {
                                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                        "type": "string"
                                    },
                                    "value": {
                                        "format": "byte",
                                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                        "type": "string"
                                    }
                                }
                            },
                            "status": {
                                "description": "ProposalStatus enumerates the valid statuses of a proposal.\n\n - PROPOSAL_STATUS_UNSPECIFIED: PROPOSAL_STATUS_UNSPECIFIED defines the default propopsal status.\n - PROPOSAL_STATUS_DEPOSIT_PERIOD: PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit\nperiod.\n - PROPOSAL_STATUS_VOTING_PERIOD: PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting\nperiod.\n - PROPOSAL_STATUS_PASSED: PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has\npassed.\n - PROPOSAL_STATUS_REJECTED: PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has\nbeen rejected.\n - PROPOSAL_STATUS_FAILED: PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has\nfailed.",
                                "default": "PROPOSAL_STATUS_UNSPECIFIED",
                                "enum": [
                                    "PROPOSAL_STATUS_UNSPECIFIED",
                                    "PROPOSAL_STATUS_DEPOSIT_PERIOD",
                                    "PROPOSAL_STATUS_VOTING_PERIOD",
                                    "PROPOSAL_STATUS_PASSED",
                                    "PROPOSAL_STATUS_REJECTED",
                                    "PROPOSAL_STATUS_FAILED"
                                ],
                                "type": "string"
                            },
                            "final_tally_result": {
                                "description": "TallyResult defines a standard tally for a governance proposal.",
                                "type": "object",
                                "properties": {
                                    "yes": {
                                        "type": "string"
                                    },
                                    "abstain": {
                                        "type": "string"
                                    },
                                    "no": {
                                        "type": "string"
                                    },
                                    "no_with_veto": {
                                        "type": "string"
                                    }
                                }
                            },
                            "submit_time": {
                                "format": "date-time",
                                "type": "string"
                            },
                            "deposit_end_time": {
                                "format": "date-time",
                                "type": "string"
                            },
                            "total_deposit": {
                                "type": "array",
                                "items": {
                                    "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto.",
                                    "type": "object",
                                    "properties": {
                                        "denom": {
                                            "type": "string"
                                        },
                                        "amount": {
                                            "type": "string"
                                        }
                                    }
                                }
                            },
                            "voting_start_time": {
                                "format": "date-time",
                                "type": "string"
                            },
                            "voting_end_time": {
                                "format": "date-time",
                                "type": "string"
                            }
                        }
                    }
                },
                "pagination": {
                    "description": "pagination defines the pagination in the response.",
                    "type": "object",
                    "properties": {
                        "next_key": {
                            "format": "byte",
                            "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently",
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string"
                        },
                        "total": {
                            "format": "uint64",
                            "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                            "type": "string"
                        }
                    }
                }
            }
        },
        "cosmos.gov.v1beta1.QueryTallyResultResponse": {
            "description": "QueryTallyResultResponse is the response type for the Query/Tally RPC method.",
            "type": "object",
            "properties": {
                "tally": {
                    "description": "TallyResult defines a standard tally for a governance proposal.",
                    "type": "object",
                    "properties": {
                        "yes": {
                            "type": "string"
                        },
                        "abstain": {
                            "type": "string"
                        },
                        "no": {
                            "type": "string"
                        },
                        "no_with_veto": {
                            "type": "string"
                        }
                    }
                }
            }
        },
        "cosmos.gov.v1beta1.QueryVoteResponse": {
            "description": "QueryVoteResponse is the response type for the Query/Vote RPC method.",
            "type": "object",
            "properties": {
                "vote": {
                    "description": "Vote defines a vote on a governance proposal.\nA Vote consists of a proposal ID, the voter, and the vote option.",
                    "type": "object",
                    "properties": {
                        "proposal_id": {
                            "format": "uint64",
                            "type": "string"
                        },
                        "voter": {
                            "type": "string"
                        },
                        "option": {
                            "description": "Deprecated: Prefer to use `options` instead. This field is set in queries\nif and only if `len(options) == 1` and that option has weight 1. In all\nother cases, this field will default to VOTE_OPTION_UNSPECIFIED.",
                            "default": "VOTE_OPTION_UNSPECIFIED",
                            "enum": [
                                "VOTE_OPTION_UNSPECIFIED",
                                "VOTE_OPTION_YES",
                                "VOTE_OPTION_ABSTAIN",
                                "VOTE_OPTION_NO",
                                "VOTE_OPTION_NO_WITH_VETO"
                            ],
                            "type": "string"
                        },
                        "options": {
                            "type": "array",
                            "items": {
                                "description": "WeightedVoteOption defines a unit of vote for vote split.",
                                "type": "object",
                                "properties": {
                                    "option": {
                                        "description": "VoteOption enumerates the valid vote options for a given governance proposal.\n\n - VOTE_OPTION_UNSPECIFIED: VOTE_OPTION_UNSPECIFIED defines a no-op vote option.\n - VOTE_OPTION_YES: VOTE_OPTION_YES defines a yes vote option.\n - VOTE_OPTION_ABSTAIN: VOTE_OPTION_ABSTAIN defines an abstain vote option.\n - VOTE_OPTION_NO: VOTE_OPTION_NO defines a no vote option.\n - VOTE_OPTION_NO_WITH_VETO: VOTE_OPTION_NO_WITH_VETO defines a no with veto vote option.",
                                        "default": "VOTE_OPTION_UNSPECIFIED",
                                        "enum": [
                                            "VOTE_OPTION_UNSPECIFIED",
                                            "VOTE_OPTION_YES",
                                            "VOTE_OPTION_ABSTAIN",
                                            "VOTE_OPTION_NO",
                                            "VOTE_OPTION_NO_WITH_VETO"
                                        ],
                                        "type": "string"
                                    },
                                    "weight": {
                                        "type": "string"
                                    }
                                }
                            }
                        }
                    }
                }
            }
        },
        "cosmos.gov.v1beta1.QueryVotesResponse": {
            "description": "QueryVotesResponse is the response type for the Query/Votes RPC method.",
            "type": "object",
            "properties": {
                "votes": {
                    "description": "votes defined the queried votes.",
                    "type": "array",
                    "items": {
                        "description": "Vote defines a vote on a governance proposal.\nA Vote consists of a proposal ID, the voter, and the vote option.",
                        "type": "object",
                        "properties": {
                            "proposal_id": {
                                "format": "uint64",
                                "type": "string"
                            },
                            "voter": {
                                "type": "string"
                            },
                            "option": {
                                "description": "Deprecated: Prefer to use `options` instead. This field is set in queries\nif and only if `len(options) == 1` and that option has weight 1. In all\nother cases, this field will default to VOTE_OPTION_UNSPECIFIED.",
                                "default": "VOTE_OPTION_UNSPECIFIED",
                                "enum": [
                                    "VOTE_OPTION_UNSPECIFIED",
                                    "VOTE_OPTION_YES",
                                    "VOTE_OPTION_ABSTAIN",
                                    "VOTE_OPTION_NO",
                                    "VOTE_OPTION_NO_WITH_VETO"
                                ],
                                "type": "string"
                            },
                            "options": {
                                "type": "array",
                                "items": {
                                    "description": "WeightedVoteOption defines a unit of vote for vote split.",
                                    "type": "object",
                                    "properties": {
                                        "option": {
                                            "description": "VoteOption enumerates the valid vote options for a given governance proposal.\n\n - VOTE_OPTION_UNSPECIFIED: VOTE_OPTION_UNSPECIFIED defines a no-op vote option.\n - VOTE_OPTION_YES: VOTE_OPTION_YES defines a yes vote option.\n - VOTE_OPTION_ABSTAIN: VOTE_OPTION_ABSTAIN defines an abstain vote option.\n - VOTE_OPTION_NO: VOTE_OPTION_NO defines a no vote option.\n - VOTE_OPTION_NO_WITH_VETO: VOTE_OPTION_NO_WITH_VETO defines a no with veto vote option.",
                                            "default": "VOTE_OPTION_UNSPECIFIED",
                                            "enum": [
                                                "VOTE_OPTION_UNSPECIFIED",
                                                "VOTE_OPTION_YES",
                                                "VOTE_OPTION_ABSTAIN",
                                                "VOTE_OPTION_NO",
                                                "VOTE_OPTION_NO_WITH_VETO"
                                            ],
                                            "type": "string"
                                        },
                                        "weight": {
                                            "type": "string"
                                        }
                                    }
                                }
                            }
                        }
                    }
                },
                "pagination": {
                    "description": "pagination defines the pagination in the response.",
                    "type": "object",
                    "properties": {
                        "next_key": {
                            "format": "byte",
                            "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently",
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string"
                        },
                        "total": {
                            "format": "uint64",
                            "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                            "type": "string"
                        }
                    }
                }
            }
        },
        "cosmos.gov.v1beta1.TallyParams": {
            "description": "TallyParams defines the params for tallying votes on governance proposals.",
            "type": "object",
            "properties": {
                "quorum": {
                    "format": "byte",
                    "description": "Minimum percentage of total stake needed to vote for a result to be\n considered valid.",
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string"
                },
                "threshold": {
                    "format": "byte",
                    "description": "Minimum proportion of Yes votes for proposal to pass. Default value: 0.5.",
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string"
                },
                "veto_threshold": {
                    "format": "byte",
                    "description": "Minimum value of Veto votes to Total votes ratio for proposal to be\n vetoed. Default value: 1/3.",
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string"
                }
            }
        },
        "cosmos.gov.v1beta1.TallyResult": {
            "description": "TallyResult defines a standard tally for a governance proposal.",
            "type": "object",
            "properties": {
                "yes": {
                    "type": "string"
                },
                "abstain": {
                    "type": "string"
                },
                "no": {
                    "type": "string"
                },
                "no_with_veto": {
                    "type": "string"
                }
            }
        },
        "cosmos.gov.v1beta1.Vote": {
            "description": "Vote defines a vote on a governance proposal.\nA Vote consists of a proposal ID, the voter, and the vote option.",
            "type": "object",
            "properties": {
                "proposal_id": {
                    "format": "uint64",
                    "type": "string"
                },
                "voter": {
                    "type": "string"
                },
                "option": {
                    "description": "Deprecated: Prefer to use `options` instead. This field is set in queries\nif and only if `len(options) == 1` and that option has weight 1. In all\nother cases, this field will default to VOTE_OPTION_UNSPECIFIED.",
                    "default": "VOTE_OPTION_UNSPECIFIED",
                    "enum": [
                        "VOTE_OPTION_UNSPECIFIED",
                        "VOTE_OPTION_YES",
                        "VOTE_OPTION_ABSTAIN",
                        "VOTE_OPTION_NO",
                        "VOTE_OPTION_NO_WITH_VETO"
                    ],
                    "type": "string"
                },
                "options": {
                    "type": "array",
                    "items": {
                        "description": "WeightedVoteOption defines a unit of vote for vote split.",
                        "type": "object",
                        "properties": {
                            "option": {
                                "description": "VoteOption enumerates the valid vote options for a given governance proposal.\n\n - VOTE_OPTION_UNSPECIFIED: VOTE_OPTION_UNSPECIFIED defines a no-op vote option.\n - VOTE_OPTION_YES: VOTE_OPTION_YES defines a yes vote option.\n - VOTE_OPTION_ABSTAIN: VOTE_OPTION_ABSTAIN defines an abstain vote option.\n - VOTE_OPTION_NO: VOTE_OPTION_NO defines a no vote option.\n - VOTE_OPTION_NO_WITH_VETO: VOTE_OPTION_NO_WITH_VETO defines a no with veto vote option.",
                                "default": "VOTE_OPTION_UNSPECIFIED",
                                "enum": [
                                    "VOTE_OPTION_UNSPECIFIED",
                                    "VOTE_OPTION_YES",
                                    "VOTE_OPTION_ABSTAIN",
                                    "VOTE_OPTION_NO",
                                    "VOTE_OPTION_NO_WITH_VETO"
                                ],
                                "type": "string"
                            },
                            "weight": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        },
        "cosmos.gov.v1beta1.VoteOption": {
            "description": "VoteOption enumerates the valid vote options for a given governance proposal.\n\n - VOTE_OPTION_UNSPECIFIED: VOTE_OPTION_UNSPECIFIED defines a no-op vote option.\n - VOTE_OPTION_YES: VOTE_OPTION_YES defines a yes vote option.\n - VOTE_OPTION_ABSTAIN: VOTE_OPTION_ABSTAIN defines an abstain vote option.\n - VOTE_OPTION_NO: VOTE_OPTION_NO defines a no vote option.\n - VOTE_OPTION_NO_WITH_VETO: VOTE_OPTION_NO_WITH_VETO defines a no with veto vote option.",
            "default": "VOTE_OPTION_UNSPECIFIED",
            "enum": [
                "VOTE_OPTION_UNSPECIFIED",
                "VOTE_OPTION_YES",
                "VOTE_OPTION_ABSTAIN",
                "VOTE_OPTION_NO",
                "VOTE_OPTION_NO_WITH_VETO"
            ],
            "type": "string"
        },
        "cosmos.gov.v1beta1.VotingParams": {
            "description": "VotingParams defines the params for voting on governance proposals.",
            "type": "object",
            "properties": {
                "voting_period": {
                    "description": "Length of the voting period.",
                    "type": "string"
                }
            }
        },
        "cosmos.gov.v1beta1.WeightedVoteOption": {
            "description": "WeightedVoteOption defines a unit of vote for vote split.",
            "type": "object",
            "properties": {
                "option": {
                    "description": "VoteOption enumerates the valid vote options for a given governance proposal.\n\n - VOTE_OPTION_UNSPECIFIED: VOTE_OPTION_UNSPECIFIED defines a no-op vote option.\n - VOTE_OPTION_YES: VOTE_OPTION_YES defines a yes vote option.\n - VOTE_OPTION_ABSTAIN: VOTE_OPTION_ABSTAIN defines an abstain vote option.\n - VOTE_OPTION_NO: VOTE_OPTION_NO defines a no vote option.\n - VOTE_OPTION_NO_WITH_VETO: VOTE_OPTION_NO_WITH_VETO defines a no with veto vote option.",
                    "default": "VOTE_OPTION_UNSPECIFIED",
                    "enum": [
                        "VOTE_OPTION_UNSPECIFIED",
                        "VOTE_OPTION_YES",
                        "VOTE_OPTION_ABSTAIN",
                        "VOTE_OPTION_NO",
                        "VOTE_OPTION_NO_WITH_VETO"
                    ],
                    "type": "string"
                },
                "weight": {
                    "type": "string"
                }
            }
        },
        "cosmos.mint.v1beta1.Params": {
            "description": "Params holds parameters for the mint module.",
            "type": "object",
            "properties": {
                "mint_denom": {
                    "title": "type of coin to mint",
                    "type": "string"
                },
                "inflation_rate_change": {
                    "title": "maximum annual change in inflation rate",
                    "type": "string"
                },
                "inflation_max": {
                    "title": "maximum inflation rate",
                    "type": "string"
                },
                "inflation_min": {
                    "title": "minimum inflation rate",
                    "type": "string"
                },
                "goal_bonded": {
                    "title": "goal of percent bonded atoms",
                    "type": "string"
                },
                "blocks_per_year": {
                    "format": "uint64",
                    "title": "expected blocks per year",
                    "type": "string"
                }
            }
        },
        "cosmos.mint.v1beta1.QueryAnnualProvisionsResponse": {
            "description": "QueryAnnualProvisionsResponse is the response type for the\nQuery/AnnualProvisions RPC method.",
            "type": "object",
            "properties": {
                "annual_provisions": {
                    "format": "byte",
                    "description": "annual_provisions is the current minting annual provisions value.",
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string"
                }
            }
        },
        "cosmos.mint.v1beta1.QueryInflationResponse": {
            "description": "QueryInflationResponse is the response type for the Query/Inflation RPC\nmethod.",
            "type": "object",
            "properties": {
                "inflation": {
                    "format": "byte",
                    "description": "inflation is the current minting inflation value.",
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string"
                }
            }
        },
        "cosmos.mint.v1beta1.QueryParamsResponse": {
            "description": "QueryParamsResponse is the response type for the Query/Params RPC method.",
            "type": "object",
            "properties": {
                "params": {
                    "description": "params defines the parameters of the module.",
                    "type": "object",
                    "properties": {
                        "mint_denom": {
                            "title": "type of coin to mint",
                            "type": "string"
                        },
                        "inflation_rate_change": {
                            "title": "maximum annual change in inflation rate",
                            "type": "string"
                        },
                        "inflation_max": {
                            "title": "maximum inflation rate",
                            "type": "string"
                        },
                        "inflation_min": {
                            "title": "minimum inflation rate",
                            "type": "string"
                        },
                        "goal_bonded": {
                            "title": "goal of percent bonded atoms",
                            "type": "string"
                        },
                        "blocks_per_year": {
                            "format": "uint64",
                            "title": "expected blocks per year",
                            "type": "string"
                        }
                    }
                }
            }
        },
        "cosmos.params.v1beta1.ParamChange": {
            "description": "ParamChange defines an individual parameter change, for use in\nParameterChangeProposal.",
            "type": "object",
            "properties": {
                "subspace": {
                    "type": "string"
                },
                "key": {
                    "type": "string"
                },
                "value": {
                    "type": "string"
                }
            }
        },
        "cosmos.params.v1beta1.QueryParamsResponse": {
            "description": "QueryParamsResponse is response type for the Query/Params RPC method.",
            "type": "object",
            "properties": {
                "param": {
                    "description": "param defines the queried parameter.",
                    "type": "object",
                    "properties": {
                        "subspace": {
                            "type": "string"
                        },
                        "key": {
                            "type": "string"
                        },
                        "value": {
                            "type": "string"
                        }
                    }
                }
            }
        },
        "cosmos.slashing.v1beta1.Params": {
            "description": "Params represents the parameters used for by the slashing module.",
            "type": "object",
            "properties": {
                "signed_blocks_window": {
                    "format": "int64",
                    "type": "string"
                },
                "min_signed_per_window": {
                    "format": "byte",
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string"
                },
                "downtime_jail_duration": {
                    "type": "string"
                },
                "slash_fraction_double_sign": {
                    "format": "byte",
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string"
                },
                "slash_fraction_downtime": {
                    "format": "byte",
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string"
                }
            }
        },
        "cosmos.slashing.v1beta1.QueryParamsResponse": {
            "title": "QueryParamsResponse is the response type for the Query/Params RPC method",
            "type": "object",
            "properties": {
                "params": {
                    "description": "Params represents the parameters used for by the slashing module.",
                    "type": "object",
                    "properties": {
                        "signed_blocks_window": {
                            "format": "int64",
                            "type": "string"
                        },
                        "min_signed_per_window": {
                            "format": "byte",
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string"
                        },
                        "downtime_jail_duration": {
                            "type": "string"
                        },
                        "slash_fraction_double_sign": {
                            "format": "byte",
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string"
                        },
                        "slash_fraction_downtime": {
                            "format": "byte",
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string"
                        }
                    }
                }
            }
        },
        "cosmos.slashing.v1beta1.QuerySigningInfoResponse": {
            "title": "QuerySigningInfoResponse is the response type for the Query/SigningInfo RPC\nmethod",
            "type": "object",
            "properties": {
                "val_signing_info": {
                    "title": "val_signing_info is the signing info of requested val cons address",
                    "description": "ValidatorSigningInfo defines a validator's signing info for monitoring their\nliveness activity.",
                    "type": "object",
                    "properties": {
                        "address": {
                            "type": "string"
                        },
                        "start_height": {
                            "format": "int64",
                            "title": "Height at which validator was first a candidate OR was unjailed",
                            "type": "string"
                        },
                        "index_offset": {
                            "format": "int64",
                            "description": "Index which is incremented each time the validator was a bonded\nin a block and may have signed a precommit or not. This in conjunction with the\n`SignedBlocksWindow` param determines the index in the `MissedBlocksBitArray`.",
                            "type": "string"
                        },
                        "jailed_until": {
                            "format": "date-time",
                            "description": "Timestamp until which the validator is jailed due to liveness downtime.",
                            "type": "string"
                        },
                        "tombstoned": {
                            "format": "boolean",
                            "description": "Whether or not a validator has been tombstoned (killed out of validator set). It is set\nonce the validator commits an equivocation or for any other configured misbehiavor.",
                            "type": "boolean"
                        },
                        "missed_blocks_counter": {
                            "format": "int64",
                            "description": "A counter kept to avoid unnecessary array reads.\nNote that `Sum(MissedBlocksBitArray)` always equals `MissedBlocksCounter`.",
                            "type": "string"
                        }
                    }
                }
            }
        },
        "cosmos.slashing.v1beta1.QuerySigningInfosResponse": {
            "title": "QuerySigningInfosResponse is the response type for the Query/SigningInfos RPC\nmethod",
            "type": "object",
            "properties": {
                "info": {
                    "title": "info is the signing info of all validators",
                    "type": "array",
                    "items": {
                        "description": "ValidatorSigningInfo defines a validator's signing info for monitoring their\nliveness activity.",
                        "type": "object",
                        "properties": {
                            "address": {
                                "type": "string"
                            },
                            "start_height": {
                                "format": "int64",
                                "title": "Height at which validator was first a candidate OR was unjailed",
                                "type": "string"
                            },
                            "index_offset": {
                                "format": "int64",
                                "description": "Index which is incremented each time the validator was a bonded\nin a block and may have signed a precommit or not. This in conjunction with the\n`SignedBlocksWindow` param determines the index in the `MissedBlocksBitArray`.",
                                "type": "string"
                            },
                            "jailed_until": {
                                "format": "date-time",
                                "description": "Timestamp until which the validator is jailed due to liveness downtime.",
                                "type": "string"
                            },
                            "tombstoned": {
                                "format": "boolean",
                                "description": "Whether or not a validator has been tombstoned (killed out of validator set). It is set\nonce the validator commits an equivocation or for any other configured misbehiavor.",
                                "type": "boolean"
                            },
                            "missed_blocks_counter": {
                                "format": "int64",
                                "description": "A counter kept to avoid unnecessary array reads.\nNote that `Sum(MissedBlocksBitArray)` always equals `MissedBlocksCounter`.",
                                "type": "string"
                            }
                        }
                    }
                },
                "pagination": {
                    "description": "PageResponse is to be embedded in gRPC response messages where the\ncorresponding request message has used PageRequest.\n\n message SomeResponse {\n         repeated Bar results = 1;\n         PageResponse page = 2;\n }",
                    "type": "object",
                    "properties": {
                        "next_key": {
                            "format": "byte",
                            "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently",
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string"
                        },
                        "total": {
                            "format": "uint64",
                            "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                            "type": "string"
                        }
                    }
                }
            }
        },
        "cosmos.slashing.v1beta1.ValidatorSigningInfo": {
            "description": "ValidatorSigningInfo defines a validator's signing info for monitoring their\nliveness activity.",
            "type": "object",
            "properties": {
                "address": {
                    "type": "string"
                },
                "start_height": {
                    "format": "int64",
                    "title": "Height at which validator was first a candidate OR was unjailed",
                    "type": "string"
                },
                "index_offset": {
                    "format": "int64",
                    "description": "Index which is incremented each time the validator was a bonded\nin a block and may have signed a precommit or not. This in conjunction with the\n`SignedBlocksWindow` param determines the index in the `MissedBlocksBitArray`.",
                    "type": "string"
                },
                "jailed_until": {
                    "format": "date-time",
                    "description": "Timestamp until which the validator is jailed due to liveness downtime.",
                    "type": "string"
                },
                "tombstoned": {
                    "format": "boolean",
                    "description": "Whether or not a validator has been tombstoned (killed out of validator set). It is set\nonce the validator commits an equivocation or for any other configured misbehiavor.",
                    "type": "boolean"
                },
                "missed_blocks_counter": {
                    "format": "int64",
                    "description": "A counter kept to avoid unnecessary array reads.\nNote that `Sum(MissedBlocksBitArray)` always equals `MissedBlocksCounter`.",
                    "type": "string"
                }
            }
        },
        "cosmos.staking.v1beta1.BondStatus": {
            "description": "BondStatus is the status of a validator.\n\n - BOND_STATUS_UNSPECIFIED: UNSPECIFIED defines an invalid validator status.\n - BOND_STATUS_UNBONDED: UNBONDED defines a validator that is not bonded.\n - BOND_STATUS_UNBONDING: UNBONDING defines a validator that is unbonding.\n - BOND_STATUS_BONDED: BONDED defines a validator that is bonded.",
            "default": "BOND_STATUS_UNSPECIFIED",
            "enum": [
                "BOND_STATUS_UNSPECIFIED",
                "BOND_STATUS_UNBONDED",
                "BOND_STATUS_UNBONDING",
                "BOND_STATUS_BONDED"
            ],
            "type": "string"
        },
        "cosmos.staking.v1beta1.Commission": {
            "description": "Commission defines commission parameters for a given validator.",
            "type": "object",
            "properties": {
                "commission_rates": {
                    "description": "commission_rates defines the initial commission rates to be used for creating a validator.",
                    "type": "object",
                    "properties": {
                        "rate": {
                            "description": "rate is the commission rate charged to delegators, as a fraction.",
                            "type": "string"
                        },
                        "max_rate": {
                            "description": "max_rate defines the maximum commission rate which validator can ever charge, as a fraction.",
                            "type": "string"
                        },
                        "max_change_rate": {
                            "description": "max_change_rate defines the maximum daily increase of the validator commission, as a fraction.",
                            "type": "string"
                        }
                    }
                },
                "update_time": {
                    "format": "date-time",
                    "description": "update_time is the last time the commission rate was changed.",
                    "type": "string"
                }
            }
        },
        "cosmos.staking.v1beta1.CommissionRates": {
            "description": "CommissionRates defines the initial commission rates to be used for creating\na validator.",
            "type": "object",
            "properties": {
                "rate": {
                    "description": "rate is the commission rate charged to delegators, as a fraction.",
                    "type": "string"
                },
                "max_rate": {
                    "description": "max_rate defines the maximum commission rate which validator can ever charge, as a fraction.",
                    "type": "string"
                },
                "max_change_rate": {
                    "description": "max_change_rate defines the maximum daily increase of the validator commission, as a fraction.",
                    "type": "string"
                }
            }
        },
        "cosmos.staking.v1beta1.Delegation": {
            "description": "Delegation represents the bond with tokens held by an account. It is\nowned by one delegator, and is associated with the voting power of one\nvalidator.",
            "type": "object",
            "properties": {
                "delegator_address": {
                    "description": "delegator_address is the bech32-encoded address of the delegator.",
                    "type": "string"
                },
                "validator_address": {
                    "description": "validator_address is the bech32-encoded address of the validator.",
                    "type": "string"
                },
                "shares": {
                    "description": "shares define the delegation shares received.",
                    "type": "string"
                }
            }
        },
        "cosmos.staking.v1beta1.DelegationResponse": {
            "description": "DelegationResponse is equivalent to Delegation except that it contains a\nbalance in addition to shares which is more suitable for client responses.",
            "type": "object",
            "properties": {
                "delegation": {
                    "description": "Delegation represents the bond with tokens held by an account. It is\nowned by one delegator, and is associated with the voting power of one\nvalidator.",
                    "type": "object",
                    "properties": {
                        "delegator_address": {
                            "description": "delegator_address is the bech32-encoded address of the delegator.",
                            "type": "string"
                        },
                        "validator_address": {
                            "description": "validator_address is the bech32-encoded address of the validator.",
                            "type": "string"
                        },
                        "shares": {
                            "description": "shares define the delegation shares received.",
                            "type": "string"
                        }
                    }
                },
                "balance": {
                    "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto.",
                    "type": "object",
                    "properties": {
                        "denom": {
                            "type": "string"
                        },
                        "amount": {
                            "type": "string"
                        }
                    }
                }
            }
        },
        "cosmos.staking.v1beta1.Description": {
            "description": "Description defines a validator description.",
            "type": "object",
            "properties": {
                "moniker": {
                    "description": "moniker defines a human-readable name for the validator.",
                    "type": "string"
                },
                "identity": {
                    "description": "identity defines an optional identity signature (ex. UPort or Keybase).",
                    "type": "string"
                },
                "website": {
                    "description": "website defines an optional website link.",
                    "type": "string"
                },
                "security_contact": {
                    "description": "security_contact defines an optional email for security contact.",
                    "type": "string"
                },
                "details": {
                    "description": "details define other optional details.",
                    "type": "string"
                }
            }
        },
        "cosmos.staking.v1beta1.HistoricalInfo": {
            "description": "HistoricalInfo contains header and validator information for a given block.\nIt is stored as part of staking module's state, which persists the `n` most\nrecent HistoricalInfo\n(`n` is set by the staking module's `historical_entries` parameter).",
            "type": "object",
            "properties": {
                "header": {
                    "description": "Header defines the structure of a Tendermint block header.",
                    "type": "object",
                    "properties": {
                        "version": {
                            "title": "basic block info",
                            "description": "Consensus captures the consensus rules for processing a block in the blockchain,\nincluding all blockchain data structures and the rules of the application's\nstate transition machine.",
                            "type": "object",
                            "properties": {
                                "block": {
                                    "format": "uint64",
                                    "type": "string"
                                },
                                "app": {
                                    "format": "uint64",
                                    "type": "string"
                                }
                            }
                        },
                        "chain_id": {
                            "type": "string"
                        },
                        "height": {
                            "format": "int64",
                            "type": "string"
                        },
                        "time": {
                            "format": "date-time",
                            "type": "string"
                        },
                        "last_block_id": {
                            "title": "prev block info",
                            "type": "object",
                            "properties": {
                                "hash": {
                                    "format": "byte",
                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                    "type": "string"
                                },
                                "part_set_header": {
                                    "title": "PartsetHeader",
                                    "type": "object",
                                    "properties": {
                                        "total": {
                                            "format": "int64",
                                            "type": "integer"
                                        },
                                        "hash": {
                                            "format": "byte",
                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                            "type": "string"
                                        }
                                    }
                                }
                            }
                        },
                        "last_commit_hash": {
                            "format": "byte",
                            "title": "hashes of block data",
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string"
                        },
                        "data_hash": {
                            "format": "byte",
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string"
                        },
                        "validators_hash": {
                            "format": "byte",
                            "title": "hashes from the app output from the prev block",
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string"
                        },
                        "next_validators_hash": {
                            "format": "byte",
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string"
                        },
                        "consensus_hash": {
                            "format": "byte",
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string"
                        },
                        "app_hash": {
                            "format": "byte",
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string"
                        },
                        "last_results_hash": {
                            "format": "byte",
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string"
                        },
                        "evidence_hash": {
                            "format": "byte",
                            "title": "consensus info",
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string"
                        },
                        "proposer_address": {
                            "format": "byte",
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string"
                        }
                    }
                },
                "valset": {
                    "type": "array",
                    "items": {
                        "description": "Validator defines a validator, together with the total amount of the\nValidator's bond shares and their exchange rate to coins. Slashing results in\na decrease in the exchange rate, allowing correct calculation of future\nundelegations without iterating over delegators. When coins are delegated to\nthis validator, the validator is credited with a delegation whose number of\nbond shares is based on the amount of coins delegated divided by the current\nexchange rate. Voting power can be calculated as total bonded shares\nmultiplied by exchange rate.",
                        "type": "object",
                        "properties": {
                            "operator_address": {
                                "description": "operator_address defines the address of the validator's operator; bech encoded in JSON.",
                                "type": "string"
                            },
                            "consensus_pubkey": {
                                "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                "type": "object",
                                "properties": {
                                    "type_url": {
                                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                        "type": "string"
                                    },
                                    "value": {
                                        "format": "byte",
                                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                        "type": "string"
                                    }
                                }
                            },
                            "jailed": {
                                "format": "boolean",
                                "description": "jailed defined whether the validator has been jailed from bonded status or not.",
                                "type": "boolean"
                            },
                            "status": {
                                "description": "status is the validator status (bonded/unbonding/unbonded).",
                                "default": "BOND_STATUS_UNSPECIFIED",
                                "enum": [
                                    "BOND_STATUS_UNSPECIFIED",
                                    "BOND_STATUS_UNBONDED",
                                    "BOND_STATUS_UNBONDING",
                                    "BOND_STATUS_BONDED"
                                ],
                                "type": "string"
                            },
                            "tokens": {
                                "description": "tokens define the delegated tokens (incl. self-delegation).",
                                "type": "string"
                            },
                            "delegator_shares": {
                                "description": "delegator_shares defines total shares issued to a validator's delegators.",
                                "type": "string"
                            },
                            "description": {
                                "description": "description defines the description terms for the validator.",
                                "type": "object",
                                "properties": {
                                    "moniker": {
                                        "description": "moniker defines a human-readable name for the validator.",
                                        "type": "string"
                                    },
                                    "identity": {
                                        "description": "identity defines an optional identity signature (ex. UPort or Keybase).",
                                        "type": "string"
                                    },
                                    "website": {
                                        "description": "website defines an optional website link.",
                                        "type": "string"
                                    },
                                    "security_contact": {
                                        "description": "security_contact defines an optional email for security contact.",
                                        "type": "string"
                                    },
                                    "details": {
                                        "description": "details define other optional details.",
                                        "type": "string"
                                    }
                                }
                            },
                            "unbonding_height": {
                                "format": "int64",
                                "description": "unbonding_height defines, if unbonding, the height at which this validator has begun unbonding.",
                                "type": "string"
                            },
                            "unbonding_time": {
                                "format": "date-time",
                                "description": "unbonding_time defines, if unbonding, the min time for the validator to complete unbonding.",
                                "type": "string"
                            },
                            "commission": {
                                "description": "commission defines the commission parameters.",
                                "type": "object",
                                "properties": {
                                    "commission_rates": {
                                        "description": "commission_rates defines the initial commission rates to be used for creating a validator.",
                                        "type": "object",
                                        "properties": {
                                            "rate": {
                                                "description": "rate is the commission rate charged to delegators, as a fraction.",
                                                "type": "string"
                                            },
                                            "max_rate": {
                                                "description": "max_rate defines the maximum commission rate which validator can ever charge, as a fraction.",
                                                "type": "string"
                                            },
                                            "max_change_rate": {
                                                "description": "max_change_rate defines the maximum daily increase of the validator commission, as a fraction.",
                                                "type": "string"
                                            }
                                        }
                                    },
                                    "update_time": {
                                        "format": "date-time",
                                        "description": "update_time is the last time the commission rate was changed.",
                                        "type": "string"
                                    }
                                }
                            },
                            "min_self_delegation": {
                                "description": "min_self_delegation is the validator's self declared minimum self delegation.",
                                "type": "string"
                            }
                        }
                    }
                }
            }
        },
        "cosmos.staking.v1beta1.Params": {
            "description": "Params defines the parameters for the staking module.",
            "type": "object",
            "properties": {
                "unbonding_time": {
                    "description": "unbonding_time is the time duration of unbonding.",
                    "type": "string"
                },
                "max_validators": {
                    "format": "int64",
                    "description": "max_validators is the maximum number of validators.",
                    "type": "integer"
                },
                "max_entries": {
                    "format": "int64",
                    "description": "max_entries is the max entries for either unbonding delegation or redelegation (per pair/trio).",
                    "type": "integer"
                },
                "historical_entries": {
                    "format": "int64",
                    "description": "historical_entries is the number of historical entries to persist.",
                    "type": "integer"
                },
                "bond_denom": {
                    "description": "bond_denom defines the bondable coin denomination.",
                    "type": "string"
                }
            }
        },
        "cosmos.staking.v1beta1.Pool": {
            "description": "Pool is used for tracking bonded and not-bonded token supply of the bond\ndenomination.",
            "type": "object",
            "properties": {
                "not_bonded_tokens": {
                    "type": "string"
                },
                "bonded_tokens": {
                    "type": "string"
                }
            }
        },
        "cosmos.staking.v1beta1.QueryDelegationResponse": {
            "description": "QueryDelegationResponse is response type for the Query/Delegation RPC method.",
            "type": "object",
            "properties": {
                "delegation_response": {
                    "description": "DelegationResponse is equivalent to Delegation except that it contains a\nbalance in addition to shares which is more suitable for client responses.",
                    "type": "object",
                    "properties": {
                        "delegation": {
                            "description": "Delegation represents the bond with tokens held by an account. It is\nowned by one delegator, and is associated with the voting power of one\nvalidator.",
                            "type": "object",
                            "properties": {
                                "delegator_address": {
                                    "description": "delegator_address is the bech32-encoded address of the delegator.",
                                    "type": "string"
                                },
                                "validator_address": {
                                    "description": "validator_address is the bech32-encoded address of the validator.",
                                    "type": "string"
                                },
                                "shares": {
                                    "description": "shares define the delegation shares received.",
                                    "type": "string"
                                }
                            }
                        },
                        "balance": {
                            "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto.",
                            "type": "object",
                            "properties": {
                                "denom": {
                                    "type": "string"
                                },
                                "amount": {
                                    "type": "string"
                                }
                            }
                        }
                    }
                }
            }
        },
        "cosmos.staking.v1beta1.QueryDelegatorDelegationsResponse": {
            "description": "QueryDelegatorDelegationsResponse is response type for the\nQuery/DelegatorDelegations RPC method.",
            "type": "object",
            "properties": {
                "delegation_responses": {
                    "description": "delegation_responses defines all the delegations' info of a delegator.",
                    "type": "array",
                    "items": {
                        "description": "DelegationResponse is equivalent to Delegation except that it contains a\nbalance in addition to shares which is more suitable for client responses.",
                        "type": "object",
                        "properties": {
                            "delegation": {
                                "description": "Delegation represents the bond with tokens held by an account. It is\nowned by one delegator, and is associated with the voting power of one\nvalidator.",
                                "type": "object",
                                "properties": {
                                    "delegator_address": {
                                        "description": "delegator_address is the bech32-encoded address of the delegator.",
                                        "type": "string"
                                    },
                                    "validator_address": {
                                        "description": "validator_address is the bech32-encoded address of the validator.",
                                        "type": "string"
                                    },
                                    "shares": {
                                        "description": "shares define the delegation shares received.",
                                        "type": "string"
                                    }
                                }
                            },
                            "balance": {
                                "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto.",
                                "type": "object",
                                "properties": {
                                    "denom": {
                                        "type": "string"
                                    },
                                    "amount": {
                                        "type": "string"
                                    }
                                }
                            }
                        }
                    }
                },
                "pagination": {
                    "description": "pagination defines the pagination in the response.",
                    "type": "object",
                    "properties": {
                        "next_key": {
                            "format": "byte",
                            "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently",
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string"
                        },
                        "total": {
                            "format": "uint64",
                            "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                            "type": "string"
                        }
                    }
                }
            }
        },
        "cosmos.staking.v1beta1.QueryDelegatorUnbondingDelegationsResponse": {
            "description": "QueryUnbondingDelegatorDelegationsResponse is response type for the\nQuery/UnbondingDelegatorDelegations RPC method.",
            "type": "object",
            "properties": {
                "unbonding_responses": {
                    "type": "array",
                    "items": {
                        "description": "UnbondingDelegation stores all of a single delegator's unbonding bonds\nfor a single validator in an time-ordered list.",
                        "type": "object",
                        "properties": {
                            "delegator_address": {
                                "description": "delegator_address is the bech32-encoded address of the delegator.",
                                "type": "string"
                            },
                            "validator_address": {
                                "description": "validator_address is the bech32-encoded address of the validator.",
                                "type": "string"
                            },
                            "entries": {
                                "description": "entries are the unbonding delegation entries.",
                                "type": "array",
                                "items": {
                                    "description": "UnbondingDelegationEntry defines an unbonding object with relevant metadata.",
                                    "type": "object",
                                    "properties": {
                                        "creation_height": {
                                            "format": "int64",
                                            "description": "creation_height is the height which the unbonding took place.",
                                            "type": "string"
                                        },
                                        "completion_time": {
                                            "format": "date-time",
                                            "description": "completion_time is the unix time for unbonding completion.",
                                            "type": "string"
                                        },
                                        "initial_balance": {
                                            "description": "initial_balance defines the tokens initially scheduled to receive at completion.",
                                            "type": "string"
                                        },
                                        "balance": {
                                            "description": "balance defines the tokens to receive at completion.",
                                            "type": "string"
                                        }
                                    }
                                }
                            }
                        }
                    }
                },
                "pagination": {
                    "description": "pagination defines the pagination in the response.",
                    "type": "object",
                    "properties": {
                        "next_key": {
                            "format": "byte",
                            "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently",
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string"
                        },
                        "total": {
                            "format": "uint64",
                            "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                            "type": "string"
                        }
                    }
                }
            }
        },
        "cosmos.staking.v1beta1.QueryDelegatorValidatorResponse": {
            "description": "QueryDelegatorValidatorResponse response type for the\nQuery/DelegatorValidator RPC method.",
            "type": "object",
            "properties": {
                "validator": {
                    "description": "Validator defines a validator, together with the total amount of the\nValidator's bond shares and their exchange rate to coins. Slashing results in\na decrease in the exchange rate, allowing correct calculation of future\nundelegations without iterating over delegators. When coins are delegated to\nthis validator, the validator is credited with a delegation whose number of\nbond shares is based on the amount of coins delegated divided by the current\nexchange rate. Voting power can be calculated as total bonded shares\nmultiplied by exchange rate.",
                    "type": "object",
                    "properties": {
                        "operator_address": {
                            "description": "operator_address defines the address of the validator's operator; bech encoded in JSON.",
                            "type": "string"
                        },
                        "consensus_pubkey": {
                            "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                            "type": "object",
                            "properties": {
                                "type_url": {
                                    "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                    "type": "string"
                                },
                                "value": {
                                    "format": "byte",
                                    "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                    "type": "string"
                                }
                            }
                        },
                        "jailed": {
                            "format": "boolean",
                            "description": "jailed defined whether the validator has been jailed from bonded status or not.",
                            "type": "boolean"
                        },
                        "status": {
                            "description": "status is the validator status (bonded/unbonding/unbonded).",
                            "default": "BOND_STATUS_UNSPECIFIED",
                            "enum": [
                                "BOND_STATUS_UNSPECIFIED",
                                "BOND_STATUS_UNBONDED",
                                "BOND_STATUS_UNBONDING",
                                "BOND_STATUS_BONDED"
                            ],
                            "type": "string"
                        },
                        "tokens": {
                            "description": "tokens define the delegated tokens (incl. self-delegation).",
                            "type": "string"
                        },
                        "delegator_shares": {
                            "description": "delegator_shares defines total shares issued to a validator's delegators.",
                            "type": "string"
                        },
                        "description": {
                            "description": "description defines the description terms for the validator.",
                            "type": "object",
                            "properties": {
                                "moniker": {
                                    "description": "moniker defines a human-readable name for the validator.",
                                    "type": "string"
                                },
                                "identity": {
                                    "description": "identity defines an optional identity signature (ex. UPort or Keybase).",
                                    "type": "string"
                                },
                                "website": {
                                    "description": "website defines an optional website link.",
                                    "type": "string"
                                },
                                "security_contact": {
                                    "description": "security_contact defines an optional email for security contact.",
                                    "type": "string"
                                },
                                "details": {
                                    "description": "details define other optional details.",
                                    "type": "string"
                                }
                            }
                        },
                        "unbonding_height": {
                            "format": "int64",
                            "description": "unbonding_height defines, if unbonding, the height at which this validator has begun unbonding.",
                            "type": "string"
                        },
                        "unbonding_time": {
                            "format": "date-time",
                            "description": "unbonding_time defines, if unbonding, the min time for the validator to complete unbonding.",
                            "type": "string"
                        },
                        "commission": {
                            "description": "commission defines the commission parameters.",
                            "type": "object",
                            "properties": {
                                "commission_rates": {
                                    "description": "commission_rates defines the initial commission rates to be used for creating a validator.",
                                    "type": "object",
                                    "properties": {
                                        "rate": {
                                            "description": "rate is the commission rate charged to delegators, as a fraction.",
                                            "type": "string"
                                        },
                                        "max_rate": {
                                            "description": "max_rate defines the maximum commission rate which validator can ever charge, as a fraction.",
                                            "type": "string"
                                        },
                                        "max_change_rate": {
                                            "description": "max_change_rate defines the maximum daily increase of the validator commission, as a fraction.",
                                            "type": "string"
                                        }
                                    }
                                },
                                "update_time": {
                                    "format": "date-time",
                                    "description": "update_time is the last time the commission rate was changed.",
                                    "type": "string"
                                }
                            }
                        },
                        "min_self_delegation": {
                            "description": "min_self_delegation is the validator's self declared minimum self delegation.",
                            "type": "string"
                        }
                    }
                }
            }
        },
        "cosmos.staking.v1beta1.QueryDelegatorValidatorsResponse": {
            "description": "QueryDelegatorValidatorsResponse is response type for the\nQuery/DelegatorValidators RPC method.",
            "type": "object",
            "properties": {
                "validators": {
                    "description": "validators defines the the validators' info of a delegator.",
                    "type": "array",
                    "items": {
                        "description": "Validator defines a validator, together with the total amount of the\nValidator's bond shares and their exchange rate to coins. Slashing results in\na decrease in the exchange rate, allowing correct calculation of future\nundelegations without iterating over delegators. When coins are delegated to\nthis validator, the validator is credited with a delegation whose number of\nbond shares is based on the amount of coins delegated divided by the current\nexchange rate. Voting power can be calculated as total bonded shares\nmultiplied by exchange rate.",
                        "type": "object",
                        "properties": {
                            "operator_address": {
                                "description": "operator_address defines the address of the validator's operator; bech encoded in JSON.",
                                "type": "string"
                            },
                            "consensus_pubkey": {
                                "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                "type": "object",
                                "properties": {
                                    "type_url": {
                                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                        "type": "string"
                                    },
                                    "value": {
                                        "format": "byte",
                                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                        "type": "string"
                                    }
                                }
                            },
                            "jailed": {
                                "format": "boolean",
                                "description": "jailed defined whether the validator has been jailed from bonded status or not.",
                                "type": "boolean"
                            },
                            "status": {
                                "description": "status is the validator status (bonded/unbonding/unbonded).",
                                "default": "BOND_STATUS_UNSPECIFIED",
                                "enum": [
                                    "BOND_STATUS_UNSPECIFIED",
                                    "BOND_STATUS_UNBONDED",
                                    "BOND_STATUS_UNBONDING",
                                    "BOND_STATUS_BONDED"
                                ],
                                "type": "string"
                            },
                            "tokens": {
                                "description": "tokens define the delegated tokens (incl. self-delegation).",
                                "type": "string"
                            },
                            "delegator_shares": {
                                "description": "delegator_shares defines total shares issued to a validator's delegators.",
                                "type": "string"
                            },
                            "description": {
                                "description": "description defines the description terms for the validator.",
                                "type": "object",
                                "properties": {
                                    "moniker": {
                                        "description": "moniker defines a human-readable name for the validator.",
                                        "type": "string"
                                    },
                                    "identity": {
                                        "description": "identity defines an optional identity signature (ex. UPort or Keybase).",
                                        "type": "string"
                                    },
                                    "website": {
                                        "description": "website defines an optional website link.",
                                        "type": "string"
                                    },
                                    "security_contact": {
                                        "description": "security_contact defines an optional email for security contact.",
                                        "type": "string"
                                    },
                                    "details": {
                                        "description": "details define other optional details.",
                                        "type": "string"
                                    }
                                }
                            },
                            "unbonding_height": {
                                "format": "int64",
                                "description": "unbonding_height defines, if unbonding, the height at which this validator has begun unbonding.",
                                "type": "string"
                            },
                            "unbonding_time": {
                                "format": "date-time",
                                "description": "unbonding_time defines, if unbonding, the min time for the validator to complete unbonding.",
                                "type": "string"
                            },
                            "commission": {
                                "description": "commission defines the commission parameters.",
                                "type": "object",
                                "properties": {
                                    "commission_rates": {
                                        "description": "commission_rates defines the initial commission rates to be used for creating a validator.",
                                        "type": "object",
                                        "properties": {
                                            "rate": {
                                                "description": "rate is the commission rate charged to delegators, as a fraction.",
                                                "type": "string"
                                            },
                                            "max_rate": {
                                                "description": "max_rate defines the maximum commission rate which validator can ever charge, as a fraction.",
                                                "type": "string"
                                            },
                                            "max_change_rate": {
                                                "description": "max_change_rate defines the maximum daily increase of the validator commission, as a fraction.",
                                                "type": "string"
                                            }
                                        }
                                    },
                                    "update_time": {
                                        "format": "date-time",
                                        "description": "update_time is the last time the commission rate was changed.",
                                        "type": "string"
                                    }
                                }
                            },
                            "min_self_delegation": {
                                "description": "min_self_delegation is the validator's self declared minimum self delegation.",
                                "type": "string"
                            }
                        }
                    }
                },
                "pagination": {
                    "description": "pagination defines the pagination in the response.",
                    "type": "object",
                    "properties": {
                        "next_key": {
                            "format": "byte",
                            "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently",
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string"
                        },
                        "total": {
                            "format": "uint64",
                            "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                            "type": "string"
                        }
                    }
                }
            }
        },
        "cosmos.staking.v1beta1.QueryHistoricalInfoResponse": {
            "description": "QueryHistoricalInfoResponse is response type for the Query/HistoricalInfo RPC\nmethod.",
            "type": "object",
            "properties": {
                "hist": {
                    "description": "hist defines the historical info at the given height.",
                    "type": "object",
                    "properties": {
                        "header": {
                            "description": "Header defines the structure of a Tendermint block header.",
                            "type": "object",
                            "properties": {
                                "version": {
                                    "title": "basic block info",
                                    "description": "Consensus captures the consensus rules for processing a block in the blockchain,\nincluding all blockchain data structures and the rules of the application's\nstate transition machine.",
                                    "type": "object",
                                    "properties": {
                                        "block": {
                                            "format": "uint64",
                                            "type": "string"
                                        },
                                        "app": {
                                            "format": "uint64",
                                            "type": "string"
                                        }
                                    }
                                },
                                "chain_id": {
                                    "type": "string"
                                },
                                "height": {
                                    "format": "int64",
                                    "type": "string"
                                },
                                "time": {
                                    "format": "date-time",
                                    "type": "string"
                                },
                                "last_block_id": {
                                    "title": "prev block info",
                                    "type": "object",
                                    "properties": {
                                        "hash": {
                                            "format": "byte",
                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                            "type": "string"
                                        },
                                        "part_set_header": {
                                            "title": "PartsetHeader",
                                            "type": "object",
                                            "properties": {
                                                "total": {
                                                    "format": "int64",
                                                    "type": "integer"
                                                },
                                                "hash": {
                                                    "format": "byte",
                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                    "type": "string"
                                                }
                                            }
                                        }
                                    }
                                },
                                "last_commit_hash": {
                                    "format": "byte",
                                    "title": "hashes of block data",
                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                    "type": "string"
                                },
                                "data_hash": {
                                    "format": "byte",
                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                    "type": "string"
                                },
                                "validators_hash": {
                                    "format": "byte",
                                    "title": "hashes from the app output from the prev block",
                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                    "type": "string"
                                },
                                "next_validators_hash": {
                                    "format": "byte",
                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                    "type": "string"
                                },
                                "consensus_hash": {
                                    "format": "byte",
                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                    "type": "string"
                                },
                                "app_hash": {
                                    "format": "byte",
                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                    "type": "string"
                                },
                                "last_results_hash": {
                                    "format": "byte",
                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                    "type": "string"
                                },
                                "evidence_hash": {
                                    "format": "byte",
                                    "title": "consensus info",
                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                    "type": "string"
                                },
                                "proposer_address": {
                                    "format": "byte",
                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                    "type": "string"
                                }
                            }
                        },
                        "valset": {
                            "type": "array",
                            "items": {
                                "description": "Validator defines a validator, together with the total amount of the\nValidator's bond shares and their exchange rate to coins. Slashing results in\na decrease in the exchange rate, allowing correct calculation of future\nundelegations without iterating over delegators. When coins are delegated to\nthis validator, the validator is credited with a delegation whose number of\nbond shares is based on the amount of coins delegated divided by the current\nexchange rate. Voting power can be calculated as total bonded shares\nmultiplied by exchange rate.",
                                "type": "object",
                                "properties": {
                                    "operator_address": {
                                        "description": "operator_address defines the address of the validator's operator; bech encoded in JSON.",
                                        "type": "string"
                                    },
                                    "consensus_pubkey": {
                                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                        "type": "object",
                                        "properties": {
                                            "type_url": {
                                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                                "type": "string"
                                            },
                                            "value": {
                                                "format": "byte",
                                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string"
                                            }
                                        }
                                    },
                                    "jailed": {
                                        "format": "boolean",
                                        "description": "jailed defined whether the validator has been jailed from bonded status or not.",
                                        "type": "boolean"
                                    },
                                    "status": {
                                        "description": "status is the validator status (bonded/unbonding/unbonded).",
                                        "default": "BOND_STATUS_UNSPECIFIED",
                                        "enum": [
                                            "BOND_STATUS_UNSPECIFIED",
                                            "BOND_STATUS_UNBONDED",
                                            "BOND_STATUS_UNBONDING",
                                            "BOND_STATUS_BONDED"
                                        ],
                                        "type": "string"
                                    },
                                    "tokens": {
                                        "description": "tokens define the delegated tokens (incl. self-delegation).",
                                        "type": "string"
                                    },
                                    "delegator_shares": {
                                        "description": "delegator_shares defines total shares issued to a validator's delegators.",
                                        "type": "string"
                                    },
                                    "description": {
                                        "description": "description defines the description terms for the validator.",
                                        "type": "object",
                                        "properties": {
                                            "moniker": {
                                                "description": "moniker defines a human-readable name for the validator.",
                                                "type": "string"
                                            },
                                            "identity": {
                                                "description": "identity defines an optional identity signature (ex. UPort or Keybase).",
                                                "type": "string"
                                            },
                                            "website": {
                                                "description": "website defines an optional website link.",
                                                "type": "string"
                                            },
                                            "security_contact": {
                                                "description": "security_contact defines an optional email for security contact.",
                                                "type": "string"
                                            },
                                            "details": {
                                                "description": "details define other optional details.",
                                                "type": "string"
                                            }
                                        }
                                    },
                                    "unbonding_height": {
                                        "format": "int64",
                                        "description": "unbonding_height defines, if unbonding, the height at which this validator has begun unbonding.",
                                        "type": "string"
                                    },
                                    "unbonding_time": {
                                        "format": "date-time",
                                        "description": "unbonding_time defines, if unbonding, the min time for the validator to complete unbonding.",
                                        "type": "string"
                                    },
                                    "commission": {
                                        "description": "commission defines the commission parameters.",
                                        "type": "object",
                                        "properties": {
                                            "commission_rates": {
                                                "description": "commission_rates defines the initial commission rates to be used for creating a validator.",
                                                "type": "object",
                                                "properties": {
                                                    "rate": {
                                                        "description": "rate is the commission rate charged to delegators, as a fraction.",
                                                        "type": "string"
                                                    },
                                                    "max_rate": {
                                                        "description": "max_rate defines the maximum commission rate which validator can ever charge, as a fraction.",
                                                        "type": "string"
                                                    },
                                                    "max_change_rate": {
                                                        "description": "max_change_rate defines the maximum daily increase of the validator commission, as a fraction.",
                                                        "type": "string"
                                                    }
                                                }
                                            },
                                            "update_time": {
                                                "format": "date-time",
                                                "description": "update_time is the last time the commission rate was changed.",
                                                "type": "string"
                                            }
                                        }
                                    },
                                    "min_self_delegation": {
                                        "description": "min_self_delegation is the validator's self declared minimum self delegation.",
                                        "type": "string"
                                    }
                                }
                            }
                        }
                    }
                }
            }
        },
        "cosmos.staking.v1beta1.QueryParamsResponse": {
            "description": "QueryParamsResponse is response type for the Query/Params RPC method.",
            "type": "object",
            "properties": {
                "params": {
                    "description": "params holds all the parameters of this module.",
                    "type": "object",
                    "properties": {
                        "unbonding_time": {
                            "description": "unbonding_time is the time duration of unbonding.",
                            "type": "string"
                        },
                        "max_validators": {
                            "format": "int64",
                            "description": "max_validators is the maximum number of validators.",
                            "type": "integer"
                        },
                        "max_entries": {
                            "format": "int64",
                            "description": "max_entries is the max entries for either unbonding delegation or redelegation (per pair/trio).",
                            "type": "integer"
                        },
                        "historical_entries": {
                            "format": "int64",
                            "description": "historical_entries is the number of historical entries to persist.",
                            "type": "integer"
                        },
                        "bond_denom": {
                            "description": "bond_denom defines the bondable coin denomination.",
                            "type": "string"
                        }
                    }
                }
            }
        },
        "cosmos.staking.v1beta1.QueryPoolResponse": {
            "description": "QueryPoolResponse is response type for the Query/Pool RPC method.",
            "type": "object",
            "properties": {
                "pool": {
                    "description": "pool defines the pool info.",
                    "type": "object",
                    "properties": {
                        "not_bonded_tokens": {
                            "type": "string"
                        },
                        "bonded_tokens": {
                            "type": "string"
                        }
                    }
                }
            }
        },
        "cosmos.staking.v1beta1.QueryRedelegationsResponse": {
            "description": "QueryRedelegationsResponse is response type for the Query/Redelegations RPC\nmethod.",
            "type": "object",
            "properties": {
                "redelegation_responses": {
                    "type": "array",
                    "items": {
                        "description": "RedelegationResponse is equivalent to a Redelegation except that its entries\ncontain a balance in addition to shares which is more suitable for client\nresponses.",
                        "type": "object",
                        "properties": {
                            "redelegation": {
                                "description": "Redelegation contains the list of a particular delegator's redelegating bonds\nfrom a particular source validator to a particular destination validator.",
                                "type": "object",
                                "properties": {
                                    "delegator_address": {
                                        "description": "delegator_address is the bech32-encoded address of the delegator.",
                                        "type": "string"
                                    },
                                    "validator_src_address": {
                                        "description": "validator_src_address is the validator redelegation source operator address.",
                                        "type": "string"
                                    },
                                    "validator_dst_address": {
                                        "description": "validator_dst_address is the validator redelegation destination operator address.",
                                        "type": "string"
                                    },
                                    "entries": {
                                        "description": "entries are the redelegation entries.",
                                        "type": "array",
                                        "items": {
                                            "description": "RedelegationEntry defines a redelegation object with relevant metadata.",
                                            "type": "object",
                                            "properties": {
                                                "creation_height": {
                                                    "format": "int64",
                                                    "description": "creation_height  defines the height which the redelegation took place.",
                                                    "type": "string"
                                                },
                                                "completion_time": {
                                                    "format": "date-time",
                                                    "description": "completion_time defines the unix time for redelegation completion.",
                                                    "type": "string"
                                                },
                                                "initial_balance": {
                                                    "description": "initial_balance defines the initial balance when redelegation started.",
                                                    "type": "string"
                                                },
                                                "shares_dst": {
                                                    "description": "shares_dst is the amount of destination-validator shares created by redelegation.",
                                                    "type": "string"
                                                }
                                            }
                                        }
                                    }
                                }
                            },
                            "entries": {
                                "type": "array",
                                "items": {
                                    "description": "RedelegationEntryResponse is equivalent to a RedelegationEntry except that it\ncontains a balance in addition to shares which is more suitable for client\nresponses.",
                                    "type": "object",
                                    "properties": {
                                        "redelegation_entry": {
                                            "description": "RedelegationEntry defines a redelegation object with relevant metadata.",
                                            "type": "object",
                                            "properties": {
                                                "creation_height": {
                                                    "format": "int64",
                                                    "description": "creation_height  defines the height which the redelegation took place.",
                                                    "type": "string"
                                                },
                                                "completion_time": {
                                                    "format": "date-time",
                                                    "description": "completion_time defines the unix time for redelegation completion.",
                                                    "type": "string"
                                                },
                                                "initial_balance": {
                                                    "description": "initial_balance defines the initial balance when redelegation started.",
                                                    "type": "string"
                                                },
                                                "shares_dst": {
                                                    "description": "shares_dst is the amount of destination-validator shares created by redelegation.",
                                                    "type": "string"
                                                }
                                            }
                                        },
                                        "balance": {
                                            "type": "string"
                                        }
                                    }
                                }
                            }
                        }
                    }
                },
                "pagination": {
                    "description": "pagination defines the pagination in the response.",
                    "type": "object",
                    "properties": {
                        "next_key": {
                            "format": "byte",
                            "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently",
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string"
                        },
                        "total": {
                            "format": "uint64",
                            "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                            "type": "string"
                        }
                    }
                }
            }
        },
        "cosmos.staking.v1beta1.QueryUnbondingDelegationResponse": {
            "description": "QueryDelegationResponse is response type for the Query/UnbondingDelegation\nRPC method.",
            "type": "object",
            "properties": {
                "unbond": {
                    "description": "UnbondingDelegation stores all of a single delegator's unbonding bonds\nfor a single validator in an time-ordered list.",
                    "type": "object",
                    "properties": {
                        "delegator_address": {
                            "description": "delegator_address is the bech32-encoded address of the delegator.",
                            "type": "string"
                        },
                        "validator_address": {
                            "description": "validator_address is the bech32-encoded address of the validator.",
                            "type": "string"
                        },
                        "entries": {
                            "description": "entries are the unbonding delegation entries.",
                            "type": "array",
                            "items": {
                                "description": "UnbondingDelegationEntry defines an unbonding object with relevant metadata.",
                                "type": "object",
                                "properties": {
                                    "creation_height": {
                                        "format": "int64",
                                        "description": "creation_height is the height which the unbonding took place.",
                                        "type": "string"
                                    },
                                    "completion_time": {
                                        "format": "date-time",
                                        "description": "completion_time is the unix time for unbonding completion.",
                                        "type": "string"
                                    },
                                    "initial_balance": {
                                        "description": "initial_balance defines the tokens initially scheduled to receive at completion.",
                                        "type": "string"
                                    },
                                    "balance": {
                                        "description": "balance defines the tokens to receive at completion.",
                                        "type": "string"
                                    }
                                }
                            }
                        }
                    }
                }
            }
        },
        "cosmos.staking.v1beta1.QueryValidatorDelegationsResponse": {
            "title": "QueryValidatorDelegationsResponse is response type for the\nQuery/ValidatorDelegations RPC method",
            "type": "object",
            "properties": {
                "delegation_responses": {
                    "type": "array",
                    "items": {
                        "description": "DelegationResponse is equivalent to Delegation except that it contains a\nbalance in addition to shares which is more suitable for client responses.",
                        "type": "object",
                        "properties": {
                            "delegation": {
                                "description": "Delegation represents the bond with tokens held by an account. It is\nowned by one delegator, and is associated with the voting power of one\nvalidator.",
                                "type": "object",
                                "properties": {
                                    "delegator_address": {
                                        "description": "delegator_address is the bech32-encoded address of the delegator.",
                                        "type": "string"
                                    },
                                    "validator_address": {
                                        "description": "validator_address is the bech32-encoded address of the validator.",
                                        "type": "string"
                                    },
                                    "shares": {
                                        "description": "shares define the delegation shares received.",
                                        "type": "string"
                                    }
                                }
                            },
                            "balance": {
                                "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto.",
                                "type": "object",
                                "properties": {
                                    "denom": {
                                        "type": "string"
                                    },
                                    "amount": {
                                        "type": "string"
                                    }
                                }
                            }
                        }
                    }
                },
                "pagination": {
                    "description": "pagination defines the pagination in the response.",
                    "type": "object",
                    "properties": {
                        "next_key": {
                            "format": "byte",
                            "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently",
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string"
                        },
                        "total": {
                            "format": "uint64",
                            "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                            "type": "string"
                        }
                    }
                }
            }
        },
        "cosmos.staking.v1beta1.QueryValidatorResponse": {
            "title": "QueryValidatorResponse is response type for the Query/Validator RPC method",
            "type": "object",
            "properties": {
                "validator": {
                    "description": "Validator defines a validator, together with the total amount of the\nValidator's bond shares and their exchange rate to coins. Slashing results in\na decrease in the exchange rate, allowing correct calculation of future\nundelegations without iterating over delegators. When coins are delegated to\nthis validator, the validator is credited with a delegation whose number of\nbond shares is based on the amount of coins delegated divided by the current\nexchange rate. Voting power can be calculated as total bonded shares\nmultiplied by exchange rate.",
                    "type": "object",
                    "properties": {
                        "operator_address": {
                            "description": "operator_address defines the address of the validator's operator; bech encoded in JSON.",
                            "type": "string"
                        },
                        "consensus_pubkey": {
                            "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                            "type": "object",
                            "properties": {
                                "type_url": {
                                    "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                    "type": "string"
                                },
                                "value": {
                                    "format": "byte",
                                    "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                    "type": "string"
                                }
                            }
                        },
                        "jailed": {
                            "format": "boolean",
                            "description": "jailed defined whether the validator has been jailed from bonded status or not.",
                            "type": "boolean"
                        },
                        "status": {
                            "description": "status is the validator status (bonded/unbonding/unbonded).",
                            "default": "BOND_STATUS_UNSPECIFIED",
                            "enum": [
                                "BOND_STATUS_UNSPECIFIED",
                                "BOND_STATUS_UNBONDED",
                                "BOND_STATUS_UNBONDING",
                                "BOND_STATUS_BONDED"
                            ],
                            "type": "string"
                        },
                        "tokens": {
                            "description": "tokens define the delegated tokens (incl. self-delegation).",
                            "type": "string"
                        },
                        "delegator_shares": {
                            "description": "delegator_shares defines total shares issued to a validator's delegators.",
                            "type": "string"
                        },
                        "description": {
                            "description": "description defines the description terms for the validator.",
                            "type": "object",
                            "properties": {
                                "moniker": {
                                    "description": "moniker defines a human-readable name for the validator.",
                                    "type": "string"
                                },
                                "identity": {
                                    "description": "identity defines an optional identity signature (ex. UPort or Keybase).",
                                    "type": "string"
                                },
                                "website": {
                                    "description": "website defines an optional website link.",
                                    "type": "string"
                                },
                                "security_contact": {
                                    "description": "security_contact defines an optional email for security contact.",
                                    "type": "string"
                                },
                                "details": {
                                    "description": "details define other optional details.",
                                    "type": "string"
                                }
                            }
                        },
                        "unbonding_height": {
                            "format": "int64",
                            "description": "unbonding_height defines, if unbonding, the height at which this validator has begun unbonding.",
                            "type": "string"
                        },
                        "unbonding_time": {
                            "format": "date-time",
                            "description": "unbonding_time defines, if unbonding, the min time for the validator to complete unbonding.",
                            "type": "string"
                        },
                        "commission": {
                            "description": "commission defines the commission parameters.",
                            "type": "object",
                            "properties": {
                                "commission_rates": {
                                    "description": "commission_rates defines the initial commission rates to be used for creating a validator.",
                                    "type": "object",
                                    "properties": {
                                        "rate": {
                                            "description": "rate is the commission rate charged to delegators, as a fraction.",
                                            "type": "string"
                                        },
                                        "max_rate": {
                                            "description": "max_rate defines the maximum commission rate which validator can ever charge, as a fraction.",
                                            "type": "string"
                                        },
                                        "max_change_rate": {
                                            "description": "max_change_rate defines the maximum daily increase of the validator commission, as a fraction.",
                                            "type": "string"
                                        }
                                    }
                                },
                                "update_time": {
                                    "format": "date-time",
                                    "description": "update_time is the last time the commission rate was changed.",
                                    "type": "string"
                                }
                            }
                        },
                        "min_self_delegation": {
                            "description": "min_self_delegation is the validator's self declared minimum self delegation.",
                            "type": "string"
                        }
                    }
                }
            }
        },
        "cosmos.staking.v1beta1.QueryValidatorUnbondingDelegationsResponse": {
            "description": "QueryValidatorUnbondingDelegationsResponse is response type for the\nQuery/ValidatorUnbondingDelegations RPC method.",
            "type": "object",
            "properties": {
                "unbonding_responses": {
                    "type": "array",
                    "items": {
                        "description": "UnbondingDelegation stores all of a single delegator's unbonding bonds\nfor a single validator in an time-ordered list.",
                        "type": "object",
                        "properties": {
                            "delegator_address": {
                                "description": "delegator_address is the bech32-encoded address of the delegator.",
                                "type": "string"
                            },
                            "validator_address": {
                                "description": "validator_address is the bech32-encoded address of the validator.",
                                "type": "string"
                            },
                            "entries": {
                                "description": "entries are the unbonding delegation entries.",
                                "type": "array",
                                "items": {
                                    "description": "UnbondingDelegationEntry defines an unbonding object with relevant metadata.",
                                    "type": "object",
                                    "properties": {
                                        "creation_height": {
                                            "format": "int64",
                                            "description": "creation_height is the height which the unbonding took place.",
                                            "type": "string"
                                        },
                                        "completion_time": {
                                            "format": "date-time",
                                            "description": "completion_time is the unix time for unbonding completion.",
                                            "type": "string"
                                        },
                                        "initial_balance": {
                                            "description": "initial_balance defines the tokens initially scheduled to receive at completion.",
                                            "type": "string"
                                        },
                                        "balance": {
                                            "description": "balance defines the tokens to receive at completion.",
                                            "type": "string"
                                        }
                                    }
                                }
                            }
                        }
                    }
                },
                "pagination": {
                    "description": "pagination defines the pagination in the response.",
                    "type": "object",
                    "properties": {
                        "next_key": {
                            "format": "byte",
                            "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently",
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string"
                        },
                        "total": {
                            "format": "uint64",
                            "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                            "type": "string"
                        }
                    }
                }
            }
        },
        "cosmos.staking.v1beta1.QueryValidatorsResponse": {
            "title": "QueryValidatorsResponse is response type for the Query/Validators RPC method",
            "type": "object",
            "properties": {
                "validators": {
                    "description": "validators contains all the queried validators.",
                    "type": "array",
                    "items": {
                        "description": "Validator defines a validator, together with the total amount of the\nValidator's bond shares and their exchange rate to coins. Slashing results in\na decrease in the exchange rate, allowing correct calculation of future\nundelegations without iterating over delegators. When coins are delegated to\nthis validator, the validator is credited with a delegation whose number of\nbond shares is based on the amount of coins delegated divided by the current\nexchange rate. Voting power can be calculated as total bonded shares\nmultiplied by exchange rate.",
                        "type": "object",
                        "properties": {
                            "operator_address": {
                                "description": "operator_address defines the address of the validator's operator; bech encoded in JSON.",
                                "type": "string"
                            },
                            "consensus_pubkey": {
                                "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                "type": "object",
                                "properties": {
                                    "type_url": {
                                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                        "type": "string"
                                    },
                                    "value": {
                                        "format": "byte",
                                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                        "type": "string"
                                    }
                                }
                            },
                            "jailed": {
                                "format": "boolean",
                                "description": "jailed defined whether the validator has been jailed from bonded status or not.",
                                "type": "boolean"
                            },
                            "status": {
                                "description": "status is the validator status (bonded/unbonding/unbonded).",
                                "default": "BOND_STATUS_UNSPECIFIED",
                                "enum": [
                                    "BOND_STATUS_UNSPECIFIED",
                                    "BOND_STATUS_UNBONDED",
                                    "BOND_STATUS_UNBONDING",
                                    "BOND_STATUS_BONDED"
                                ],
                                "type": "string"
                            },
                            "tokens": {
                                "description": "tokens define the delegated tokens (incl. self-delegation).",
                                "type": "string"
                            },
                            "delegator_shares": {
                                "description": "delegator_shares defines total shares issued to a validator's delegators.",
                                "type": "string"
                            },
                            "description": {
                                "description": "description defines the description terms for the validator.",
                                "type": "object",
                                "properties": {
                                    "moniker": {
                                        "description": "moniker defines a human-readable name for the validator.",
                                        "type": "string"
                                    },
                                    "identity": {
                                        "description": "identity defines an optional identity signature (ex. UPort or Keybase).",
                                        "type": "string"
                                    },
                                    "website": {
                                        "description": "website defines an optional website link.",
                                        "type": "string"
                                    },
                                    "security_contact": {
                                        "description": "security_contact defines an optional email for security contact.",
                                        "type": "string"
                                    },
                                    "details": {
                                        "description": "details define other optional details.",
                                        "type": "string"
                                    }
                                }
                            },
                            "unbonding_height": {
                                "format": "int64",
                                "description": "unbonding_height defines, if unbonding, the height at which this validator has begun unbonding.",
                                "type": "string"
                            },
                            "unbonding_time": {
                                "format": "date-time",
                                "description": "unbonding_time defines, if unbonding, the min time for the validator to complete unbonding.",
                                "type": "string"
                            },
                            "commission": {
                                "description": "commission defines the commission parameters.",
                                "type": "object",
                                "properties": {
                                    "commission_rates": {
                                        "description": "commission_rates defines the initial commission rates to be used for creating a validator.",
                                        "type": "object",
                                        "properties": {
                                            "rate": {
                                                "description": "rate is the commission rate charged to delegators, as a fraction.",
                                                "type": "string"
                                            },
                                            "max_rate": {
                                                "description": "max_rate defines the maximum commission rate which validator can ever charge, as a fraction.",
                                                "type": "string"
                                            },
                                            "max_change_rate": {
                                                "description": "max_change_rate defines the maximum daily increase of the validator commission, as a fraction.",
                                                "type": "string"
                                            }
                                        }
                                    },
                                    "update_time": {
                                        "format": "date-time",
                                        "description": "update_time is the last time the commission rate was changed.",
                                        "type": "string"
                                    }
                                }
                            },
                            "min_self_delegation": {
                                "description": "min_self_delegation is the validator's self declared minimum self delegation.",
                                "type": "string"
                            }
                        }
                    }
                },
                "pagination": {
                    "description": "pagination defines the pagination in the response.",
                    "type": "object",
                    "properties": {
                        "next_key": {
                            "format": "byte",
                            "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently",
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string"
                        },
                        "total": {
                            "format": "uint64",
                            "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                            "type": "string"
                        }
                    }
                }
            }
        },
        "cosmos.staking.v1beta1.Redelegation": {
            "description": "Redelegation contains the list of a particular delegator's redelegating bonds\nfrom a particular source validator to a particular destination validator.",
            "type": "object",
            "properties": {
                "delegator_address": {
                    "description": "delegator_address is the bech32-encoded address of the delegator.",
                    "type": "string"
                },
                "validator_src_address": {
                    "description": "validator_src_address is the validator redelegation source operator address.",
                    "type": "string"
                },
                "validator_dst_address": {
                    "description": "validator_dst_address is the validator redelegation destination operator address.",
                    "type": "string"
                },
                "entries": {
                    "description": "entries are the redelegation entries.",
                    "type": "array",
                    "items": {
                        "description": "RedelegationEntry defines a redelegation object with relevant metadata.",
                        "type": "object",
                        "properties": {
                            "creation_height": {
                                "format": "int64",
                                "description": "creation_height  defines the height which the redelegation took place.",
                                "type": "string"
                            },
                            "completion_time": {
                                "format": "date-time",
                                "description": "completion_time defines the unix time for redelegation completion.",
                                "type": "string"
                            },
                            "initial_balance": {
                                "description": "initial_balance defines the initial balance when redelegation started.",
                                "type": "string"
                            },
                            "shares_dst": {
                                "description": "shares_dst is the amount of destination-validator shares created by redelegation.",
                                "type": "string"
                            }
                        }
                    }
                }
            }
        },
        "cosmos.staking.v1beta1.RedelegationEntry": {
            "description": "RedelegationEntry defines a redelegation object with relevant metadata.",
            "type": "object",
            "properties": {
                "creation_height": {
                    "format": "int64",
                    "description": "creation_height  defines the height which the redelegation took place.",
                    "type": "string"
                },
                "completion_time": {
                    "format": "date-time",
                    "description": "completion_time defines the unix time for redelegation completion.",
                    "type": "string"
                },
                "initial_balance": {
                    "description": "initial_balance defines the initial balance when redelegation started.",
                    "type": "string"
                },
                "shares_dst": {
                    "description": "shares_dst is the amount of destination-validator shares created by redelegation.",
                    "type": "string"
                }
            }
        },
        "cosmos.staking.v1beta1.RedelegationEntryResponse": {
            "description": "RedelegationEntryResponse is equivalent to a RedelegationEntry except that it\ncontains a balance in addition to shares which is more suitable for client\nresponses.",
            "type": "object",
            "properties": {
                "redelegation_entry": {
                    "description": "RedelegationEntry defines a redelegation object with relevant metadata.",
                    "type": "object",
                    "properties": {
                        "creation_height": {
                            "format": "int64",
                            "description": "creation_height  defines the height which the redelegation took place.",
                            "type": "string"
                        },
                        "completion_time": {
                            "format": "date-time",
                            "description": "completion_time defines the unix time for redelegation completion.",
                            "type": "string"
                        },
                        "initial_balance": {
                            "description": "initial_balance defines the initial balance when redelegation started.",
                            "type": "string"
                        },
                        "shares_dst": {
                            "description": "shares_dst is the amount of destination-validator shares created by redelegation.",
                            "type": "string"
                        }
                    }
                },
                "balance": {
                    "type": "string"
                }
            }
        },
        "cosmos.staking.v1beta1.RedelegationResponse": {
            "description": "RedelegationResponse is equivalent to a Redelegation except that its entries\ncontain a balance in addition to shares which is more suitable for client\nresponses.",
            "type": "object",
            "properties": {
                "redelegation": {
                    "description": "Redelegation contains the list of a particular delegator's redelegating bonds\nfrom a particular source validator to a particular destination validator.",
                    "type": "object",
                    "properties": {
                        "delegator_address": {
                            "description": "delegator_address is the bech32-encoded address of the delegator.",
                            "type": "string"
                        },
                        "validator_src_address": {
                            "description": "validator_src_address is the validator redelegation source operator address.",
                            "type": "string"
                        },
                        "validator_dst_address": {
                            "description": "validator_dst_address is the validator redelegation destination operator address.",
                            "type": "string"
                        },
                        "entries": {
                            "description": "entries are the redelegation entries.",
                            "type": "array",
                            "items": {
                                "description": "RedelegationEntry defines a redelegation object with relevant metadata.",
                                "type": "object",
                                "properties": {
                                    "creation_height": {
                                        "format": "int64",
                                        "description": "creation_height  defines the height which the redelegation took place.",
                                        "type": "string"
                                    },
                                    "completion_time": {
                                        "format": "date-time",
                                        "description": "completion_time defines the unix time for redelegation completion.",
                                        "type": "string"
                                    },
                                    "initial_balance": {
                                        "description": "initial_balance defines the initial balance when redelegation started.",
                                        "type": "string"
                                    },
                                    "shares_dst": {
                                        "description": "shares_dst is the amount of destination-validator shares created by redelegation.",
                                        "type": "string"
                                    }
                                }
                            }
                        }
                    }
                },
                "entries": {
                    "type": "array",
                    "items": {
                        "description": "RedelegationEntryResponse is equivalent to a RedelegationEntry except that it\ncontains a balance in addition to shares which is more suitable for client\nresponses.",
                        "type": "object",
                        "properties": {
                            "redelegation_entry": {
                                "description": "RedelegationEntry defines a redelegation object with relevant metadata.",
                                "type": "object",
                                "properties": {
                                    "creation_height": {
                                        "format": "int64",
                                        "description": "creation_height  defines the height which the redelegation took place.",
                                        "type": "string"
                                    },
                                    "completion_time": {
                                        "format": "date-time",
                                        "description": "completion_time defines the unix time for redelegation completion.",
                                        "type": "string"
                                    },
                                    "initial_balance": {
                                        "description": "initial_balance defines the initial balance when redelegation started.",
                                        "type": "string"
                                    },
                                    "shares_dst": {
                                        "description": "shares_dst is the amount of destination-validator shares created by redelegation.",
                                        "type": "string"
                                    }
                                }
                            },
                            "balance": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        },
        "cosmos.staking.v1beta1.UnbondingDelegation": {
            "description": "UnbondingDelegation stores all of a single delegator's unbonding bonds\nfor a single validator in an time-ordered list.",
            "type": "object",
            "properties": {
                "delegator_address": {
                    "description": "delegator_address is the bech32-encoded address of the delegator.",
                    "type": "string"
                },
                "validator_address": {
                    "description": "validator_address is the bech32-encoded address of the validator.",
                    "type": "string"
                },
                "entries": {
                    "description": "entries are the unbonding delegation entries.",
                    "type": "array",
                    "items": {
                        "description": "UnbondingDelegationEntry defines an unbonding object with relevant metadata.",
                        "type": "object",
                        "properties": {
                            "creation_height": {
                                "format": "int64",
                                "description": "creation_height is the height which the unbonding took place.",
                                "type": "string"
                            },
                            "completion_time": {
                                "format": "date-time",
                                "description": "completion_time is the unix time for unbonding completion.",
                                "type": "string"
                            },
                            "initial_balance": {
                                "description": "initial_balance defines the tokens initially scheduled to receive at completion.",
                                "type": "string"
                            },
                            "balance": {
                                "description": "balance defines the tokens to receive at completion.",
                                "type": "string"
                            }
                        }
                    }
                }
            }
        },
        "cosmos.staking.v1beta1.UnbondingDelegationEntry": {
            "description": "UnbondingDelegationEntry defines an unbonding object with relevant metadata.",
            "type": "object",
            "properties": {
                "creation_height": {
                    "format": "int64",
                    "description": "creation_height is the height which the unbonding took place.",
                    "type": "string"
                },
                "completion_time": {
                    "format": "date-time",
                    "description": "completion_time is the unix time for unbonding completion.",
                    "type": "string"
                },
                "initial_balance": {
                    "description": "initial_balance defines the tokens initially scheduled to receive at completion.",
                    "type": "string"
                },
                "balance": {
                    "description": "balance defines the tokens to receive at completion.",
                    "type": "string"
                }
            }
        },
        "cosmos.staking.v1beta1.Validator": {
            "description": "Validator defines a validator, together with the total amount of the\nValidator's bond shares and their exchange rate to coins. Slashing results in\na decrease in the exchange rate, allowing correct calculation of future\nundelegations without iterating over delegators. When coins are delegated to\nthis validator, the validator is credited with a delegation whose number of\nbond shares is based on the amount of coins delegated divided by the current\nexchange rate. Voting power can be calculated as total bonded shares\nmultiplied by exchange rate.",
            "type": "object",
            "properties": {
                "operator_address": {
                    "description": "operator_address defines the address of the validator's operator; bech encoded in JSON.",
                    "type": "string"
                },
                "consensus_pubkey": {
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                    "type": "object",
                    "properties": {
                        "type_url": {
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                            "type": "string"
                        },
                        "value": {
                            "format": "byte",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string"
                        }
                    }
                },
                "jailed": {
                    "format": "boolean",
                    "description": "jailed defined whether the validator has been jailed from bonded status or not.",
                    "type": "boolean"
                },
                "status": {
                    "description": "status is the validator status (bonded/unbonding/unbonded).",
                    "default": "BOND_STATUS_UNSPECIFIED",
                    "enum": [
                        "BOND_STATUS_UNSPECIFIED",
                        "BOND_STATUS_UNBONDED",
                        "BOND_STATUS_UNBONDING",
                        "BOND_STATUS_BONDED"
                    ],
                    "type": "string"
                },
                "tokens": {
                    "description": "tokens define the delegated tokens (incl. self-delegation).",
                    "type": "string"
                },
                "delegator_shares": {
                    "description": "delegator_shares defines total shares issued to a validator's delegators.",
                    "type": "string"
                },
                "description": {
                    "description": "description defines the description terms for the validator.",
                    "type": "object",
                    "properties": {
                        "moniker": {
                            "description": "moniker defines a human-readable name for the validator.",
                            "type": "string"
                        },
                        "identity": {
                            "description": "identity defines an optional identity signature (ex. UPort or Keybase).",
                            "type": "string"
                        },
                        "website": {
                            "description": "website defines an optional website link.",
                            "type": "string"
                        },
                        "security_contact": {
                            "description": "security_contact defines an optional email for security contact.",
                            "type": "string"
                        },
                        "details": {
                            "description": "details define other optional details.",
                            "type": "string"
                        }
                    }
                },
                "unbonding_height": {
                    "format": "int64",
                    "description": "unbonding_height defines, if unbonding, the height at which this validator has begun unbonding.",
                    "type": "string"
                },
                "unbonding_time": {
                    "format": "date-time",
                    "description": "unbonding_time defines, if unbonding, the min time for the validator to complete unbonding.",
                    "type": "string"
                },
                "commission": {
                    "description": "commission defines the commission parameters.",
                    "type": "object",
                    "properties": {
                        "commission_rates": {
                            "description": "commission_rates defines the initial commission rates to be used for creating a validator.",
                            "type": "object",
                            "properties": {
                                "rate": {
                                    "description": "rate is the commission rate charged to delegators, as a fraction.",
                                    "type": "string"
                                },
                                "max_rate": {
                                    "description": "max_rate defines the maximum commission rate which validator can ever charge, as a fraction.",
                                    "type": "string"
                                },
                                "max_change_rate": {
                                    "description": "max_change_rate defines the maximum daily increase of the validator commission, as a fraction.",
                                    "type": "string"
                                }
                            }
                        },
                        "update_time": {
                            "format": "date-time",
                            "description": "update_time is the last time the commission rate was changed.",
                            "type": "string"
                        }
                    }
                },
                "min_self_delegation": {
                    "description": "min_self_delegation is the validator's self declared minimum self delegation.",
                    "type": "string"
                }
            }
        },
        "cosmos.base.abci.v1beta1.ABCIMessageLog": {
            "description": "ABCIMessageLog defines a structure containing an indexed tx ABCI message log.",
            "type": "object",
            "properties": {
                "msg_index": {
                    "format": "int64",
                    "type": "integer"
                },
                "log": {
                    "type": "string"
                },
                "events": {
                    "description": "Events contains a slice of Event objects that were emitted during some\nexecution.",
                    "type": "array",
                    "items": {
                        "description": "StringEvent defines en Event object wrapper where all the attributes\ncontain key/value pairs that are strings instead of raw bytes.",
                        "type": "object",
                        "properties": {
                            "type": {
                                "type": "string"
                            },
                            "attributes": {
                                "type": "array",
                                "items": {
                                    "description": "Attribute defines an attribute wrapper where the key and value are\nstrings instead of raw bytes.",
                                    "type": "object",
                                    "properties": {
                                        "key": {
                                            "type": "string"
                                        },
                                        "value": {
                                            "type": "string"
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        },
        "cosmos.base.abci.v1beta1.Attribute": {
            "description": "Attribute defines an attribute wrapper where the key and value are\nstrings instead of raw bytes.",
            "type": "object",
            "properties": {
                "key": {
                    "type": "string"
                },
                "value": {
                    "type": "string"
                }
            }
        },
        "cosmos.base.abci.v1beta1.GasInfo": {
            "description": "GasInfo defines tx execution gas context.",
            "type": "object",
            "properties": {
                "gas_wanted": {
                    "format": "uint64",
                    "description": "GasWanted is the maximum units of work we allow this tx to perform.",
                    "type": "string"
                },
                "gas_used": {
                    "format": "uint64",
                    "description": "GasUsed is the amount of gas actually consumed.",
                    "type": "string"
                }
            }
        },
        "cosmos.base.abci.v1beta1.Result": {
            "description": "Result is the union of ResponseFormat and ResponseCheckTx.",
            "type": "object",
            "properties": {
                "data": {
                    "format": "byte",
                    "description": "Data is any data returned from message or handler execution. It MUST be\nlength prefixed in order to separate data from multiple message executions.",
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string"
                },
                "log": {
                    "description": "Log contains the log information from message or handler execution.",
                    "type": "string"
                },
                "events": {
                    "description": "Events contains a slice of Event objects that were emitted during message\nor handler execution.",
                    "type": "array",
                    "items": {
                        "description": "Event allows application developers to attach additional information to\nResponseBeginBlock, ResponseEndBlock, ResponseCheckTx and ResponseDeliverTx.\nLater, transactions may be queried using these events.",
                        "type": "object",
                        "properties": {
                            "type": {
                                "type": "string"
                            },
                            "attributes": {
                                "type": "array",
                                "items": {
                                    "description": "EventAttribute is a single key-value pair, associated with an event.",
                                    "type": "object",
                                    "properties": {
                                        "key": {
                                            "format": "byte",
                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                            "type": "string"
                                        },
                                        "value": {
                                            "format": "byte",
                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                            "type": "string"
                                        },
                                        "index": {
                                            "format": "boolean",
                                            "type": "boolean"
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        },
        "cosmos.base.abci.v1beta1.StringEvent": {
            "description": "StringEvent defines en Event object wrapper where all the attributes\ncontain key/value pairs that are strings instead of raw bytes.",
            "type": "object",
            "properties": {
                "type": {
                    "type": "string"
                },
                "attributes": {
                    "type": "array",
                    "items": {
                        "description": "Attribute defines an attribute wrapper where the key and value are\nstrings instead of raw bytes.",
                        "type": "object",
                        "properties": {
                            "key": {
                                "type": "string"
                            },
                            "value": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        },
        "cosmos.base.abci.v1beta1.TxResponse": {
            "description": "TxResponse defines a structure containing relevant tx data and metadata. The\ntags are stringified and the log is JSON decoded.",
            "type": "object",
            "properties": {
                "height": {
                    "format": "int64",
                    "title": "The block height",
                    "type": "string"
                },
                "txhash": {
                    "description": "The transaction hash.",
                    "type": "string"
                },
                "codespace": {
                    "title": "Namespace for the Code",
                    "type": "string"
                },
                "code": {
                    "format": "int64",
                    "description": "Response code.",
                    "type": "integer"
                },
                "data": {
                    "description": "Result bytes, if any.",
                    "type": "string"
                },
                "raw_log": {
                    "description": "The output of the application's logger (raw string). May be\nnon-deterministic.",
                    "type": "string"
                },
                "logs": {
                    "description": "The output of the application's logger (typed). May be non-deterministic.",
                    "type": "array",
                    "items": {
                        "description": "ABCIMessageLog defines a structure containing an indexed tx ABCI message log.",
                        "type": "object",
                        "properties": {
                            "msg_index": {
                                "format": "int64",
                                "type": "integer"
                            },
                            "log": {
                                "type": "string"
                            },
                            "events": {
                                "description": "Events contains a slice of Event objects that were emitted during some\nexecution.",
                                "type": "array",
                                "items": {
                                    "description": "StringEvent defines en Event object wrapper where all the attributes\ncontain key/value pairs that are strings instead of raw bytes.",
                                    "type": "object",
                                    "properties": {
                                        "type": {
                                            "type": "string"
                                        },
                                        "attributes": {
                                            "type": "array",
                                            "items": {
                                                "description": "Attribute defines an attribute wrapper where the key and value are\nstrings instead of raw bytes.",
                                                "type": "object",
                                                "properties": {
                                                    "key": {
                                                        "type": "string"
                                                    },
                                                    "value": {
                                                        "type": "string"
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                },
                "info": {
                    "description": "Additional information. May be non-deterministic.",
                    "type": "string"
                },
                "gas_wanted": {
                    "format": "int64",
                    "description": "Amount of gas requested for transaction.",
                    "type": "string"
                },
                "gas_used": {
                    "format": "int64",
                    "description": "Amount of gas consumed by transaction.",
                    "type": "string"
                },
                "tx": {
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                    "type": "object",
                    "properties": {
                        "type_url": {
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                            "type": "string"
                        },
                        "value": {
                            "format": "byte",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string"
                        }
                    }
                },
                "timestamp": {
                    "description": "Time of the previous block. For heights > 1, it's the weighted median of\nthe timestamps of the valid votes in the block.LastCommit. For height == 1,\nit's genesis time.",
                    "type": "string"
                }
            }
        },
        "cosmos.crypto.multisig.v1beta1.CompactBitArray": {
            "description": "CompactBitArray is an implementation of a space efficient bit array.\nThis is used to ensure that the encoded data takes up a minimal amount of\nspace after proto encoding.\nThis is not thread safe, and is not intended for concurrent usage.",
            "type": "object",
            "properties": {
                "extra_bits_stored": {
                    "format": "int64",
                    "type": "integer"
                },
                "elems": {
                    "format": "byte",
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string"
                }
            }
        },
        "cosmos.tx.signing.v1beta1.SignMode": {
            "description": "SignMode represents a signing mode with its own security guarantees.\n\n - SIGN_MODE_UNSPECIFIED: SIGN_MODE_UNSPECIFIED specifies an unknown signing mode and will be\nrejected\n - SIGN_MODE_DIRECT: SIGN_MODE_DIRECT specifies a signing mode which uses SignDoc and is\nverified with raw bytes from Tx\n - SIGN_MODE_TEXTUAL: SIGN_MODE_TEXTUAL is a future signing mode that will verify some\nhuman-readable textual representation on top of the binary representation\nfrom SIGN_MODE_DIRECT\n - SIGN_MODE_LEGACY_AMINO_JSON: SIGN_MODE_LEGACY_AMINO_JSON is a backwards compatibility mode which uses\nAmino JSON and will be removed in the future",
            "default": "SIGN_MODE_UNSPECIFIED",
            "enum": [
                "SIGN_MODE_UNSPECIFIED",
                "SIGN_MODE_DIRECT",
                "SIGN_MODE_TEXTUAL",
                "SIGN_MODE_LEGACY_AMINO_JSON"
            ],
            "type": "string"
        },
        "cosmos.tx.v1beta1.AuthInfo": {
            "description": "AuthInfo describes the fee and signer modes that are used to sign a\ntransaction.",
            "type": "object",
            "properties": {
                "signer_infos": {
                    "description": "signer_infos defines the signing modes for the required signers. The number\nand order of elements must match the required signers from TxBody's\nmessages. The first element is the primary signer and the one which pays\nthe fee.",
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/cosmos.tx.v1beta1.SignerInfo"
                    }
                },
                "fee": {
                    "description": "Fee is the fee and gas limit for the transaction. The first signer is the\nprimary signer and the one which pays the fee. The fee can be calculated\nbased on the cost of evaluating the body and doing signature verification\nof the signers. This can be estimated via simulation.",
                    "type": "object",
                    "properties": {
                        "amount": {
                            "title": "amount is the amount of coins to be paid as a fee",
                            "type": "array",
                            "items": {
                                "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto.",
                                "type": "object",
                                "properties": {
                                    "denom": {
                                        "type": "string"
                                    },
                                    "amount": {
                                        "type": "string"
                                    }
                                }
                            }
                        },
                        "gas_limit": {
                            "format": "uint64",
                            "title": "gas_limit is the maximum gas that can be used in transaction processing\nbefore an out of gas error occurs",
                            "type": "string"
                        },
                        "payer": {
                            "description": "if unset, the first signer is responsible for paying the fees. If set, the specified account must pay the fees.\nthe payer must be a tx signer (and thus have signed this field in AuthInfo).\nsetting this field does *not* change the ordering of required signers for the transaction.",
                            "type": "string"
                        },
                        "granter": {
                            "title": "if set, the fee payer (either the first signer or the value of the payer field) requests that a fee grant be used\nto pay fees instead of the fee payer's own balance. If an appropriate fee grant does not exist or the chain does\nnot support fee grants, this will fail",
                            "type": "string"
                        }
                    }
                }
            }
        },
        "cosmos.tx.v1beta1.BroadcastMode": {
            "description": "BroadcastMode specifies the broadcast mode for the TxService.Broadcast RPC method.\n\n - BROADCAST_MODE_UNSPECIFIED: zero-value for mode ordering\n - BROADCAST_MODE_BLOCK: BROADCAST_MODE_BLOCK defines a tx broadcasting mode where the client waits for\nthe tx to be committed in a block.\n - BROADCAST_MODE_SYNC: BROADCAST_MODE_SYNC defines a tx broadcasting mode where the client waits for\na CheckTx execution response only.\n - BROADCAST_MODE_ASYNC: BROADCAST_MODE_ASYNC defines a tx broadcasting mode where the client returns\nimmediately.",
            "default": "BROADCAST_MODE_UNSPECIFIED",
            "enum": [
                "BROADCAST_MODE_UNSPECIFIED",
                "BROADCAST_MODE_BLOCK",
                "BROADCAST_MODE_SYNC",
                "BROADCAST_MODE_ASYNC"
            ],
            "type": "string"
        },
        "cosmos.tx.v1beta1.BroadcastTxRequest": {
            "description": "BroadcastTxRequest is the request type for the Service.BroadcastTxRequest\nRPC method.",
            "type": "object",
            "properties": {
                "tx_bytes": {
                    "format": "byte",
                    "description": "tx_bytes is the raw transaction.",
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string"
                },
                "mode": {
                    "description": "BroadcastMode specifies the broadcast mode for the TxService.Broadcast RPC method.\n\n - BROADCAST_MODE_UNSPECIFIED: zero-value for mode ordering\n - BROADCAST_MODE_BLOCK: BROADCAST_MODE_BLOCK defines a tx broadcasting mode where the client waits for\nthe tx to be committed in a block.\n - BROADCAST_MODE_SYNC: BROADCAST_MODE_SYNC defines a tx broadcasting mode where the client waits for\na CheckTx execution response only.\n - BROADCAST_MODE_ASYNC: BROADCAST_MODE_ASYNC defines a tx broadcasting mode where the client returns\nimmediately.",
                    "default": "BROADCAST_MODE_UNSPECIFIED",
                    "enum": [
                        "BROADCAST_MODE_UNSPECIFIED",
                        "BROADCAST_MODE_BLOCK",
                        "BROADCAST_MODE_SYNC",
                        "BROADCAST_MODE_ASYNC"
                    ],
                    "type": "string"
                }
            }
        },
        "cosmos.tx.v1beta1.BroadcastTxResponse": {
            "description": "BroadcastTxResponse is the response type for the\nService.BroadcastTx method.",
            "type": "object",
            "properties": {
                "tx_response": {
                    "description": "TxResponse defines a structure containing relevant tx data and metadata. The\ntags are stringified and the log is JSON decoded.",
                    "type": "object",
                    "properties": {
                        "height": {
                            "format": "int64",
                            "title": "The block height",
                            "type": "string"
                        },
                        "txhash": {
                            "description": "The transaction hash.",
                            "type": "string"
                        },
                        "codespace": {
                            "title": "Namespace for the Code",
                            "type": "string"
                        },
                        "code": {
                            "format": "int64",
                            "description": "Response code.",
                            "type": "integer"
                        },
                        "data": {
                            "description": "Result bytes, if any.",
                            "type": "string"
                        },
                        "raw_log": {
                            "description": "The output of the application's logger (raw string). May be\nnon-deterministic.",
                            "type": "string"
                        },
                        "logs": {
                            "description": "The output of the application's logger (typed). May be non-deterministic.",
                            "type": "array",
                            "items": {
                                "description": "ABCIMessageLog defines a structure containing an indexed tx ABCI message log.",
                                "type": "object",
                                "properties": {
                                    "msg_index": {
                                        "format": "int64",
                                        "type": "integer"
                                    },
                                    "log": {
                                        "type": "string"
                                    },
                                    "events": {
                                        "description": "Events contains a slice of Event objects that were emitted during some\nexecution.",
                                        "type": "array",
                                        "items": {
                                            "description": "StringEvent defines en Event object wrapper where all the attributes\ncontain key/value pairs that are strings instead of raw bytes.",
                                            "type": "object",
                                            "properties": {
                                                "type": {
                                                    "type": "string"
                                                },
                                                "attributes": {
                                                    "type": "array",
                                                    "items": {
                                                        "description": "Attribute defines an attribute wrapper where the key and value are\nstrings instead of raw bytes.",
                                                        "type": "object",
                                                        "properties": {
                                                            "key": {
                                                                "type": "string"
                                                            },
                                                            "value": {
                                                                "type": "string"
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        },
                        "info": {
                            "description": "Additional information. May be non-deterministic.",
                            "type": "string"
                        },
                        "gas_wanted": {
                            "format": "int64",
                            "description": "Amount of gas requested for transaction.",
                            "type": "string"
                        },
                        "gas_used": {
                            "format": "int64",
                            "description": "Amount of gas consumed by transaction.",
                            "type": "string"
                        },
                        "tx": {
                            "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                            "type": "object",
                            "properties": {
                                "type_url": {
                                    "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                    "type": "string"
                                },
                                "value": {
                                    "format": "byte",
                                    "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                    "type": "string"
                                }
                            }
                        },
                        "timestamp": {
                            "description": "Time of the previous block. For heights > 1, it's the weighted median of\nthe timestamps of the valid votes in the block.LastCommit. For height == 1,\nit's genesis time.",
                            "type": "string"
                        }
                    }
                }
            }
        },
        "cosmos.tx.v1beta1.Fee": {
            "description": "Fee includes the amount of coins paid in fees and the maximum\ngas to be used by the transaction. The ratio yields an effective \"gasprice\",\nwhich must be above some miminum to be accepted into the mempool.",
            "type": "object",
            "properties": {
                "amount": {
                    "title": "amount is the amount of coins to be paid as a fee",
                    "type": "array",
                    "items": {
                        "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto.",
                        "type": "object",
                        "properties": {
                            "denom": {
                                "type": "string"
                            },
                            "amount": {
                                "type": "string"
                            }
                        }
                    }
                },
                "gas_limit": {
                    "format": "uint64",
                    "title": "gas_limit is the maximum gas that can be used in transaction processing\nbefore an out of gas error occurs",
                    "type": "string"
                },
                "payer": {
                    "description": "if unset, the first signer is responsible for paying the fees. If set, the specified account must pay the fees.\nthe payer must be a tx signer (and thus have signed this field in AuthInfo).\nsetting this field does *not* change the ordering of required signers for the transaction.",
                    "type": "string"
                },
                "granter": {
                    "title": "if set, the fee payer (either the first signer or the value of the payer field) requests that a fee grant be used\nto pay fees instead of the fee payer's own balance. If an appropriate fee grant does not exist or the chain does\nnot support fee grants, this will fail",
                    "type": "string"
                }
            }
        },
        "cosmos.tx.v1beta1.GetTxResponse": {
            "description": "GetTxResponse is the response type for the Service.GetTx method.",
            "type": "object",
            "properties": {
                "tx": {
                    "$ref": "#/definitions/cosmos.tx.v1beta1.Tx"
                },
                "tx_response": {
                    "description": "TxResponse defines a structure containing relevant tx data and metadata. The\ntags are stringified and the log is JSON decoded.",
                    "type": "object",
                    "properties": {
                        "height": {
                            "format": "int64",
                            "title": "The block height",
                            "type": "string"
                        },
                        "txhash": {
                            "description": "The transaction hash.",
                            "type": "string"
                        },
                        "codespace": {
                            "title": "Namespace for the Code",
                            "type": "string"
                        },
                        "code": {
                            "format": "int64",
                            "description": "Response code.",
                            "type": "integer"
                        },
                        "data": {
                            "description": "Result bytes, if any.",
                            "type": "string"
                        },
                        "raw_log": {
                            "description": "The output of the application's logger (raw string). May be\nnon-deterministic.",
                            "type": "string"
                        },
                        "logs": {
                            "description": "The output of the application's logger (typed). May be non-deterministic.",
                            "type": "array",
                            "items": {
                                "description": "ABCIMessageLog defines a structure containing an indexed tx ABCI message log.",
                                "type": "object",
                                "properties": {
                                    "msg_index": {
                                        "format": "int64",
                                        "type": "integer"
                                    },
                                    "log": {
                                        "type": "string"
                                    },
                                    "events": {
                                        "description": "Events contains a slice of Event objects that were emitted during some\nexecution.",
                                        "type": "array",
                                        "items": {
                                            "description": "StringEvent defines en Event object wrapper where all the attributes\ncontain key/value pairs that are strings instead of raw bytes.",
                                            "type": "object",
                                            "properties": {
                                                "type": {
                                                    "type": "string"
                                                },
                                                "attributes": {
                                                    "type": "array",
                                                    "items": {
                                                        "description": "Attribute defines an attribute wrapper where the key and value are\nstrings instead of raw bytes.",
                                                        "type": "object",
                                                        "properties": {
                                                            "key": {
                                                                "type": "string"
                                                            },
                                                            "value": {
                                                                "type": "string"
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        },
                        "info": {
                            "description": "Additional information. May be non-deterministic.",
                            "type": "string"
                        },
                        "gas_wanted": {
                            "format": "int64",
                            "description": "Amount of gas requested for transaction.",
                            "type": "string"
                        },
                        "gas_used": {
                            "format": "int64",
                            "description": "Amount of gas consumed by transaction.",
                            "type": "string"
                        },
                        "tx": {
                            "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                            "type": "object",
                            "properties": {
                                "type_url": {
                                    "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                    "type": "string"
                                },
                                "value": {
                                    "format": "byte",
                                    "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                    "type": "string"
                                }
                            }
                        },
                        "timestamp": {
                            "description": "Time of the previous block. For heights > 1, it's the weighted median of\nthe timestamps of the valid votes in the block.LastCommit. For height == 1,\nit's genesis time.",
                            "type": "string"
                        }
                    }
                }
            }
        },
        "cosmos.tx.v1beta1.GetTxsEventResponse": {
            "description": "GetTxsEventResponse is the response type for the Service.TxsByEvents\nRPC method.",
            "type": "object",
            "properties": {
                "txs": {
                    "description": "txs is the list of queried transactions.",
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/cosmos.tx.v1beta1.Tx"
                    }
                },
                "tx_responses": {
                    "description": "tx_responses is the list of queried TxResponses.",
                    "type": "array",
                    "items": {
                        "description": "TxResponse defines a structure containing relevant tx data and metadata. The\ntags are stringified and the log is JSON decoded.",
                        "type": "object",
                        "properties": {
                            "height": {
                                "format": "int64",
                                "title": "The block height",
                                "type": "string"
                            },
                            "txhash": {
                                "description": "The transaction hash.",
                                "type": "string"
                            },
                            "codespace": {
                                "title": "Namespace for the Code",
                                "type": "string"
                            },
                            "code": {
                                "format": "int64",
                                "description": "Response code.",
                                "type": "integer"
                            },
                            "data": {
                                "description": "Result bytes, if any.",
                                "type": "string"
                            },
                            "raw_log": {
                                "description": "The output of the application's logger (raw string). May be\nnon-deterministic.",
                                "type": "string"
                            },
                            "logs": {
                                "description": "The output of the application's logger (typed). May be non-deterministic.",
                                "type": "array",
                                "items": {
                                    "description": "ABCIMessageLog defines a structure containing an indexed tx ABCI message log.",
                                    "type": "object",
                                    "properties": {
                                        "msg_index": {
                                            "format": "int64",
                                            "type": "integer"
                                        },
                                        "log": {
                                            "type": "string"
                                        },
                                        "events": {
                                            "description": "Events contains a slice of Event objects that were emitted during some\nexecution.",
                                            "type": "array",
                                            "items": {
                                                "description": "StringEvent defines en Event object wrapper where all the attributes\ncontain key/value pairs that are strings instead of raw bytes.",
                                                "type": "object",
                                                "properties": {
                                                    "type": {
                                                        "type": "string"
                                                    },
                                                    "attributes": {
                                                        "type": "array",
                                                        "items": {
                                                            "description": "Attribute defines an attribute wrapper where the key and value are\nstrings instead of raw bytes.",
                                                            "type": "object",
                                                            "properties": {
                                                                "key": {
                                                                    "type": "string"
                                                                },
                                                                "value": {
                                                                    "type": "string"
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            },
                            "info": {
                                "description": "Additional information. May be non-deterministic.",
                                "type": "string"
                            },
                            "gas_wanted": {
                                "format": "int64",
                                "description": "Amount of gas requested for transaction.",
                                "type": "string"
                            },
                            "gas_used": {
                                "format": "int64",
                                "description": "Amount of gas consumed by transaction.",
                                "type": "string"
                            },
                            "tx": {
                                "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                "type": "object",
                                "properties": {
                                    "type_url": {
                                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                        "type": "string"
                                    },
                                    "value": {
                                        "format": "byte",
                                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                        "type": "string"
                                    }
                                }
                            },
                            "timestamp": {
                                "description": "Time of the previous block. For heights > 1, it's the weighted median of\nthe timestamps of the valid votes in the block.LastCommit. For height == 1,\nit's genesis time.",
                                "type": "string"
                            }
                        }
                    }
                },
                "pagination": {
                    "description": "pagination defines an pagination for the response.",
                    "type": "object",
                    "properties": {
                        "next_key": {
                            "format": "byte",
                            "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently",
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string"
                        },
                        "total": {
                            "format": "uint64",
                            "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                            "type": "string"
                        }
                    }
                }
            }
        },
        "cosmos.tx.v1beta1.ModeInfo": {
            "description": "ModeInfo describes the signing mode of a single or nested multisig signer.",
            "type": "object",
            "properties": {
                "single": {
                    "title": "single represents a single signer",
                    "type": "object",
                    "properties": {
                        "mode": {
                            "title": "mode is the signing mode of the single signer",
                            "description": "SignMode represents a signing mode with its own security guarantees.\n\n - SIGN_MODE_UNSPECIFIED: SIGN_MODE_UNSPECIFIED specifies an unknown signing mode and will be\nrejected\n - SIGN_MODE_DIRECT: SIGN_MODE_DIRECT specifies a signing mode which uses SignDoc and is\nverified with raw bytes from Tx\n - SIGN_MODE_TEXTUAL: SIGN_MODE_TEXTUAL is a future signing mode that will verify some\nhuman-readable textual representation on top of the binary representation\nfrom SIGN_MODE_DIRECT\n - SIGN_MODE_LEGACY_AMINO_JSON: SIGN_MODE_LEGACY_AMINO_JSON is a backwards compatibility mode which uses\nAmino JSON and will be removed in the future",
                            "default": "SIGN_MODE_UNSPECIFIED",
                            "enum": [
                                "SIGN_MODE_UNSPECIFIED",
                                "SIGN_MODE_DIRECT",
                                "SIGN_MODE_TEXTUAL",
                                "SIGN_MODE_LEGACY_AMINO_JSON"
                            ],
                            "type": "string"
                        }
                    }
                },
                "multi": {
                    "$ref": "#/definitions/cosmos.tx.v1beta1.ModeInfo.Multi"
                }
            }
        },
        "cosmos.tx.v1beta1.ModeInfo.Multi": {
            "title": "Multi is the mode info for a multisig public key",
            "type": "object",
            "properties": {
                "bitarray": {
                    "title": "bitarray specifies which keys within the multisig are signing",
                    "description": "CompactBitArray is an implementation of a space efficient bit array.\nThis is used to ensure that the encoded data takes up a minimal amount of\nspace after proto encoding.\nThis is not thread safe, and is not intended for concurrent usage.",
                    "type": "object",
                    "properties": {
                        "extra_bits_stored": {
                            "format": "int64",
                            "type": "integer"
                        },
                        "elems": {
                            "format": "byte",
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string"
                        }
                    }
                },
                "mode_infos": {
                    "title": "mode_infos is the corresponding modes of the signers of the multisig\nwhich could include nested multisig public keys",
                    "type": "array",
                    "items": {
                        "$ref": "#/definitions/cosmos.tx.v1beta1.ModeInfo"
                    }
                }
            }
        },
        "cosmos.tx.v1beta1.ModeInfo.Single": {
            "title": "Single is the mode info for a single signer. It is structured as a message\nto allow for additional fields such as locale for SIGN_MODE_TEXTUAL in the\nfuture",
            "type": "object",
            "properties": {
                "mode": {
                    "title": "mode is the signing mode of the single signer",
                    "description": "SignMode represents a signing mode with its own security guarantees.\n\n - SIGN_MODE_UNSPECIFIED: SIGN_MODE_UNSPECIFIED specifies an unknown signing mode and will be\nrejected\n - SIGN_MODE_DIRECT: SIGN_MODE_DIRECT specifies a signing mode which uses SignDoc and is\nverified with raw bytes from Tx\n - SIGN_MODE_TEXTUAL: SIGN_MODE_TEXTUAL is a future signing mode that will verify some\nhuman-readable textual representation on top of the binary representation\nfrom SIGN_MODE_DIRECT\n - SIGN_MODE_LEGACY_AMINO_JSON: SIGN_MODE_LEGACY_AMINO_JSON is a backwards compatibility mode which uses\nAmino JSON and will be removed in the future",
                    "default": "SIGN_MODE_UNSPECIFIED",
                    "enum": [
                        "SIGN_MODE_UNSPECIFIED",
                        "SIGN_MODE_DIRECT",
                        "SIGN_MODE_TEXTUAL",
                        "SIGN_MODE_LEGACY_AMINO_JSON"
                    ],
                    "type": "string"
                }
            }
        },
        "cosmos.tx.v1beta1.OrderBy": {
            "title": "OrderBy defines the sorting order",
            "description": "- ORDER_BY_UNSPECIFIED: ORDER_BY_UNSPECIFIED specifies an unknown sorting order. OrderBy defaults to ASC in this case.\n - ORDER_BY_ASC: ORDER_BY_ASC defines ascending order\n - ORDER_BY_DESC: ORDER_BY_DESC defines descending order",
            "default": "ORDER_BY_UNSPECIFIED",
            "enum": [
                "ORDER_BY_UNSPECIFIED",
                "ORDER_BY_ASC",
                "ORDER_BY_DESC"
            ],
            "type": "string"
        },
        "cosmos.tx.v1beta1.SignerInfo": {
            "description": "SignerInfo describes the public key and signing mode of a single top-level\nsigner.",
            "type": "object",
            "properties": {
                "public_key": {
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                    "type": "object",
                    "properties": {
                        "type_url": {
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                            "type": "string"
                        },
                        "value": {
                            "format": "byte",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string"
                        }
                    }
                },
                "mode_info": {
                    "$ref": "#/definitions/cosmos.tx.v1beta1.ModeInfo"
                },
                "sequence": {
                    "format": "uint64",
                    "description": "sequence is the sequence of the account, which describes the\nnumber of committed transactions signed by a given address. It is used to\nprevent replay attacks.",
                    "type": "string"
                }
            }
        },
        "cosmos.tx.v1beta1.SimulateRequest": {
            "description": "SimulateRequest is the request type for the Service.Simulate\nRPC method.",
            "type": "object",
            "properties": {
                "tx": {
                    "$ref": "#/definitions/cosmos.tx.v1beta1.Tx"
                },
                "tx_bytes": {
                    "format": "byte",
                    "description": "tx_bytes is the raw transaction.",
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string"
                }
            }
        },
        "cosmos.tx.v1beta1.SimulateResponse": {
            "description": "SimulateResponse is the response type for the\nService.SimulateRPC method.",
            "type": "object",
            "properties": {
                "gas_info": {
                    "description": "gas_info is the information about gas used in the simulation.",
                    "type": "object",
                    "properties": {
                        "gas_wanted": {
                            "format": "uint64",
                            "description": "GasWanted is the maximum units of work we allow this tx to perform.",
                            "type": "string"
                        },
                        "gas_used": {
                            "format": "uint64",
                            "description": "GasUsed is the amount of gas actually consumed.",
                            "type": "string"
                        }
                    }
                },
                "result": {
                    "description": "result is the result of the simulation.",
                    "type": "object",
                    "properties": {
                        "data": {
                            "format": "byte",
                            "description": "Data is any data returned from message or handler execution. It MUST be\nlength prefixed in order to separate data from multiple message executions.",
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string"
                        },
                        "log": {
                            "description": "Log contains the log information from message or handler execution.",
                            "type": "string"
                        },
                        "events": {
                            "description": "Events contains a slice of Event objects that were emitted during message\nor handler execution.",
                            "type": "array",
                            "items": {
                                "description": "Event allows application developers to attach additional information to\nResponseBeginBlock, ResponseEndBlock, ResponseCheckTx and ResponseDeliverTx.\nLater, transactions may be queried using these events.",
                                "type": "object",
                                "properties": {
                                    "type": {
                                        "type": "string"
                                    },
                                    "attributes": {
                                        "type": "array",
                                        "items": {
                                            "description": "EventAttribute is a single key-value pair, associated with an event.",
                                            "type": "object",
                                            "properties": {
                                                "key": {
                                                    "format": "byte",
                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                    "type": "string"
                                                },
                                                "value": {
                                                    "format": "byte",
                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                    "type": "string"
                                                },
                                                "index": {
                                                    "format": "boolean",
                                                    "type": "boolean"
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        },
        "cosmos.tx.v1beta1.Tx": {
            "description": "Tx is the standard type used for broadcasting transactions.",
            "type": "object",
            "properties": {
                "body": {
                    "title": "body is the processable content of the transaction",
                    "description": "TxBody is the body of a transaction that all signers sign over.",
                    "type": "object",
                    "properties": {
                        "messages": {
                            "description": "messages is a list of messages to be executed. The required signers of\nthose messages define the number and order of elements in AuthInfo's\nsigner_infos and Tx's signatures. Each required signer address is added to\nthe list only the first time it occurs.\nBy convention, the first required signer (usually from the first message)\nis referred to as the primary signer and pays the fee for the whole\ntransaction.",
                            "type": "array",
                            "items": {
                                "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                "type": "object",
                                "properties": {
                                    "type_url": {
                                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                        "type": "string"
                                    },
                                    "value": {
                                        "format": "byte",
                                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                        "type": "string"
                                    }
                                }
                            }
                        },
                        "memo": {
                            "description": "memo is any arbitrary note/comment to be added to the transaction.\nWARNING: in clients, any publicly exposed text should not be called memo,\nbut should be called `note` instead (see https://github.com/cosmos/cosmos-sdk/issues/9122).",
                            "type": "string"
                        },
                        "timeout_height": {
                            "format": "uint64",
                            "title": "timeout is the block height after which this transaction will not\nbe processed by the chain",
                            "type": "string"
                        },
                        "extension_options": {
                            "title": "extension_options are arbitrary options that can be added by chains\nwhen the default options are not sufficient. If any of these are present\nand can't be handled, the transaction will be rejected",
                            "type": "array",
                            "items": {
                                "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                "type": "object",
                                "properties": {
                                    "type_url": {
                                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                        "type": "string"
                                    },
                                    "value": {
                                        "format": "byte",
                                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                        "type": "string"
                                    }
                                }
                            }
                        },
                        "non_critical_extension_options": {
                            "title": "extension_options are arbitrary options that can be added by chains\nwhen the default options are not sufficient. If any of these are present\nand can't be handled, they will be ignored",
                            "type": "array",
                            "items": {
                                "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                "type": "object",
                                "properties": {
                                    "type_url": {
                                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                        "type": "string"
                                    },
                                    "value": {
                                        "format": "byte",
                                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                        "type": "string"
                                    }
                                }
                            }
                        }
                    }
                },
                "auth_info": {
                    "$ref": "#/definitions/cosmos.tx.v1beta1.AuthInfo"
                },
                "signatures": {
                    "description": "signatures is a list of signatures that matches the length and order of\nAuthInfo's signer_infos to allow connecting signature meta information like\npublic key and signing mode by position.",
                    "type": "array",
                    "items": {
                        "format": "byte",
                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                        "type": "string"
                    }
                }
            }
        },
        "cosmos.tx.v1beta1.TxBody": {
            "description": "TxBody is the body of a transaction that all signers sign over.",
            "type": "object",
            "properties": {
                "messages": {
                    "description": "messages is a list of messages to be executed. The required signers of\nthose messages define the number and order of elements in AuthInfo's\nsigner_infos and Tx's signatures. Each required signer address is added to\nthe list only the first time it occurs.\nBy convention, the first required signer (usually from the first message)\nis referred to as the primary signer and pays the fee for the whole\ntransaction.",
                    "type": "array",
                    "items": {
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                        "type": "object",
                        "properties": {
                            "type_url": {
                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                "type": "string"
                            },
                            "value": {
                                "format": "byte",
                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                "type": "string"
                            }
                        }
                    }
                },
                "memo": {
                    "description": "memo is any arbitrary note/comment to be added to the transaction.\nWARNING: in clients, any publicly exposed text should not be called memo,\nbut should be called `note` instead (see https://github.com/cosmos/cosmos-sdk/issues/9122).",
                    "type": "string"
                },
                "timeout_height": {
                    "format": "uint64",
                    "title": "timeout is the block height after which this transaction will not\nbe processed by the chain",
                    "type": "string"
                },
                "extension_options": {
                    "title": "extension_options are arbitrary options that can be added by chains\nwhen the default options are not sufficient. If any of these are present\nand can't be handled, the transaction will be rejected",
                    "type": "array",
                    "items": {
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                        "type": "object",
                        "properties": {
                            "type_url": {
                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                "type": "string"
                            },
                            "value": {
                                "format": "byte",
                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                "type": "string"
                            }
                        }
                    }
                },
                "non_critical_extension_options": {
                    "title": "extension_options are arbitrary options that can be added by chains\nwhen the default options are not sufficient. If any of these are present\nand can't be handled, they will be ignored",
                    "type": "array",
                    "items": {
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                        "type": "object",
                        "properties": {
                            "type_url": {
                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                "type": "string"
                            },
                            "value": {
                                "format": "byte",
                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                "type": "string"
                            }
                        }
                    }
                }
            }
        },
        "tendermint.abci.Event": {
            "description": "Event allows application developers to attach additional information to\nResponseBeginBlock, ResponseEndBlock, ResponseCheckTx and ResponseDeliverTx.\nLater, transactions may be queried using these events.",
            "type": "object",
            "properties": {
                "type": {
                    "type": "string"
                },
                "attributes": {
                    "type": "array",
                    "items": {
                        "description": "EventAttribute is a single key-value pair, associated with an event.",
                        "type": "object",
                        "properties": {
                            "key": {
                                "format": "byte",
                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                "type": "string"
                            },
                            "value": {
                                "format": "byte",
                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                "type": "string"
                            },
                            "index": {
                                "format": "boolean",
                                "type": "boolean"
                            }
                        }
                    }
                }
            }
        },
        "tendermint.abci.EventAttribute": {
            "description": "EventAttribute is a single key-value pair, associated with an event.",
            "type": "object",
            "properties": {
                "key": {
                    "format": "byte",
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string"
                },
                "value": {
                    "format": "byte",
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string"
                },
                "index": {
                    "format": "boolean",
                    "type": "boolean"
                }
            }
        },
        "cosmos.upgrade.v1beta1.ModuleVersion": {
            "description": "ModuleVersion specifies a module and its consensus version.",
            "type": "object",
            "properties": {
                "name": {
                    "title": "name of the app module",
                    "type": "string"
                },
                "version": {
                    "format": "uint64",
                    "title": "consensus version of the app module",
                    "type": "string"
                }
            }
        },
        "cosmos.upgrade.v1beta1.Plan": {
            "description": "Plan specifies information about a planned upgrade and when it should occur.",
            "type": "object",
            "properties": {
                "name": {
                    "description": "Sets the name for the upgrade. This name will be used by the upgraded\nversion of the software to apply any special \"on-upgrade\" commands during\nthe first BeginBlock method after the upgrade is applied. It is also used\nto detect whether a software version can handle a given upgrade. If no\nupgrade handler with this name has been set in the software, it will be\nassumed that the software is out-of-date when the upgrade Time or Height is\nreached and the software will exit.",
                    "type": "string"
                },
                "time": {
                    "format": "date-time",
                    "description": "Deprecated: Time based upgrades have been deprecated. Time based upgrade logic\nhas been removed from the SDK.\nIf this field is not empty, an error will be thrown.",
                    "type": "string"
                },
                "height": {
                    "format": "int64",
                    "description": "The height at which the upgrade must be performed.\nOnly used if Time is not set.",
                    "type": "string"
                },
                "info": {
                    "title": "Any application specific upgrade info to be included on-chain\nsuch as a git commit that validators could automatically upgrade to",
                    "type": "string"
                },
                "upgraded_client_state": {
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                    "type": "object",
                    "properties": {
                        "type_url": {
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                            "type": "string"
                        },
                        "value": {
                            "format": "byte",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string"
                        }
                    }
                }
            }
        },
        "cosmos.upgrade.v1beta1.QueryAppliedPlanResponse": {
            "description": "QueryAppliedPlanResponse is the response type for the Query/AppliedPlan RPC\nmethod.",
            "type": "object",
            "properties": {
                "height": {
                    "format": "int64",
                    "description": "height is the block height at which the plan was applied.",
                    "type": "string"
                }
            }
        },
        "cosmos.upgrade.v1beta1.QueryCurrentPlanResponse": {
            "description": "QueryCurrentPlanResponse is the response type for the Query/CurrentPlan RPC\nmethod.",
            "type": "object",
            "properties": {
                "plan": {
                    "description": "plan is the current upgrade plan.",
                    "type": "object",
                    "properties": {
                        "name": {
                            "description": "Sets the name for the upgrade. This name will be used by the upgraded\nversion of the software to apply any special \"on-upgrade\" commands during\nthe first BeginBlock method after the upgrade is applied. It is also used\nto detect whether a software version can handle a given upgrade. If no\nupgrade handler with this name has been set in the software, it will be\nassumed that the software is out-of-date when the upgrade Time or Height is\nreached and the software will exit.",
                            "type": "string"
                        },
                        "time": {
                            "format": "date-time",
                            "description": "Deprecated: Time based upgrades have been deprecated. Time based upgrade logic\nhas been removed from the SDK.\nIf this field is not empty, an error will be thrown.",
                            "type": "string"
                        },
                        "height": {
                            "format": "int64",
                            "description": "The height at which the upgrade must be performed.\nOnly used if Time is not set.",
                            "type": "string"
                        },
                        "info": {
                            "title": "Any application specific upgrade info to be included on-chain\nsuch as a git commit that validators could automatically upgrade to",
                            "type": "string"
                        },
                        "upgraded_client_state": {
                            "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                            "type": "object",
                            "properties": {
                                "type_url": {
                                    "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                    "type": "string"
                                },
                                "value": {
                                    "format": "byte",
                                    "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                    "type": "string"
                                }
                            }
                        }
                    }
                }
            }
        },
        "cosmos.upgrade.v1beta1.QueryModuleVersionsResponse": {
            "description": "QueryModuleVersionsResponse is the response type for the Query/ModuleVersions\nRPC method.",
            "type": "object",
            "properties": {
                "module_versions": {
                    "description": "module_versions is a list of module names with their consensus versions.",
                    "type": "array",
                    "items": {
                        "description": "ModuleVersion specifies a module and its consensus version.",
                        "type": "object",
                        "properties": {
                            "name": {
                                "title": "name of the app module",
                                "type": "string"
                            },
                            "version": {
                                "format": "uint64",
                                "title": "consensus version of the app module",
                                "type": "string"
                            }
                        }
                    }
                }
            }
        },
        "cosmos.upgrade.v1beta1.QueryUpgradedConsensusStateResponse": {
            "description": "QueryUpgradedConsensusStateResponse is the response type for the Query/UpgradedConsensusState\nRPC method.",
            "type": "object",
            "properties": {
                "upgraded_consensus_state": {
                    "format": "byte",
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string"
                }
            }
        },
        "cosmos.authz.v1beta1.Grant": {
            "description": "Grant gives permissions to execute\nthe provide method with expiration time.",
            "type": "object",
            "properties": {
                "authorization": {
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                    "type": "object",
                    "properties": {
                        "type_url": {
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                            "type": "string"
                        },
                        "value": {
                            "format": "byte",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string"
                        }
                    }
                },
                "expiration": {
                    "format": "date-time",
                    "type": "string"
                }
            }
        },
        "cosmos.authz.v1beta1.QueryGrantsResponse": {
            "description": "QueryGrantsResponse is the response type for the Query/Authorizations RPC method.",
            "type": "object",
            "properties": {
                "grants": {
                    "description": "authorizations is a list of grants granted for grantee by granter.",
                    "type": "array",
                    "items": {
                        "description": "Grant gives permissions to execute\nthe provide method with expiration time.",
                        "type": "object",
                        "properties": {
                            "authorization": {
                                "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := ptypes.MarshalAny(foo)\n     ...\n     foo := &pb.Foo{}\n     if err := ptypes.UnmarshalAny(any, foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n====\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }",
                                "type": "object",
                                "properties": {
                                    "type_url": {
                                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                        "type": "string"
                                    },
                                    "value": {
                                        "format": "byte",
                                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                        "type": "string"
                                    }
                                }
                            },
                            "expiration": {
                                "format": "date-time",
                                "type": "string"
                            }
                        }
                    }
                },
                "pagination": {
                    "description": "pagination defines an pagination for the response.",
                    "type": "object",
                    "properties": {
                        "next_key": {
                            "format": "byte",
                            "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently",
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string"
                        },
                        "total": {
                            "format": "uint64",
                            "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                            "type": "string"
                        }
                    }
                }
            }
        },
        "cosmos.feegrant.v1beta1.Grant": {
            "title": "Grant is stored in the KVStore to record a grant with full context",
            "type": "object",
            "properties": {
                "granter": {
                    "description": "granter is the address of the user granting an allowance of their funds.",
                    "type": "string"
                },
                "grantee": {
                    "description": "grantee is the address of the user being granted an allowance of another user's funds.",
                    "type": "string"
                },
                "allowance": {
                    "description": "allowance can be any of basic and filtered fee allowance.",
                    "type": "object",
                    "properties": {
                        "type_url": {
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                            "type": "string"
                        },
                        "value": {
                            "format": "byte",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string"
                        }
                    }
                }
            }
        },
        "cosmos.feegrant.v1beta1.QueryAllowanceResponse": {
            "description": "QueryAllowanceResponse is the response type for the Query/Allowance RPC method.",
            "type": "object",
            "properties": {
                "allowance": {
                    "title": "Grant is stored in the KVStore to record a grant with full context",
                    "description": "allowance is a allowance granted for grantee by granter.",
                    "type": "object",
                    "properties": {
                        "granter": {
                            "description": "granter is the address of the user granting an allowance of their funds.",
                            "type": "string"
                        },
                        "grantee": {
                            "description": "grantee is the address of the user being granted an allowance of another user's funds.",
                            "type": "string"
                        },
                        "allowance": {
                            "description": "allowance can be any of basic and filtered fee allowance.",
                            "type": "object",
                            "properties": {
                                "type_url": {
                                    "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                    "type": "string"
                                },
                                "value": {
                                    "format": "byte",
                                    "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                    "type": "string"
                                }
                            }
                        }
                    }
                }
            }
        },
        "cosmos.feegrant.v1beta1.QueryAllowancesResponse": {
            "description": "QueryAllowancesResponse is the response type for the Query/Allowances RPC method.",
            "type": "object",
            "properties": {
                "allowances": {
                    "description": "allowances are allowance's granted for grantee by granter.",
                    "type": "array",
                    "items": {
                        "title": "Grant is stored in the KVStore to record a grant with full context",
                        "type": "object",
                        "properties": {
                            "granter": {
                                "description": "granter is the address of the user granting an allowance of their funds.",
                                "type": "string"
                            },
                            "grantee": {
                                "description": "grantee is the address of the user being granted an allowance of another user's funds.",
                                "type": "string"
                            },
                            "allowance": {
                                "description": "allowance can be any of basic and filtered fee allowance.",
                                "type": "object",
                                "properties": {
                                    "type_url": {
                                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
                                        "type": "string"
                                    },
                                    "value": {
                                        "format": "byte",
                                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                        "type": "string"
                                    }
                                }
                            }
                        }
                    }
                },
                "pagination": {
                    "description": "pagination defines an pagination for the response.",
                    "type": "object",
                    "properties": {
                        "next_key": {
                            "format": "byte",
                            "title": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently",
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string"
                        },
                        "total": {
                            "format": "uint64",
                            "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                            "type": "string"
                        }
                    }
                }
            }
        },
        "secret.registration.v1beta1.Key": {
            "type": "object",
            "properties": {
                "key": {
                    "format": "byte",
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string"
                }
            }
        },
        "secret.registration.v1beta1.QueryEncryptedSeedResponse": {
            "type": "object",
            "properties": {
                "encrypted_seed": {
                    "format": "byte",
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string"
                }
            }
        },
        "SecretNetwork.x.compute.v1beta1.AbsoluteTxPosition": {
            "title": "AbsoluteTxPosition can be used to sort contracts",
            "type": "object",
            "properties": {
                "block_height": {
                    "format": "int64",
                    "title": "BlockHeight is the block the contract was created at",
                    "type": "string"
                },
                "tx_index": {
                    "format": "uint64",
                    "title": "TxIndex is a monotonic counter within the block (actual transaction index, or gas consumed)",
                    "type": "string"
                }
            }
        },
        "SecretNetwork.x.compute.v1beta1.CodeInfoResponse": {
            "type": "object",
            "properties": {
                "code_id": {
                    "format": "uint64",
                    "type": "string"
                },
                "creator": {
                    "format": "byte",
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string"
                },
                "data_hash": {
                    "format": "byte",
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string"
                },
                "source": {
                    "type": "string"
                },
                "builder": {
                    "type": "string"
                }
            }
        },
        "SecretNetwork.x.compute.v1beta1.ContractInfo": {
            "title": "ContractInfo stores a WASM contract instance",
            "type": "object",
            "properties": {
                "code_id": {
                    "format": "uint64",
                    "type": "string"
                },
                "creator": {
                    "format": "byte",
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string"
                },
                "label": {
                    "title": "bytes admin = 3 [(gogoproto.casttype) = \"github.com/cosmos/cosmos-sdk/types.AccAddress\"];",
                    "type": "string"
                },
                "created": {
                    "title": "never show this in query results, just use for sorting\n(Note: when using json tag \"-\" amino refused to serialize it...)",
                    "type": "object",
                    "properties": {
                        "block_height": {
                            "format": "int64",
                            "title": "BlockHeight is the block the contract was created at",
                            "type": "string"
                        },
                        "tx_index": {
                            "format": "uint64",
                            "title": "TxIndex is a monotonic counter within the block (actual transaction index, or gas consumed)",
                            "type": "string"
                        }
                    }
                }
            }
        },
        "SecretNetwork.x.compute.v1beta1.ContractInfoWithAddress": {
            "title": "ContractInfoWithAddress adds the address (key) to the ContractInfo representation",
            "type": "object",
            "properties": {
                "address": {
                    "format": "byte",
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string"
                },
                "ContractInfo": {
                    "title": "ContractInfo stores a WASM contract instance",
                    "type": "object",
                    "properties": {
                        "code_id": {
                            "format": "uint64",
                            "type": "string"
                        },
                        "creator": {
                            "format": "byte",
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string"
                        },
                        "label": {
                            "title": "bytes admin = 3 [(gogoproto.casttype) = \"github.com/cosmos/cosmos-sdk/types.AccAddress\"];",
                            "type": "string"
                        },
                        "created": {
                            "title": "never show this in query results, just use for sorting\n(Note: when using json tag \"-\" amino refused to serialize it...)",
                            "type": "object",
                            "properties": {
                                "block_height": {
                                    "format": "int64",
                                    "title": "BlockHeight is the block the contract was created at",
                                    "type": "string"
                                },
                                "tx_index": {
                                    "format": "uint64",
                                    "title": "TxIndex is a monotonic counter within the block (actual transaction index, or gas consumed)",
                                    "type": "string"
                                }
                            }
                        }
                    }
                }
            }
        },
        "SecretNetwork.x.compute.v1beta1.QueryCodeResponse": {
            "type": "object",
            "properties": {
                "code_info": {
                    "type": "object",
                    "properties": {
                        "code_id": {
                            "format": "uint64",
                            "type": "string"
                        },
                        "creator": {
                            "format": "byte",
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string"
                        },
                        "data_hash": {
                            "format": "byte",
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string"
                        },
                        "source": {
                            "type": "string"
                        },
                        "builder": {
                            "type": "string"
                        }
                    }
                },
                "data": {
                    "format": "byte",
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string"
                }
            }
        },
        "SecretNetwork.x.compute.v1beta1.QueryCodesResponse": {
            "type": "object",
            "properties": {
                "code_infos": {
                    "type": "array",
                    "items": {
                        "type": "object",
                        "properties": {
                            "code_id": {
                                "format": "uint64",
                                "type": "string"
                            },
                            "creator": {
                                "format": "byte",
                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                "type": "string"
                            },
                            "data_hash": {
                                "format": "byte",
                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                "type": "string"
                            },
                            "source": {
                                "type": "string"
                            },
                            "builder": {
                                "type": "string"
                            }
                        }
                    }
                }
            }
        },
        "SecretNetwork.x.compute.v1beta1.QueryContractInfoResponse": {
            "title": "QueryContractInfoResponse is the response type for the Query/ContractInfo RPC method",
            "type": "object",
            "properties": {
                "address": {
                    "format": "byte",
                    "title": "address is the address of the contract",
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string"
                },
                "ContractInfo": {
                    "title": "ContractInfo stores a WASM contract instance",
                    "type": "object",
                    "properties": {
                        "code_id": {
                            "format": "uint64",
                            "type": "string"
                        },
                        "creator": {
                            "format": "byte",
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string"
                        },
                        "label": {
                            "title": "bytes admin = 3 [(gogoproto.casttype) = \"github.com/cosmos/cosmos-sdk/types.AccAddress\"];",
                            "type": "string"
                        },
                        "created": {
                            "title": "never show this in query results, just use for sorting\n(Note: when using json tag \"-\" amino refused to serialize it...)",
                            "type": "object",
                            "properties": {
                                "block_height": {
                                    "format": "int64",
                                    "title": "BlockHeight is the block the contract was created at",
                                    "type": "string"
                                },
                                "tx_index": {
                                    "format": "uint64",
                                    "title": "TxIndex is a monotonic counter within the block (actual transaction index, or gas consumed)",
                                    "type": "string"
                                }
                            }
                        }
                    }
                }
            }
        },
        "SecretNetwork.x.compute.v1beta1.QueryContractsByCodeResponse": {
            "type": "object",
            "properties": {
                "contract_infos": {
                    "type": "array",
                    "items": {
                        "title": "ContractInfoWithAddress adds the address (key) to the ContractInfo representation",
                        "type": "object",
                        "properties": {
                            "address": {
                                "format": "byte",
                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                "type": "string"
                            },
                            "ContractInfo": {
                                "title": "ContractInfo stores a WASM contract instance",
                                "type": "object",
                                "properties": {
                                    "code_id": {
                                        "format": "uint64",
                                        "type": "string"
                                    },
                                    "creator": {
                                        "format": "byte",
                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                        "type": "string"
                                    },
                                    "label": {
                                        "title": "bytes admin = 3 [(gogoproto.casttype) = \"github.com/cosmos/cosmos-sdk/types.AccAddress\"];",
                                        "type": "string"
                                    },
                                    "created": {
                                        "title": "never show this in query results, just use for sorting\n(Note: when using json tag \"-\" amino refused to serialize it...)",
                                        "type": "object",
                                        "properties": {
                                            "block_height": {
                                                "format": "int64",
                                                "title": "BlockHeight is the block the contract was created at",
                                                "type": "string"
                                            },
                                            "tx_index": {
                                                "format": "uint64",
                                                "title": "TxIndex is a monotonic counter within the block (actual transaction index, or gas consumed)",
                                                "type": "string"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        },
        "SecretNetwork.x.compute.v1beta1.QuerySmartContractStateResponse": {
            "type": "object",
            "properties": {
                "data": {
                    "format": "byte",
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string"
                }
            }
        }
    },
    "tags": [
        {
            "name": "Auth",
            "description": "Authenticate accounts"
        },
        {
            "name": "Transactions",
            "description": "Search, encode, or broadcast transactions."
        },
        {
            "name": "Mint",
            "description": "Minting module APIs"
        },
        {
            "name": "Bank",
            "description": "Create and broadcast transactions"
        },
        {
            "name": "Reg",
            "description": "Registration & key exchange"
        },
        {
            "name": "Governance",
            "description": "Governance module APIs"
        },
        {
            "name": "Distribution",
            "description": "Fee distribution module APIs"
        },
        {
            "name": "Slashing",
            "description": "Slashing module APIs"
        },
        {
            "name": "Supply",
            "description": "Supply module APIs"
        },
        {
            "name": "Misc",
            "description": "Query app version"
        },
        {
            "name": "Wasm",
            "description": "Wasm stuff"
        },
        {
            "name": "Staking",
            "description": "Stake module APIs"
        },
        {
            "name": "version"
        },
        {
            "name": "Tendermint RPC",
            "description": "Tendermint APIs, such as query blocks, transactions and validatorset"
        }
    ]
}
use attestation::sgx_quote::{SgxEcdsaQuoteAkType, SgxEpidQuoteSigType, SgxQuoteVersion};
use attestation::sgx_report::SgxEnclaveReport;

use log::{error, warn};
use secret_attestation_token::Error;
use sgx_tcrypto::rsgx_sha256_slice;
use sgx_types::{sgx_quote_nonce_t, sgx_report_t, sgx_status_t, SgxResult};
use std::convert::TryFrom;
use uuid::Uuid;

/// An application that hosts an enclave can ask the enclave to produce a report
/// (`SgxEnclaveReport`) and then pass this report to a platform service
/// (Quoting Enclave) to produce a type of credential that reflects the enclave
/// and platform state. The quote can be passed to entities off the platform,
/// and verified using Intel EPID signature verification techniques.
pub struct EpidSgxQuote {
    /// Version of the quote structure
    pub version: SgxQuoteVersion,
    /// ID of the Intel EPID group of the platform belongs to
    pub gid: u32,
    /// Security version number of Quoting Enclave
    pub isv_svn_qe: u16,
    /// Security version number of PCE
    pub isv_svn_pce: u16,
    /// Vendor ID of Quoting Enclave
    pub qe_vendor_id: Uuid,
    /// User data
    pub user_data: [u8; 20],
    /// Report generated by the enclave
    pub isv_enclave_report: SgxEnclaveReport,
}

impl std::fmt::Debug for EpidSgxQuote {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        writeln!(f, "version: {:?}", self.version)?;
        writeln!(f, "gid: {}", self.gid)?;
        writeln!(f, "isv_svn_qe: {}", self.isv_svn_qe)?;
        writeln!(f, "isv_svn_pce: {}", self.isv_svn_pce)?;
        writeln!(f, "qe_vendor_id: {}", self.qe_vendor_id)?;
        writeln!(f, "user_data: {:?}", &self.user_data)?;
        writeln!(f, "isv_enclave_report: \n{:?}", self.isv_enclave_report)
    }
}

impl EpidSgxQuote {
    /// Parse from bytes to `SgxQuote`.
    // just unused in SW mode
    #[allow(dead_code)]
    pub fn parse_from<'a>(bytes: &'a [u8]) -> Result<Self, Error> {
        let mut pos: usize = 0;
        let mut take = |n: usize| -> Result<&'a [u8], Error> {
            if n > 0 && bytes.len() >= pos + n {
                let ret = &bytes[pos..pos + n];
                pos += n;
                Ok(ret)
            } else {
                warn!("Quote parsing error.");
                Err(Error::ReportParseError)
            }
        };

        // Parse by bytes according to specifications.
        // off 0, size 2 + 2
        let version = match u16::from_le_bytes(<[u8; 2]>::try_from(take(2)?)?) {
            1 => {
                let signature_type = match u16::from_le_bytes(<[u8; 2]>::try_from(
                    take(2).map_err(|_| Error::ReportParseError)?,
                )?) {
                    0 => SgxEpidQuoteSigType::Unlinkable,
                    1 => SgxEpidQuoteSigType::Linkable,
                    _ => {
                        warn!("Invalid v1 quote signature type");
                        return Err(Error::ReportParseError);
                    }
                };
                SgxQuoteVersion::V1(signature_type)
            }
            2 => {
                let signature_type = match u16::from_le_bytes(<[u8; 2]>::try_from(
                    take(2).map_err(|_| Error::ReportParseError)?,
                )?) {
                    0 => SgxEpidQuoteSigType::Unlinkable,
                    1 => SgxEpidQuoteSigType::Linkable,
                    _ => {
                        warn!("Invalid v2 quote signature type");
                        return Err(Error::ReportParseError);
                    }
                };
                SgxQuoteVersion::V2(signature_type)
            }
            3 => {
                let attestation_key_type = match u16::from_le_bytes(<[u8; 2]>::try_from(
                    take(2).map_err(|_| Error::ReportParseError)?,
                )?) {
                    2 => SgxEcdsaQuoteAkType::P256_256,
                    3 => SgxEcdsaQuoteAkType::P384_384,
                    _ => {
                        warn!("Quote parsing error - ecdsa quote type invalid");
                        return Err(Error::ReportParseError);
                    }
                };
                SgxQuoteVersion::V3(attestation_key_type)
            }
            _ => {
                warn!("Quote parsing error - Unknown quote version");
                return Err(Error::ReportParseError);
            }
        };

        // off 4, size 4
        let gid = u32::from_le_bytes(<[u8; 4]>::try_from(take(4).map_err(|_| {
            warn!("Failed to parse quote gid");
            Error::ReportParseError
        })?)?);

        // off 8, size 2
        let isv_svn_qe = u16::from_le_bytes(<[u8; 2]>::try_from(take(2).map_err(|_| {
            warn!("Failed to parse quote isv svn qe");
            Error::ReportParseError
        })?)?);

        // off 10, size 2
        let isv_svn_pce = u16::from_le_bytes(<[u8; 2]>::try_from(take(2).map_err(|_| {
            warn!("Failed to parse quote isv svn");
            Error::ReportParseError
        })?)?);

        // off 12, size 16
        let qe_vendor_id_raw =
            <[u8; 16]>::try_from(take(16).map_err(|_| Error::ReportParseError)?)?;
        let qe_vendor_id = Uuid::from_slice(&qe_vendor_id_raw).map_err(|_| {
            warn!("Failed to parse quote vendor id");
            Error::ReportParseError
        })?;

        // off 28, size 20
        let user_data = <[u8; 20]>::try_from(take(20).map_err(|_| {
            warn!("Failed to parse quote user data");
            Error::ReportParseError
        })?)?;

        // off 48, size 384
        let isv_enclave_report = SgxEnclaveReport::parse_from(take(384).map_err(|_| {
            warn!("Failed to parse enclave report");
            Error::ReportParseError
        })?)?;

        if pos != bytes.len() {
            warn!("Quote parsing error - Quote size different from expected");
            return Err(Error::ReportParseError);
        };

        Ok(Self {
            version,
            gid,
            isv_svn_qe,
            isv_svn_pce,
            qe_vendor_id,
            user_data,
            isv_enclave_report,
        })
    }
}

pub fn check_sgx_quote_is_tampered(
    qe_report: sgx_report_t,
    quote_nonce: sgx_quote_nonce_t,
    quote_len: u32,
    return_quote_buf: &[u8],
    report_data_len: usize,
) -> SgxResult<()> {
    // Check qe_report to defend against replay attack
    // The purpose of p_qe_report is for the ISV enclave to confirm the QUOTE
    // it received is not modified by the untrusted SW stack, and not a replay.
    // The implementation in QE is to generate a REPORT targeting the ISV
    // enclave (target info from p_report) , with the lower 32Bytes in
    // report.data = SHA256(p_nonce||p_quote). The ISV enclave can verify the
    // p_qe_report and report.data to confirm the QUOTE has not be modified and
    // is not a replay

    let mut rhs_vec: Vec<u8> = quote_nonce.rand.to_vec();
    rhs_vec.extend(&return_quote_buf[..quote_len as usize]);
    let rhs_hash = rsgx_sha256_slice(&rhs_vec[..]).unwrap();
    let lhs_hash = &qe_report.body.report_data.d[..report_data_len];

    // trace!("Report rhs hash = {:02X}", rhs_hash.iter().format(""));
    // trace!("Report lhs hash = {:02X}", lhs_hash.iter().format(""));

    if rhs_hash != lhs_hash {
        error!("Quote is tampered!");
        return Err(sgx_status_t::SGX_ERROR_UNEXPECTED);
    }

    Ok(())
}

// impl AsAuthenticationMaterial for EpidSgxQuote {
//     fn as_authentication_material(&self) -> SignedAuthenticationMaterial {
//         self.
//     }
// }

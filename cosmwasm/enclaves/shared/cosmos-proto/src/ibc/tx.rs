// This file is generated by rust-protobuf 2.25.2. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `ibc/core/channel/v1/tx.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_25_2;

#[derive(PartialEq,Clone,Default)]
pub struct MsgChannelOpenInit {
    // message fields
    pub port_id: ::std::string::String,
    pub channel: ::protobuf::SingularPtrField<super::channel::Channel>,
    pub signer: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MsgChannelOpenInit {
    fn default() -> &'a MsgChannelOpenInit {
        <MsgChannelOpenInit as ::protobuf::Message>::default_instance()
    }
}

impl MsgChannelOpenInit {
    pub fn new() -> MsgChannelOpenInit {
        ::std::default::Default::default()
    }

    // string port_id = 1;


    pub fn get_port_id(&self) -> &str {
        &self.port_id
    }
    pub fn clear_port_id(&mut self) {
        self.port_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_port_id(&mut self, v: ::std::string::String) {
        self.port_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_port_id(&mut self) -> &mut ::std::string::String {
        &mut self.port_id
    }

    // Take field
    pub fn take_port_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.port_id, ::std::string::String::new())
    }

    // .ibc.core.channel.v1.Channel channel = 2;


    pub fn get_channel(&self) -> &super::channel::Channel {
        self.channel.as_ref().unwrap_or_else(|| <super::channel::Channel as ::protobuf::Message>::default_instance())
    }
    pub fn clear_channel(&mut self) {
        self.channel.clear();
    }

    pub fn has_channel(&self) -> bool {
        self.channel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel(&mut self, v: super::channel::Channel) {
        self.channel = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_channel(&mut self) -> &mut super::channel::Channel {
        if self.channel.is_none() {
            self.channel.set_default();
        }
        self.channel.as_mut().unwrap()
    }

    // Take field
    pub fn take_channel(&mut self) -> super::channel::Channel {
        self.channel.take().unwrap_or_else(|| super::channel::Channel::new())
    }

    // string signer = 3;


    pub fn get_signer(&self) -> &str {
        &self.signer
    }
    pub fn clear_signer(&mut self) {
        self.signer.clear();
    }

    // Param is passed by value, moved
    pub fn set_signer(&mut self, v: ::std::string::String) {
        self.signer = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signer(&mut self) -> &mut ::std::string::String {
        &mut self.signer
    }

    // Take field
    pub fn take_signer(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.signer, ::std::string::String::new())
    }
}

impl ::protobuf::Message for MsgChannelOpenInit {
    fn is_initialized(&self) -> bool {
        for v in &self.channel {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.port_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.channel)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.signer)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.port_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.port_id);
        }
        if let Some(ref v) = self.channel.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.signer.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.signer);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.port_id.is_empty() {
            os.write_string(1, &self.port_id)?;
        }
        if let Some(ref v) = self.channel.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.signer.is_empty() {
            os.write_string(3, &self.signer)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MsgChannelOpenInit {
        MsgChannelOpenInit::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "port_id",
                |m: &MsgChannelOpenInit| { &m.port_id },
                |m: &mut MsgChannelOpenInit| { &mut m.port_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::channel::Channel>>(
                "channel",
                |m: &MsgChannelOpenInit| { &m.channel },
                |m: &mut MsgChannelOpenInit| { &mut m.channel },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "signer",
                |m: &MsgChannelOpenInit| { &m.signer },
                |m: &mut MsgChannelOpenInit| { &mut m.signer },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MsgChannelOpenInit>(
                "MsgChannelOpenInit",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MsgChannelOpenInit {
        static instance: ::protobuf::rt::LazyV2<MsgChannelOpenInit> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MsgChannelOpenInit::new)
    }
}

impl ::protobuf::Clear for MsgChannelOpenInit {
    fn clear(&mut self) {
        self.port_id.clear();
        self.channel.clear();
        self.signer.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MsgChannelOpenInit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgChannelOpenInit {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MsgChannelOpenInitResponse {
    // message fields
    pub channel_id: ::std::string::String,
    pub version: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MsgChannelOpenInitResponse {
    fn default() -> &'a MsgChannelOpenInitResponse {
        <MsgChannelOpenInitResponse as ::protobuf::Message>::default_instance()
    }
}

impl MsgChannelOpenInitResponse {
    pub fn new() -> MsgChannelOpenInitResponse {
        ::std::default::Default::default()
    }

    // string channel_id = 1;


    pub fn get_channel_id(&self) -> &str {
        &self.channel_id
    }
    pub fn clear_channel_id(&mut self) {
        self.channel_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_channel_id(&mut self, v: ::std::string::String) {
        self.channel_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_channel_id(&mut self) -> &mut ::std::string::String {
        &mut self.channel_id
    }

    // Take field
    pub fn take_channel_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.channel_id, ::std::string::String::new())
    }

    // string version = 2;


    pub fn get_version(&self) -> &str {
        &self.version
    }
    pub fn clear_version(&mut self) {
        self.version.clear();
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: ::std::string::String) {
        self.version = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version(&mut self) -> &mut ::std::string::String {
        &mut self.version
    }

    // Take field
    pub fn take_version(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.version, ::std::string::String::new())
    }
}

impl ::protobuf::Message for MsgChannelOpenInitResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.channel_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.version)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.channel_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.channel_id);
        }
        if !self.version.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.version);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.channel_id.is_empty() {
            os.write_string(1, &self.channel_id)?;
        }
        if !self.version.is_empty() {
            os.write_string(2, &self.version)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MsgChannelOpenInitResponse {
        MsgChannelOpenInitResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "channel_id",
                |m: &MsgChannelOpenInitResponse| { &m.channel_id },
                |m: &mut MsgChannelOpenInitResponse| { &mut m.channel_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "version",
                |m: &MsgChannelOpenInitResponse| { &m.version },
                |m: &mut MsgChannelOpenInitResponse| { &mut m.version },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MsgChannelOpenInitResponse>(
                "MsgChannelOpenInitResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MsgChannelOpenInitResponse {
        static instance: ::protobuf::rt::LazyV2<MsgChannelOpenInitResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MsgChannelOpenInitResponse::new)
    }
}

impl ::protobuf::Clear for MsgChannelOpenInitResponse {
    fn clear(&mut self) {
        self.channel_id.clear();
        self.version.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MsgChannelOpenInitResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgChannelOpenInitResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MsgChannelOpenTry {
    // message fields
    pub port_id: ::std::string::String,
    pub previous_channel_id: ::std::string::String,
    pub channel: ::protobuf::SingularPtrField<super::channel::Channel>,
    pub counterparty_version: ::std::string::String,
    pub proof_init: ::std::vec::Vec<u8>,
    pub proof_height: ::protobuf::SingularPtrField<super::client::Height>,
    pub signer: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MsgChannelOpenTry {
    fn default() -> &'a MsgChannelOpenTry {
        <MsgChannelOpenTry as ::protobuf::Message>::default_instance()
    }
}

impl MsgChannelOpenTry {
    pub fn new() -> MsgChannelOpenTry {
        ::std::default::Default::default()
    }

    // string port_id = 1;


    pub fn get_port_id(&self) -> &str {
        &self.port_id
    }
    pub fn clear_port_id(&mut self) {
        self.port_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_port_id(&mut self, v: ::std::string::String) {
        self.port_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_port_id(&mut self) -> &mut ::std::string::String {
        &mut self.port_id
    }

    // Take field
    pub fn take_port_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.port_id, ::std::string::String::new())
    }

    // string previous_channel_id = 2;


    pub fn get_previous_channel_id(&self) -> &str {
        &self.previous_channel_id
    }
    pub fn clear_previous_channel_id(&mut self) {
        self.previous_channel_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_previous_channel_id(&mut self, v: ::std::string::String) {
        self.previous_channel_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_previous_channel_id(&mut self) -> &mut ::std::string::String {
        &mut self.previous_channel_id
    }

    // Take field
    pub fn take_previous_channel_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.previous_channel_id, ::std::string::String::new())
    }

    // .ibc.core.channel.v1.Channel channel = 3;


    pub fn get_channel(&self) -> &super::channel::Channel {
        self.channel.as_ref().unwrap_or_else(|| <super::channel::Channel as ::protobuf::Message>::default_instance())
    }
    pub fn clear_channel(&mut self) {
        self.channel.clear();
    }

    pub fn has_channel(&self) -> bool {
        self.channel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel(&mut self, v: super::channel::Channel) {
        self.channel = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_channel(&mut self) -> &mut super::channel::Channel {
        if self.channel.is_none() {
            self.channel.set_default();
        }
        self.channel.as_mut().unwrap()
    }

    // Take field
    pub fn take_channel(&mut self) -> super::channel::Channel {
        self.channel.take().unwrap_or_else(|| super::channel::Channel::new())
    }

    // string counterparty_version = 4;


    pub fn get_counterparty_version(&self) -> &str {
        &self.counterparty_version
    }
    pub fn clear_counterparty_version(&mut self) {
        self.counterparty_version.clear();
    }

    // Param is passed by value, moved
    pub fn set_counterparty_version(&mut self, v: ::std::string::String) {
        self.counterparty_version = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_counterparty_version(&mut self) -> &mut ::std::string::String {
        &mut self.counterparty_version
    }

    // Take field
    pub fn take_counterparty_version(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.counterparty_version, ::std::string::String::new())
    }

    // bytes proof_init = 5;


    pub fn get_proof_init(&self) -> &[u8] {
        &self.proof_init
    }
    pub fn clear_proof_init(&mut self) {
        self.proof_init.clear();
    }

    // Param is passed by value, moved
    pub fn set_proof_init(&mut self, v: ::std::vec::Vec<u8>) {
        self.proof_init = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_proof_init(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.proof_init
    }

    // Take field
    pub fn take_proof_init(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.proof_init, ::std::vec::Vec::new())
    }

    // .ibc.core.client.v1.Height proof_height = 6;


    pub fn get_proof_height(&self) -> &super::client::Height {
        self.proof_height.as_ref().unwrap_or_else(|| <super::client::Height as ::protobuf::Message>::default_instance())
    }
    pub fn clear_proof_height(&mut self) {
        self.proof_height.clear();
    }

    pub fn has_proof_height(&self) -> bool {
        self.proof_height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_proof_height(&mut self, v: super::client::Height) {
        self.proof_height = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_proof_height(&mut self) -> &mut super::client::Height {
        if self.proof_height.is_none() {
            self.proof_height.set_default();
        }
        self.proof_height.as_mut().unwrap()
    }

    // Take field
    pub fn take_proof_height(&mut self) -> super::client::Height {
        self.proof_height.take().unwrap_or_else(|| super::client::Height::new())
    }

    // string signer = 7;


    pub fn get_signer(&self) -> &str {
        &self.signer
    }
    pub fn clear_signer(&mut self) {
        self.signer.clear();
    }

    // Param is passed by value, moved
    pub fn set_signer(&mut self, v: ::std::string::String) {
        self.signer = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signer(&mut self) -> &mut ::std::string::String {
        &mut self.signer
    }

    // Take field
    pub fn take_signer(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.signer, ::std::string::String::new())
    }
}

impl ::protobuf::Message for MsgChannelOpenTry {
    fn is_initialized(&self) -> bool {
        for v in &self.channel {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.proof_height {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.port_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.previous_channel_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.channel)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.counterparty_version)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.proof_init)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.proof_height)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.signer)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.port_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.port_id);
        }
        if !self.previous_channel_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.previous_channel_id);
        }
        if let Some(ref v) = self.channel.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.counterparty_version.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.counterparty_version);
        }
        if !self.proof_init.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.proof_init);
        }
        if let Some(ref v) = self.proof_height.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.signer.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.signer);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.port_id.is_empty() {
            os.write_string(1, &self.port_id)?;
        }
        if !self.previous_channel_id.is_empty() {
            os.write_string(2, &self.previous_channel_id)?;
        }
        if let Some(ref v) = self.channel.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.counterparty_version.is_empty() {
            os.write_string(4, &self.counterparty_version)?;
        }
        if !self.proof_init.is_empty() {
            os.write_bytes(5, &self.proof_init)?;
        }
        if let Some(ref v) = self.proof_height.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.signer.is_empty() {
            os.write_string(7, &self.signer)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MsgChannelOpenTry {
        MsgChannelOpenTry::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "port_id",
                |m: &MsgChannelOpenTry| { &m.port_id },
                |m: &mut MsgChannelOpenTry| { &mut m.port_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "previous_channel_id",
                |m: &MsgChannelOpenTry| { &m.previous_channel_id },
                |m: &mut MsgChannelOpenTry| { &mut m.previous_channel_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::channel::Channel>>(
                "channel",
                |m: &MsgChannelOpenTry| { &m.channel },
                |m: &mut MsgChannelOpenTry| { &mut m.channel },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "counterparty_version",
                |m: &MsgChannelOpenTry| { &m.counterparty_version },
                |m: &mut MsgChannelOpenTry| { &mut m.counterparty_version },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "proof_init",
                |m: &MsgChannelOpenTry| { &m.proof_init },
                |m: &mut MsgChannelOpenTry| { &mut m.proof_init },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::client::Height>>(
                "proof_height",
                |m: &MsgChannelOpenTry| { &m.proof_height },
                |m: &mut MsgChannelOpenTry| { &mut m.proof_height },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "signer",
                |m: &MsgChannelOpenTry| { &m.signer },
                |m: &mut MsgChannelOpenTry| { &mut m.signer },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MsgChannelOpenTry>(
                "MsgChannelOpenTry",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MsgChannelOpenTry {
        static instance: ::protobuf::rt::LazyV2<MsgChannelOpenTry> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MsgChannelOpenTry::new)
    }
}

impl ::protobuf::Clear for MsgChannelOpenTry {
    fn clear(&mut self) {
        self.port_id.clear();
        self.previous_channel_id.clear();
        self.channel.clear();
        self.counterparty_version.clear();
        self.proof_init.clear();
        self.proof_height.clear();
        self.signer.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MsgChannelOpenTry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgChannelOpenTry {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MsgChannelOpenTryResponse {
    // message fields
    pub version: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MsgChannelOpenTryResponse {
    fn default() -> &'a MsgChannelOpenTryResponse {
        <MsgChannelOpenTryResponse as ::protobuf::Message>::default_instance()
    }
}

impl MsgChannelOpenTryResponse {
    pub fn new() -> MsgChannelOpenTryResponse {
        ::std::default::Default::default()
    }

    // string version = 1;


    pub fn get_version(&self) -> &str {
        &self.version
    }
    pub fn clear_version(&mut self) {
        self.version.clear();
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: ::std::string::String) {
        self.version = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version(&mut self) -> &mut ::std::string::String {
        &mut self.version
    }

    // Take field
    pub fn take_version(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.version, ::std::string::String::new())
    }
}

impl ::protobuf::Message for MsgChannelOpenTryResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.version)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.version.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.version);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.version.is_empty() {
            os.write_string(1, &self.version)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MsgChannelOpenTryResponse {
        MsgChannelOpenTryResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "version",
                |m: &MsgChannelOpenTryResponse| { &m.version },
                |m: &mut MsgChannelOpenTryResponse| { &mut m.version },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MsgChannelOpenTryResponse>(
                "MsgChannelOpenTryResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MsgChannelOpenTryResponse {
        static instance: ::protobuf::rt::LazyV2<MsgChannelOpenTryResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MsgChannelOpenTryResponse::new)
    }
}

impl ::protobuf::Clear for MsgChannelOpenTryResponse {
    fn clear(&mut self) {
        self.version.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MsgChannelOpenTryResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgChannelOpenTryResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MsgChannelOpenAck {
    // message fields
    pub port_id: ::std::string::String,
    pub channel_id: ::std::string::String,
    pub counterparty_channel_id: ::std::string::String,
    pub counterparty_version: ::std::string::String,
    pub proof_try: ::std::vec::Vec<u8>,
    pub proof_height: ::protobuf::SingularPtrField<super::client::Height>,
    pub signer: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MsgChannelOpenAck {
    fn default() -> &'a MsgChannelOpenAck {
        <MsgChannelOpenAck as ::protobuf::Message>::default_instance()
    }
}

impl MsgChannelOpenAck {
    pub fn new() -> MsgChannelOpenAck {
        ::std::default::Default::default()
    }

    // string port_id = 1;


    pub fn get_port_id(&self) -> &str {
        &self.port_id
    }
    pub fn clear_port_id(&mut self) {
        self.port_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_port_id(&mut self, v: ::std::string::String) {
        self.port_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_port_id(&mut self) -> &mut ::std::string::String {
        &mut self.port_id
    }

    // Take field
    pub fn take_port_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.port_id, ::std::string::String::new())
    }

    // string channel_id = 2;


    pub fn get_channel_id(&self) -> &str {
        &self.channel_id
    }
    pub fn clear_channel_id(&mut self) {
        self.channel_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_channel_id(&mut self, v: ::std::string::String) {
        self.channel_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_channel_id(&mut self) -> &mut ::std::string::String {
        &mut self.channel_id
    }

    // Take field
    pub fn take_channel_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.channel_id, ::std::string::String::new())
    }

    // string counterparty_channel_id = 3;


    pub fn get_counterparty_channel_id(&self) -> &str {
        &self.counterparty_channel_id
    }
    pub fn clear_counterparty_channel_id(&mut self) {
        self.counterparty_channel_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_counterparty_channel_id(&mut self, v: ::std::string::String) {
        self.counterparty_channel_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_counterparty_channel_id(&mut self) -> &mut ::std::string::String {
        &mut self.counterparty_channel_id
    }

    // Take field
    pub fn take_counterparty_channel_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.counterparty_channel_id, ::std::string::String::new())
    }

    // string counterparty_version = 4;


    pub fn get_counterparty_version(&self) -> &str {
        &self.counterparty_version
    }
    pub fn clear_counterparty_version(&mut self) {
        self.counterparty_version.clear();
    }

    // Param is passed by value, moved
    pub fn set_counterparty_version(&mut self, v: ::std::string::String) {
        self.counterparty_version = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_counterparty_version(&mut self) -> &mut ::std::string::String {
        &mut self.counterparty_version
    }

    // Take field
    pub fn take_counterparty_version(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.counterparty_version, ::std::string::String::new())
    }

    // bytes proof_try = 5;


    pub fn get_proof_try(&self) -> &[u8] {
        &self.proof_try
    }
    pub fn clear_proof_try(&mut self) {
        self.proof_try.clear();
    }

    // Param is passed by value, moved
    pub fn set_proof_try(&mut self, v: ::std::vec::Vec<u8>) {
        self.proof_try = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_proof_try(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.proof_try
    }

    // Take field
    pub fn take_proof_try(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.proof_try, ::std::vec::Vec::new())
    }

    // .ibc.core.client.v1.Height proof_height = 6;


    pub fn get_proof_height(&self) -> &super::client::Height {
        self.proof_height.as_ref().unwrap_or_else(|| <super::client::Height as ::protobuf::Message>::default_instance())
    }
    pub fn clear_proof_height(&mut self) {
        self.proof_height.clear();
    }

    pub fn has_proof_height(&self) -> bool {
        self.proof_height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_proof_height(&mut self, v: super::client::Height) {
        self.proof_height = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_proof_height(&mut self) -> &mut super::client::Height {
        if self.proof_height.is_none() {
            self.proof_height.set_default();
        }
        self.proof_height.as_mut().unwrap()
    }

    // Take field
    pub fn take_proof_height(&mut self) -> super::client::Height {
        self.proof_height.take().unwrap_or_else(|| super::client::Height::new())
    }

    // string signer = 7;


    pub fn get_signer(&self) -> &str {
        &self.signer
    }
    pub fn clear_signer(&mut self) {
        self.signer.clear();
    }

    // Param is passed by value, moved
    pub fn set_signer(&mut self, v: ::std::string::String) {
        self.signer = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signer(&mut self) -> &mut ::std::string::String {
        &mut self.signer
    }

    // Take field
    pub fn take_signer(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.signer, ::std::string::String::new())
    }
}

impl ::protobuf::Message for MsgChannelOpenAck {
    fn is_initialized(&self) -> bool {
        for v in &self.proof_height {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.port_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.channel_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.counterparty_channel_id)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.counterparty_version)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.proof_try)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.proof_height)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.signer)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.port_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.port_id);
        }
        if !self.channel_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.channel_id);
        }
        if !self.counterparty_channel_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.counterparty_channel_id);
        }
        if !self.counterparty_version.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.counterparty_version);
        }
        if !self.proof_try.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.proof_try);
        }
        if let Some(ref v) = self.proof_height.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.signer.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.signer);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.port_id.is_empty() {
            os.write_string(1, &self.port_id)?;
        }
        if !self.channel_id.is_empty() {
            os.write_string(2, &self.channel_id)?;
        }
        if !self.counterparty_channel_id.is_empty() {
            os.write_string(3, &self.counterparty_channel_id)?;
        }
        if !self.counterparty_version.is_empty() {
            os.write_string(4, &self.counterparty_version)?;
        }
        if !self.proof_try.is_empty() {
            os.write_bytes(5, &self.proof_try)?;
        }
        if let Some(ref v) = self.proof_height.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.signer.is_empty() {
            os.write_string(7, &self.signer)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MsgChannelOpenAck {
        MsgChannelOpenAck::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "port_id",
                |m: &MsgChannelOpenAck| { &m.port_id },
                |m: &mut MsgChannelOpenAck| { &mut m.port_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "channel_id",
                |m: &MsgChannelOpenAck| { &m.channel_id },
                |m: &mut MsgChannelOpenAck| { &mut m.channel_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "counterparty_channel_id",
                |m: &MsgChannelOpenAck| { &m.counterparty_channel_id },
                |m: &mut MsgChannelOpenAck| { &mut m.counterparty_channel_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "counterparty_version",
                |m: &MsgChannelOpenAck| { &m.counterparty_version },
                |m: &mut MsgChannelOpenAck| { &mut m.counterparty_version },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "proof_try",
                |m: &MsgChannelOpenAck| { &m.proof_try },
                |m: &mut MsgChannelOpenAck| { &mut m.proof_try },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::client::Height>>(
                "proof_height",
                |m: &MsgChannelOpenAck| { &m.proof_height },
                |m: &mut MsgChannelOpenAck| { &mut m.proof_height },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "signer",
                |m: &MsgChannelOpenAck| { &m.signer },
                |m: &mut MsgChannelOpenAck| { &mut m.signer },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MsgChannelOpenAck>(
                "MsgChannelOpenAck",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MsgChannelOpenAck {
        static instance: ::protobuf::rt::LazyV2<MsgChannelOpenAck> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MsgChannelOpenAck::new)
    }
}

impl ::protobuf::Clear for MsgChannelOpenAck {
    fn clear(&mut self) {
        self.port_id.clear();
        self.channel_id.clear();
        self.counterparty_channel_id.clear();
        self.counterparty_version.clear();
        self.proof_try.clear();
        self.proof_height.clear();
        self.signer.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MsgChannelOpenAck {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgChannelOpenAck {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MsgChannelOpenAckResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MsgChannelOpenAckResponse {
    fn default() -> &'a MsgChannelOpenAckResponse {
        <MsgChannelOpenAckResponse as ::protobuf::Message>::default_instance()
    }
}

impl MsgChannelOpenAckResponse {
    pub fn new() -> MsgChannelOpenAckResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for MsgChannelOpenAckResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MsgChannelOpenAckResponse {
        MsgChannelOpenAckResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MsgChannelOpenAckResponse>(
                "MsgChannelOpenAckResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MsgChannelOpenAckResponse {
        static instance: ::protobuf::rt::LazyV2<MsgChannelOpenAckResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MsgChannelOpenAckResponse::new)
    }
}

impl ::protobuf::Clear for MsgChannelOpenAckResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MsgChannelOpenAckResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgChannelOpenAckResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MsgChannelOpenConfirm {
    // message fields
    pub port_id: ::std::string::String,
    pub channel_id: ::std::string::String,
    pub proof_ack: ::std::vec::Vec<u8>,
    pub proof_height: ::protobuf::SingularPtrField<super::client::Height>,
    pub signer: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MsgChannelOpenConfirm {
    fn default() -> &'a MsgChannelOpenConfirm {
        <MsgChannelOpenConfirm as ::protobuf::Message>::default_instance()
    }
}

impl MsgChannelOpenConfirm {
    pub fn new() -> MsgChannelOpenConfirm {
        ::std::default::Default::default()
    }

    // string port_id = 1;


    pub fn get_port_id(&self) -> &str {
        &self.port_id
    }
    pub fn clear_port_id(&mut self) {
        self.port_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_port_id(&mut self, v: ::std::string::String) {
        self.port_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_port_id(&mut self) -> &mut ::std::string::String {
        &mut self.port_id
    }

    // Take field
    pub fn take_port_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.port_id, ::std::string::String::new())
    }

    // string channel_id = 2;


    pub fn get_channel_id(&self) -> &str {
        &self.channel_id
    }
    pub fn clear_channel_id(&mut self) {
        self.channel_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_channel_id(&mut self, v: ::std::string::String) {
        self.channel_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_channel_id(&mut self) -> &mut ::std::string::String {
        &mut self.channel_id
    }

    // Take field
    pub fn take_channel_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.channel_id, ::std::string::String::new())
    }

    // bytes proof_ack = 3;


    pub fn get_proof_ack(&self) -> &[u8] {
        &self.proof_ack
    }
    pub fn clear_proof_ack(&mut self) {
        self.proof_ack.clear();
    }

    // Param is passed by value, moved
    pub fn set_proof_ack(&mut self, v: ::std::vec::Vec<u8>) {
        self.proof_ack = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_proof_ack(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.proof_ack
    }

    // Take field
    pub fn take_proof_ack(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.proof_ack, ::std::vec::Vec::new())
    }

    // .ibc.core.client.v1.Height proof_height = 4;


    pub fn get_proof_height(&self) -> &super::client::Height {
        self.proof_height.as_ref().unwrap_or_else(|| <super::client::Height as ::protobuf::Message>::default_instance())
    }
    pub fn clear_proof_height(&mut self) {
        self.proof_height.clear();
    }

    pub fn has_proof_height(&self) -> bool {
        self.proof_height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_proof_height(&mut self, v: super::client::Height) {
        self.proof_height = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_proof_height(&mut self) -> &mut super::client::Height {
        if self.proof_height.is_none() {
            self.proof_height.set_default();
        }
        self.proof_height.as_mut().unwrap()
    }

    // Take field
    pub fn take_proof_height(&mut self) -> super::client::Height {
        self.proof_height.take().unwrap_or_else(|| super::client::Height::new())
    }

    // string signer = 5;


    pub fn get_signer(&self) -> &str {
        &self.signer
    }
    pub fn clear_signer(&mut self) {
        self.signer.clear();
    }

    // Param is passed by value, moved
    pub fn set_signer(&mut self, v: ::std::string::String) {
        self.signer = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signer(&mut self) -> &mut ::std::string::String {
        &mut self.signer
    }

    // Take field
    pub fn take_signer(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.signer, ::std::string::String::new())
    }
}

impl ::protobuf::Message for MsgChannelOpenConfirm {
    fn is_initialized(&self) -> bool {
        for v in &self.proof_height {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.port_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.channel_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.proof_ack)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.proof_height)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.signer)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.port_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.port_id);
        }
        if !self.channel_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.channel_id);
        }
        if !self.proof_ack.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.proof_ack);
        }
        if let Some(ref v) = self.proof_height.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.signer.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.signer);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.port_id.is_empty() {
            os.write_string(1, &self.port_id)?;
        }
        if !self.channel_id.is_empty() {
            os.write_string(2, &self.channel_id)?;
        }
        if !self.proof_ack.is_empty() {
            os.write_bytes(3, &self.proof_ack)?;
        }
        if let Some(ref v) = self.proof_height.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.signer.is_empty() {
            os.write_string(5, &self.signer)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MsgChannelOpenConfirm {
        MsgChannelOpenConfirm::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "port_id",
                |m: &MsgChannelOpenConfirm| { &m.port_id },
                |m: &mut MsgChannelOpenConfirm| { &mut m.port_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "channel_id",
                |m: &MsgChannelOpenConfirm| { &m.channel_id },
                |m: &mut MsgChannelOpenConfirm| { &mut m.channel_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "proof_ack",
                |m: &MsgChannelOpenConfirm| { &m.proof_ack },
                |m: &mut MsgChannelOpenConfirm| { &mut m.proof_ack },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::client::Height>>(
                "proof_height",
                |m: &MsgChannelOpenConfirm| { &m.proof_height },
                |m: &mut MsgChannelOpenConfirm| { &mut m.proof_height },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "signer",
                |m: &MsgChannelOpenConfirm| { &m.signer },
                |m: &mut MsgChannelOpenConfirm| { &mut m.signer },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MsgChannelOpenConfirm>(
                "MsgChannelOpenConfirm",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MsgChannelOpenConfirm {
        static instance: ::protobuf::rt::LazyV2<MsgChannelOpenConfirm> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MsgChannelOpenConfirm::new)
    }
}

impl ::protobuf::Clear for MsgChannelOpenConfirm {
    fn clear(&mut self) {
        self.port_id.clear();
        self.channel_id.clear();
        self.proof_ack.clear();
        self.proof_height.clear();
        self.signer.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MsgChannelOpenConfirm {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgChannelOpenConfirm {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MsgChannelOpenConfirmResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MsgChannelOpenConfirmResponse {
    fn default() -> &'a MsgChannelOpenConfirmResponse {
        <MsgChannelOpenConfirmResponse as ::protobuf::Message>::default_instance()
    }
}

impl MsgChannelOpenConfirmResponse {
    pub fn new() -> MsgChannelOpenConfirmResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for MsgChannelOpenConfirmResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MsgChannelOpenConfirmResponse {
        MsgChannelOpenConfirmResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MsgChannelOpenConfirmResponse>(
                "MsgChannelOpenConfirmResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MsgChannelOpenConfirmResponse {
        static instance: ::protobuf::rt::LazyV2<MsgChannelOpenConfirmResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MsgChannelOpenConfirmResponse::new)
    }
}

impl ::protobuf::Clear for MsgChannelOpenConfirmResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MsgChannelOpenConfirmResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgChannelOpenConfirmResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MsgChannelCloseInit {
    // message fields
    pub port_id: ::std::string::String,
    pub channel_id: ::std::string::String,
    pub signer: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MsgChannelCloseInit {
    fn default() -> &'a MsgChannelCloseInit {
        <MsgChannelCloseInit as ::protobuf::Message>::default_instance()
    }
}

impl MsgChannelCloseInit {
    pub fn new() -> MsgChannelCloseInit {
        ::std::default::Default::default()
    }

    // string port_id = 1;


    pub fn get_port_id(&self) -> &str {
        &self.port_id
    }
    pub fn clear_port_id(&mut self) {
        self.port_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_port_id(&mut self, v: ::std::string::String) {
        self.port_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_port_id(&mut self) -> &mut ::std::string::String {
        &mut self.port_id
    }

    // Take field
    pub fn take_port_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.port_id, ::std::string::String::new())
    }

    // string channel_id = 2;


    pub fn get_channel_id(&self) -> &str {
        &self.channel_id
    }
    pub fn clear_channel_id(&mut self) {
        self.channel_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_channel_id(&mut self, v: ::std::string::String) {
        self.channel_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_channel_id(&mut self) -> &mut ::std::string::String {
        &mut self.channel_id
    }

    // Take field
    pub fn take_channel_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.channel_id, ::std::string::String::new())
    }

    // string signer = 3;


    pub fn get_signer(&self) -> &str {
        &self.signer
    }
    pub fn clear_signer(&mut self) {
        self.signer.clear();
    }

    // Param is passed by value, moved
    pub fn set_signer(&mut self, v: ::std::string::String) {
        self.signer = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signer(&mut self) -> &mut ::std::string::String {
        &mut self.signer
    }

    // Take field
    pub fn take_signer(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.signer, ::std::string::String::new())
    }
}

impl ::protobuf::Message for MsgChannelCloseInit {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.port_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.channel_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.signer)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.port_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.port_id);
        }
        if !self.channel_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.channel_id);
        }
        if !self.signer.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.signer);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.port_id.is_empty() {
            os.write_string(1, &self.port_id)?;
        }
        if !self.channel_id.is_empty() {
            os.write_string(2, &self.channel_id)?;
        }
        if !self.signer.is_empty() {
            os.write_string(3, &self.signer)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MsgChannelCloseInit {
        MsgChannelCloseInit::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "port_id",
                |m: &MsgChannelCloseInit| { &m.port_id },
                |m: &mut MsgChannelCloseInit| { &mut m.port_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "channel_id",
                |m: &MsgChannelCloseInit| { &m.channel_id },
                |m: &mut MsgChannelCloseInit| { &mut m.channel_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "signer",
                |m: &MsgChannelCloseInit| { &m.signer },
                |m: &mut MsgChannelCloseInit| { &mut m.signer },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MsgChannelCloseInit>(
                "MsgChannelCloseInit",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MsgChannelCloseInit {
        static instance: ::protobuf::rt::LazyV2<MsgChannelCloseInit> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MsgChannelCloseInit::new)
    }
}

impl ::protobuf::Clear for MsgChannelCloseInit {
    fn clear(&mut self) {
        self.port_id.clear();
        self.channel_id.clear();
        self.signer.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MsgChannelCloseInit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgChannelCloseInit {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MsgChannelCloseInitResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MsgChannelCloseInitResponse {
    fn default() -> &'a MsgChannelCloseInitResponse {
        <MsgChannelCloseInitResponse as ::protobuf::Message>::default_instance()
    }
}

impl MsgChannelCloseInitResponse {
    pub fn new() -> MsgChannelCloseInitResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for MsgChannelCloseInitResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MsgChannelCloseInitResponse {
        MsgChannelCloseInitResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MsgChannelCloseInitResponse>(
                "MsgChannelCloseInitResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MsgChannelCloseInitResponse {
        static instance: ::protobuf::rt::LazyV2<MsgChannelCloseInitResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MsgChannelCloseInitResponse::new)
    }
}

impl ::protobuf::Clear for MsgChannelCloseInitResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MsgChannelCloseInitResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgChannelCloseInitResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MsgChannelCloseConfirm {
    // message fields
    pub port_id: ::std::string::String,
    pub channel_id: ::std::string::String,
    pub proof_init: ::std::vec::Vec<u8>,
    pub proof_height: ::protobuf::SingularPtrField<super::client::Height>,
    pub signer: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MsgChannelCloseConfirm {
    fn default() -> &'a MsgChannelCloseConfirm {
        <MsgChannelCloseConfirm as ::protobuf::Message>::default_instance()
    }
}

impl MsgChannelCloseConfirm {
    pub fn new() -> MsgChannelCloseConfirm {
        ::std::default::Default::default()
    }

    // string port_id = 1;


    pub fn get_port_id(&self) -> &str {
        &self.port_id
    }
    pub fn clear_port_id(&mut self) {
        self.port_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_port_id(&mut self, v: ::std::string::String) {
        self.port_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_port_id(&mut self) -> &mut ::std::string::String {
        &mut self.port_id
    }

    // Take field
    pub fn take_port_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.port_id, ::std::string::String::new())
    }

    // string channel_id = 2;


    pub fn get_channel_id(&self) -> &str {
        &self.channel_id
    }
    pub fn clear_channel_id(&mut self) {
        self.channel_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_channel_id(&mut self, v: ::std::string::String) {
        self.channel_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_channel_id(&mut self) -> &mut ::std::string::String {
        &mut self.channel_id
    }

    // Take field
    pub fn take_channel_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.channel_id, ::std::string::String::new())
    }

    // bytes proof_init = 3;


    pub fn get_proof_init(&self) -> &[u8] {
        &self.proof_init
    }
    pub fn clear_proof_init(&mut self) {
        self.proof_init.clear();
    }

    // Param is passed by value, moved
    pub fn set_proof_init(&mut self, v: ::std::vec::Vec<u8>) {
        self.proof_init = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_proof_init(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.proof_init
    }

    // Take field
    pub fn take_proof_init(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.proof_init, ::std::vec::Vec::new())
    }

    // .ibc.core.client.v1.Height proof_height = 4;


    pub fn get_proof_height(&self) -> &super::client::Height {
        self.proof_height.as_ref().unwrap_or_else(|| <super::client::Height as ::protobuf::Message>::default_instance())
    }
    pub fn clear_proof_height(&mut self) {
        self.proof_height.clear();
    }

    pub fn has_proof_height(&self) -> bool {
        self.proof_height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_proof_height(&mut self, v: super::client::Height) {
        self.proof_height = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_proof_height(&mut self) -> &mut super::client::Height {
        if self.proof_height.is_none() {
            self.proof_height.set_default();
        }
        self.proof_height.as_mut().unwrap()
    }

    // Take field
    pub fn take_proof_height(&mut self) -> super::client::Height {
        self.proof_height.take().unwrap_or_else(|| super::client::Height::new())
    }

    // string signer = 5;


    pub fn get_signer(&self) -> &str {
        &self.signer
    }
    pub fn clear_signer(&mut self) {
        self.signer.clear();
    }

    // Param is passed by value, moved
    pub fn set_signer(&mut self, v: ::std::string::String) {
        self.signer = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signer(&mut self) -> &mut ::std::string::String {
        &mut self.signer
    }

    // Take field
    pub fn take_signer(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.signer, ::std::string::String::new())
    }
}

impl ::protobuf::Message for MsgChannelCloseConfirm {
    fn is_initialized(&self) -> bool {
        for v in &self.proof_height {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.port_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.channel_id)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.proof_init)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.proof_height)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.signer)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.port_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.port_id);
        }
        if !self.channel_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.channel_id);
        }
        if !self.proof_init.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.proof_init);
        }
        if let Some(ref v) = self.proof_height.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.signer.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.signer);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.port_id.is_empty() {
            os.write_string(1, &self.port_id)?;
        }
        if !self.channel_id.is_empty() {
            os.write_string(2, &self.channel_id)?;
        }
        if !self.proof_init.is_empty() {
            os.write_bytes(3, &self.proof_init)?;
        }
        if let Some(ref v) = self.proof_height.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.signer.is_empty() {
            os.write_string(5, &self.signer)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MsgChannelCloseConfirm {
        MsgChannelCloseConfirm::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "port_id",
                |m: &MsgChannelCloseConfirm| { &m.port_id },
                |m: &mut MsgChannelCloseConfirm| { &mut m.port_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "channel_id",
                |m: &MsgChannelCloseConfirm| { &m.channel_id },
                |m: &mut MsgChannelCloseConfirm| { &mut m.channel_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "proof_init",
                |m: &MsgChannelCloseConfirm| { &m.proof_init },
                |m: &mut MsgChannelCloseConfirm| { &mut m.proof_init },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::client::Height>>(
                "proof_height",
                |m: &MsgChannelCloseConfirm| { &m.proof_height },
                |m: &mut MsgChannelCloseConfirm| { &mut m.proof_height },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "signer",
                |m: &MsgChannelCloseConfirm| { &m.signer },
                |m: &mut MsgChannelCloseConfirm| { &mut m.signer },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MsgChannelCloseConfirm>(
                "MsgChannelCloseConfirm",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MsgChannelCloseConfirm {
        static instance: ::protobuf::rt::LazyV2<MsgChannelCloseConfirm> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MsgChannelCloseConfirm::new)
    }
}

impl ::protobuf::Clear for MsgChannelCloseConfirm {
    fn clear(&mut self) {
        self.port_id.clear();
        self.channel_id.clear();
        self.proof_init.clear();
        self.proof_height.clear();
        self.signer.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MsgChannelCloseConfirm {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgChannelCloseConfirm {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MsgChannelCloseConfirmResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MsgChannelCloseConfirmResponse {
    fn default() -> &'a MsgChannelCloseConfirmResponse {
        <MsgChannelCloseConfirmResponse as ::protobuf::Message>::default_instance()
    }
}

impl MsgChannelCloseConfirmResponse {
    pub fn new() -> MsgChannelCloseConfirmResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for MsgChannelCloseConfirmResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MsgChannelCloseConfirmResponse {
        MsgChannelCloseConfirmResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MsgChannelCloseConfirmResponse>(
                "MsgChannelCloseConfirmResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MsgChannelCloseConfirmResponse {
        static instance: ::protobuf::rt::LazyV2<MsgChannelCloseConfirmResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MsgChannelCloseConfirmResponse::new)
    }
}

impl ::protobuf::Clear for MsgChannelCloseConfirmResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MsgChannelCloseConfirmResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgChannelCloseConfirmResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MsgRecvPacket {
    // message fields
    pub packet: ::protobuf::SingularPtrField<super::channel::Packet>,
    pub proof_commitment: ::std::vec::Vec<u8>,
    pub proof_height: ::protobuf::SingularPtrField<super::client::Height>,
    pub signer: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MsgRecvPacket {
    fn default() -> &'a MsgRecvPacket {
        <MsgRecvPacket as ::protobuf::Message>::default_instance()
    }
}

impl MsgRecvPacket {
    pub fn new() -> MsgRecvPacket {
        ::std::default::Default::default()
    }

    // .ibc.core.channel.v1.Packet packet = 1;


    pub fn get_packet(&self) -> &super::channel::Packet {
        self.packet.as_ref().unwrap_or_else(|| <super::channel::Packet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_packet(&mut self) {
        self.packet.clear();
    }

    pub fn has_packet(&self) -> bool {
        self.packet.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packet(&mut self, v: super::channel::Packet) {
        self.packet = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_packet(&mut self) -> &mut super::channel::Packet {
        if self.packet.is_none() {
            self.packet.set_default();
        }
        self.packet.as_mut().unwrap()
    }

    // Take field
    pub fn take_packet(&mut self) -> super::channel::Packet {
        self.packet.take().unwrap_or_else(|| super::channel::Packet::new())
    }

    // bytes proof_commitment = 2;


    pub fn get_proof_commitment(&self) -> &[u8] {
        &self.proof_commitment
    }
    pub fn clear_proof_commitment(&mut self) {
        self.proof_commitment.clear();
    }

    // Param is passed by value, moved
    pub fn set_proof_commitment(&mut self, v: ::std::vec::Vec<u8>) {
        self.proof_commitment = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_proof_commitment(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.proof_commitment
    }

    // Take field
    pub fn take_proof_commitment(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.proof_commitment, ::std::vec::Vec::new())
    }

    // .ibc.core.client.v1.Height proof_height = 3;


    pub fn get_proof_height(&self) -> &super::client::Height {
        self.proof_height.as_ref().unwrap_or_else(|| <super::client::Height as ::protobuf::Message>::default_instance())
    }
    pub fn clear_proof_height(&mut self) {
        self.proof_height.clear();
    }

    pub fn has_proof_height(&self) -> bool {
        self.proof_height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_proof_height(&mut self, v: super::client::Height) {
        self.proof_height = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_proof_height(&mut self) -> &mut super::client::Height {
        if self.proof_height.is_none() {
            self.proof_height.set_default();
        }
        self.proof_height.as_mut().unwrap()
    }

    // Take field
    pub fn take_proof_height(&mut self) -> super::client::Height {
        self.proof_height.take().unwrap_or_else(|| super::client::Height::new())
    }

    // string signer = 4;


    pub fn get_signer(&self) -> &str {
        &self.signer
    }
    pub fn clear_signer(&mut self) {
        self.signer.clear();
    }

    // Param is passed by value, moved
    pub fn set_signer(&mut self, v: ::std::string::String) {
        self.signer = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signer(&mut self) -> &mut ::std::string::String {
        &mut self.signer
    }

    // Take field
    pub fn take_signer(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.signer, ::std::string::String::new())
    }
}

impl ::protobuf::Message for MsgRecvPacket {
    fn is_initialized(&self) -> bool {
        for v in &self.packet {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.proof_height {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.packet)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.proof_commitment)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.proof_height)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.signer)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.packet.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.proof_commitment.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.proof_commitment);
        }
        if let Some(ref v) = self.proof_height.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.signer.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.signer);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.packet.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.proof_commitment.is_empty() {
            os.write_bytes(2, &self.proof_commitment)?;
        }
        if let Some(ref v) = self.proof_height.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.signer.is_empty() {
            os.write_string(4, &self.signer)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MsgRecvPacket {
        MsgRecvPacket::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::channel::Packet>>(
                "packet",
                |m: &MsgRecvPacket| { &m.packet },
                |m: &mut MsgRecvPacket| { &mut m.packet },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "proof_commitment",
                |m: &MsgRecvPacket| { &m.proof_commitment },
                |m: &mut MsgRecvPacket| { &mut m.proof_commitment },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::client::Height>>(
                "proof_height",
                |m: &MsgRecvPacket| { &m.proof_height },
                |m: &mut MsgRecvPacket| { &mut m.proof_height },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "signer",
                |m: &MsgRecvPacket| { &m.signer },
                |m: &mut MsgRecvPacket| { &mut m.signer },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MsgRecvPacket>(
                "MsgRecvPacket",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MsgRecvPacket {
        static instance: ::protobuf::rt::LazyV2<MsgRecvPacket> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MsgRecvPacket::new)
    }
}

impl ::protobuf::Clear for MsgRecvPacket {
    fn clear(&mut self) {
        self.packet.clear();
        self.proof_commitment.clear();
        self.proof_height.clear();
        self.signer.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MsgRecvPacket {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgRecvPacket {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MsgRecvPacketResponse {
    // message fields
    pub result: ResponseResultType,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MsgRecvPacketResponse {
    fn default() -> &'a MsgRecvPacketResponse {
        <MsgRecvPacketResponse as ::protobuf::Message>::default_instance()
    }
}

impl MsgRecvPacketResponse {
    pub fn new() -> MsgRecvPacketResponse {
        ::std::default::Default::default()
    }

    // .ibc.core.channel.v1.ResponseResultType result = 1;


    pub fn get_result(&self) -> ResponseResultType {
        self.result
    }
    pub fn clear_result(&mut self) {
        self.result = ResponseResultType::RESPONSE_RESULT_TYPE_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: ResponseResultType) {
        self.result = v;
    }
}

impl ::protobuf::Message for MsgRecvPacketResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.result, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.result != ResponseResultType::RESPONSE_RESULT_TYPE_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(1, self.result);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.result != ResponseResultType::RESPONSE_RESULT_TYPE_UNSPECIFIED {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.result))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MsgRecvPacketResponse {
        MsgRecvPacketResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ResponseResultType>>(
                "result",
                |m: &MsgRecvPacketResponse| { &m.result },
                |m: &mut MsgRecvPacketResponse| { &mut m.result },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MsgRecvPacketResponse>(
                "MsgRecvPacketResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MsgRecvPacketResponse {
        static instance: ::protobuf::rt::LazyV2<MsgRecvPacketResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MsgRecvPacketResponse::new)
    }
}

impl ::protobuf::Clear for MsgRecvPacketResponse {
    fn clear(&mut self) {
        self.result = ResponseResultType::RESPONSE_RESULT_TYPE_UNSPECIFIED;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MsgRecvPacketResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgRecvPacketResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MsgTimeout {
    // message fields
    pub packet: ::protobuf::SingularPtrField<super::channel::Packet>,
    pub proof_unreceived: ::std::vec::Vec<u8>,
    pub proof_height: ::protobuf::SingularPtrField<super::client::Height>,
    pub next_sequence_recv: u64,
    pub signer: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MsgTimeout {
    fn default() -> &'a MsgTimeout {
        <MsgTimeout as ::protobuf::Message>::default_instance()
    }
}

impl MsgTimeout {
    pub fn new() -> MsgTimeout {
        ::std::default::Default::default()
    }

    // .ibc.core.channel.v1.Packet packet = 1;


    pub fn get_packet(&self) -> &super::channel::Packet {
        self.packet.as_ref().unwrap_or_else(|| <super::channel::Packet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_packet(&mut self) {
        self.packet.clear();
    }

    pub fn has_packet(&self) -> bool {
        self.packet.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packet(&mut self, v: super::channel::Packet) {
        self.packet = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_packet(&mut self) -> &mut super::channel::Packet {
        if self.packet.is_none() {
            self.packet.set_default();
        }
        self.packet.as_mut().unwrap()
    }

    // Take field
    pub fn take_packet(&mut self) -> super::channel::Packet {
        self.packet.take().unwrap_or_else(|| super::channel::Packet::new())
    }

    // bytes proof_unreceived = 2;


    pub fn get_proof_unreceived(&self) -> &[u8] {
        &self.proof_unreceived
    }
    pub fn clear_proof_unreceived(&mut self) {
        self.proof_unreceived.clear();
    }

    // Param is passed by value, moved
    pub fn set_proof_unreceived(&mut self, v: ::std::vec::Vec<u8>) {
        self.proof_unreceived = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_proof_unreceived(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.proof_unreceived
    }

    // Take field
    pub fn take_proof_unreceived(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.proof_unreceived, ::std::vec::Vec::new())
    }

    // .ibc.core.client.v1.Height proof_height = 3;


    pub fn get_proof_height(&self) -> &super::client::Height {
        self.proof_height.as_ref().unwrap_or_else(|| <super::client::Height as ::protobuf::Message>::default_instance())
    }
    pub fn clear_proof_height(&mut self) {
        self.proof_height.clear();
    }

    pub fn has_proof_height(&self) -> bool {
        self.proof_height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_proof_height(&mut self, v: super::client::Height) {
        self.proof_height = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_proof_height(&mut self) -> &mut super::client::Height {
        if self.proof_height.is_none() {
            self.proof_height.set_default();
        }
        self.proof_height.as_mut().unwrap()
    }

    // Take field
    pub fn take_proof_height(&mut self) -> super::client::Height {
        self.proof_height.take().unwrap_or_else(|| super::client::Height::new())
    }

    // uint64 next_sequence_recv = 4;


    pub fn get_next_sequence_recv(&self) -> u64 {
        self.next_sequence_recv
    }
    pub fn clear_next_sequence_recv(&mut self) {
        self.next_sequence_recv = 0;
    }

    // Param is passed by value, moved
    pub fn set_next_sequence_recv(&mut self, v: u64) {
        self.next_sequence_recv = v;
    }

    // string signer = 5;


    pub fn get_signer(&self) -> &str {
        &self.signer
    }
    pub fn clear_signer(&mut self) {
        self.signer.clear();
    }

    // Param is passed by value, moved
    pub fn set_signer(&mut self, v: ::std::string::String) {
        self.signer = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signer(&mut self) -> &mut ::std::string::String {
        &mut self.signer
    }

    // Take field
    pub fn take_signer(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.signer, ::std::string::String::new())
    }
}

impl ::protobuf::Message for MsgTimeout {
    fn is_initialized(&self) -> bool {
        for v in &self.packet {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.proof_height {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.packet)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.proof_unreceived)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.proof_height)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.next_sequence_recv = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.signer)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.packet.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.proof_unreceived.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.proof_unreceived);
        }
        if let Some(ref v) = self.proof_height.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.next_sequence_recv != 0 {
            my_size += ::protobuf::rt::value_size(4, self.next_sequence_recv, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.signer.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.signer);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.packet.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.proof_unreceived.is_empty() {
            os.write_bytes(2, &self.proof_unreceived)?;
        }
        if let Some(ref v) = self.proof_height.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.next_sequence_recv != 0 {
            os.write_uint64(4, self.next_sequence_recv)?;
        }
        if !self.signer.is_empty() {
            os.write_string(5, &self.signer)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MsgTimeout {
        MsgTimeout::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::channel::Packet>>(
                "packet",
                |m: &MsgTimeout| { &m.packet },
                |m: &mut MsgTimeout| { &mut m.packet },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "proof_unreceived",
                |m: &MsgTimeout| { &m.proof_unreceived },
                |m: &mut MsgTimeout| { &mut m.proof_unreceived },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::client::Height>>(
                "proof_height",
                |m: &MsgTimeout| { &m.proof_height },
                |m: &mut MsgTimeout| { &mut m.proof_height },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "next_sequence_recv",
                |m: &MsgTimeout| { &m.next_sequence_recv },
                |m: &mut MsgTimeout| { &mut m.next_sequence_recv },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "signer",
                |m: &MsgTimeout| { &m.signer },
                |m: &mut MsgTimeout| { &mut m.signer },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MsgTimeout>(
                "MsgTimeout",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MsgTimeout {
        static instance: ::protobuf::rt::LazyV2<MsgTimeout> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MsgTimeout::new)
    }
}

impl ::protobuf::Clear for MsgTimeout {
    fn clear(&mut self) {
        self.packet.clear();
        self.proof_unreceived.clear();
        self.proof_height.clear();
        self.next_sequence_recv = 0;
        self.signer.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MsgTimeout {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgTimeout {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MsgTimeoutResponse {
    // message fields
    pub result: ResponseResultType,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MsgTimeoutResponse {
    fn default() -> &'a MsgTimeoutResponse {
        <MsgTimeoutResponse as ::protobuf::Message>::default_instance()
    }
}

impl MsgTimeoutResponse {
    pub fn new() -> MsgTimeoutResponse {
        ::std::default::Default::default()
    }

    // .ibc.core.channel.v1.ResponseResultType result = 1;


    pub fn get_result(&self) -> ResponseResultType {
        self.result
    }
    pub fn clear_result(&mut self) {
        self.result = ResponseResultType::RESPONSE_RESULT_TYPE_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: ResponseResultType) {
        self.result = v;
    }
}

impl ::protobuf::Message for MsgTimeoutResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.result, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.result != ResponseResultType::RESPONSE_RESULT_TYPE_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(1, self.result);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.result != ResponseResultType::RESPONSE_RESULT_TYPE_UNSPECIFIED {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.result))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MsgTimeoutResponse {
        MsgTimeoutResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ResponseResultType>>(
                "result",
                |m: &MsgTimeoutResponse| { &m.result },
                |m: &mut MsgTimeoutResponse| { &mut m.result },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MsgTimeoutResponse>(
                "MsgTimeoutResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MsgTimeoutResponse {
        static instance: ::protobuf::rt::LazyV2<MsgTimeoutResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MsgTimeoutResponse::new)
    }
}

impl ::protobuf::Clear for MsgTimeoutResponse {
    fn clear(&mut self) {
        self.result = ResponseResultType::RESPONSE_RESULT_TYPE_UNSPECIFIED;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MsgTimeoutResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgTimeoutResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MsgTimeoutOnClose {
    // message fields
    pub packet: ::protobuf::SingularPtrField<super::channel::Packet>,
    pub proof_unreceived: ::std::vec::Vec<u8>,
    pub proof_close: ::std::vec::Vec<u8>,
    pub proof_height: ::protobuf::SingularPtrField<super::client::Height>,
    pub next_sequence_recv: u64,
    pub signer: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MsgTimeoutOnClose {
    fn default() -> &'a MsgTimeoutOnClose {
        <MsgTimeoutOnClose as ::protobuf::Message>::default_instance()
    }
}

impl MsgTimeoutOnClose {
    pub fn new() -> MsgTimeoutOnClose {
        ::std::default::Default::default()
    }

    // .ibc.core.channel.v1.Packet packet = 1;


    pub fn get_packet(&self) -> &super::channel::Packet {
        self.packet.as_ref().unwrap_or_else(|| <super::channel::Packet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_packet(&mut self) {
        self.packet.clear();
    }

    pub fn has_packet(&self) -> bool {
        self.packet.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packet(&mut self, v: super::channel::Packet) {
        self.packet = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_packet(&mut self) -> &mut super::channel::Packet {
        if self.packet.is_none() {
            self.packet.set_default();
        }
        self.packet.as_mut().unwrap()
    }

    // Take field
    pub fn take_packet(&mut self) -> super::channel::Packet {
        self.packet.take().unwrap_or_else(|| super::channel::Packet::new())
    }

    // bytes proof_unreceived = 2;


    pub fn get_proof_unreceived(&self) -> &[u8] {
        &self.proof_unreceived
    }
    pub fn clear_proof_unreceived(&mut self) {
        self.proof_unreceived.clear();
    }

    // Param is passed by value, moved
    pub fn set_proof_unreceived(&mut self, v: ::std::vec::Vec<u8>) {
        self.proof_unreceived = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_proof_unreceived(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.proof_unreceived
    }

    // Take field
    pub fn take_proof_unreceived(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.proof_unreceived, ::std::vec::Vec::new())
    }

    // bytes proof_close = 3;


    pub fn get_proof_close(&self) -> &[u8] {
        &self.proof_close
    }
    pub fn clear_proof_close(&mut self) {
        self.proof_close.clear();
    }

    // Param is passed by value, moved
    pub fn set_proof_close(&mut self, v: ::std::vec::Vec<u8>) {
        self.proof_close = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_proof_close(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.proof_close
    }

    // Take field
    pub fn take_proof_close(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.proof_close, ::std::vec::Vec::new())
    }

    // .ibc.core.client.v1.Height proof_height = 4;


    pub fn get_proof_height(&self) -> &super::client::Height {
        self.proof_height.as_ref().unwrap_or_else(|| <super::client::Height as ::protobuf::Message>::default_instance())
    }
    pub fn clear_proof_height(&mut self) {
        self.proof_height.clear();
    }

    pub fn has_proof_height(&self) -> bool {
        self.proof_height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_proof_height(&mut self, v: super::client::Height) {
        self.proof_height = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_proof_height(&mut self) -> &mut super::client::Height {
        if self.proof_height.is_none() {
            self.proof_height.set_default();
        }
        self.proof_height.as_mut().unwrap()
    }

    // Take field
    pub fn take_proof_height(&mut self) -> super::client::Height {
        self.proof_height.take().unwrap_or_else(|| super::client::Height::new())
    }

    // uint64 next_sequence_recv = 5;


    pub fn get_next_sequence_recv(&self) -> u64 {
        self.next_sequence_recv
    }
    pub fn clear_next_sequence_recv(&mut self) {
        self.next_sequence_recv = 0;
    }

    // Param is passed by value, moved
    pub fn set_next_sequence_recv(&mut self, v: u64) {
        self.next_sequence_recv = v;
    }

    // string signer = 6;


    pub fn get_signer(&self) -> &str {
        &self.signer
    }
    pub fn clear_signer(&mut self) {
        self.signer.clear();
    }

    // Param is passed by value, moved
    pub fn set_signer(&mut self, v: ::std::string::String) {
        self.signer = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signer(&mut self) -> &mut ::std::string::String {
        &mut self.signer
    }

    // Take field
    pub fn take_signer(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.signer, ::std::string::String::new())
    }
}

impl ::protobuf::Message for MsgTimeoutOnClose {
    fn is_initialized(&self) -> bool {
        for v in &self.packet {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.proof_height {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.packet)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.proof_unreceived)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.proof_close)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.proof_height)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.next_sequence_recv = tmp;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.signer)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.packet.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.proof_unreceived.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.proof_unreceived);
        }
        if !self.proof_close.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.proof_close);
        }
        if let Some(ref v) = self.proof_height.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.next_sequence_recv != 0 {
            my_size += ::protobuf::rt::value_size(5, self.next_sequence_recv, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.signer.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.signer);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.packet.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.proof_unreceived.is_empty() {
            os.write_bytes(2, &self.proof_unreceived)?;
        }
        if !self.proof_close.is_empty() {
            os.write_bytes(3, &self.proof_close)?;
        }
        if let Some(ref v) = self.proof_height.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.next_sequence_recv != 0 {
            os.write_uint64(5, self.next_sequence_recv)?;
        }
        if !self.signer.is_empty() {
            os.write_string(6, &self.signer)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MsgTimeoutOnClose {
        MsgTimeoutOnClose::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::channel::Packet>>(
                "packet",
                |m: &MsgTimeoutOnClose| { &m.packet },
                |m: &mut MsgTimeoutOnClose| { &mut m.packet },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "proof_unreceived",
                |m: &MsgTimeoutOnClose| { &m.proof_unreceived },
                |m: &mut MsgTimeoutOnClose| { &mut m.proof_unreceived },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "proof_close",
                |m: &MsgTimeoutOnClose| { &m.proof_close },
                |m: &mut MsgTimeoutOnClose| { &mut m.proof_close },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::client::Height>>(
                "proof_height",
                |m: &MsgTimeoutOnClose| { &m.proof_height },
                |m: &mut MsgTimeoutOnClose| { &mut m.proof_height },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "next_sequence_recv",
                |m: &MsgTimeoutOnClose| { &m.next_sequence_recv },
                |m: &mut MsgTimeoutOnClose| { &mut m.next_sequence_recv },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "signer",
                |m: &MsgTimeoutOnClose| { &m.signer },
                |m: &mut MsgTimeoutOnClose| { &mut m.signer },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MsgTimeoutOnClose>(
                "MsgTimeoutOnClose",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MsgTimeoutOnClose {
        static instance: ::protobuf::rt::LazyV2<MsgTimeoutOnClose> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MsgTimeoutOnClose::new)
    }
}

impl ::protobuf::Clear for MsgTimeoutOnClose {
    fn clear(&mut self) {
        self.packet.clear();
        self.proof_unreceived.clear();
        self.proof_close.clear();
        self.proof_height.clear();
        self.next_sequence_recv = 0;
        self.signer.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MsgTimeoutOnClose {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgTimeoutOnClose {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MsgTimeoutOnCloseResponse {
    // message fields
    pub result: ResponseResultType,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MsgTimeoutOnCloseResponse {
    fn default() -> &'a MsgTimeoutOnCloseResponse {
        <MsgTimeoutOnCloseResponse as ::protobuf::Message>::default_instance()
    }
}

impl MsgTimeoutOnCloseResponse {
    pub fn new() -> MsgTimeoutOnCloseResponse {
        ::std::default::Default::default()
    }

    // .ibc.core.channel.v1.ResponseResultType result = 1;


    pub fn get_result(&self) -> ResponseResultType {
        self.result
    }
    pub fn clear_result(&mut self) {
        self.result = ResponseResultType::RESPONSE_RESULT_TYPE_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: ResponseResultType) {
        self.result = v;
    }
}

impl ::protobuf::Message for MsgTimeoutOnCloseResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.result, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.result != ResponseResultType::RESPONSE_RESULT_TYPE_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(1, self.result);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.result != ResponseResultType::RESPONSE_RESULT_TYPE_UNSPECIFIED {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.result))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MsgTimeoutOnCloseResponse {
        MsgTimeoutOnCloseResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ResponseResultType>>(
                "result",
                |m: &MsgTimeoutOnCloseResponse| { &m.result },
                |m: &mut MsgTimeoutOnCloseResponse| { &mut m.result },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MsgTimeoutOnCloseResponse>(
                "MsgTimeoutOnCloseResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MsgTimeoutOnCloseResponse {
        static instance: ::protobuf::rt::LazyV2<MsgTimeoutOnCloseResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MsgTimeoutOnCloseResponse::new)
    }
}

impl ::protobuf::Clear for MsgTimeoutOnCloseResponse {
    fn clear(&mut self) {
        self.result = ResponseResultType::RESPONSE_RESULT_TYPE_UNSPECIFIED;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MsgTimeoutOnCloseResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgTimeoutOnCloseResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MsgAcknowledgement {
    // message fields
    pub packet: ::protobuf::SingularPtrField<super::channel::Packet>,
    pub acknowledgement: ::std::vec::Vec<u8>,
    pub proof_acked: ::std::vec::Vec<u8>,
    pub proof_height: ::protobuf::SingularPtrField<super::client::Height>,
    pub signer: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MsgAcknowledgement {
    fn default() -> &'a MsgAcknowledgement {
        <MsgAcknowledgement as ::protobuf::Message>::default_instance()
    }
}

impl MsgAcknowledgement {
    pub fn new() -> MsgAcknowledgement {
        ::std::default::Default::default()
    }

    // .ibc.core.channel.v1.Packet packet = 1;


    pub fn get_packet(&self) -> &super::channel::Packet {
        self.packet.as_ref().unwrap_or_else(|| <super::channel::Packet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_packet(&mut self) {
        self.packet.clear();
    }

    pub fn has_packet(&self) -> bool {
        self.packet.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packet(&mut self, v: super::channel::Packet) {
        self.packet = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_packet(&mut self) -> &mut super::channel::Packet {
        if self.packet.is_none() {
            self.packet.set_default();
        }
        self.packet.as_mut().unwrap()
    }

    // Take field
    pub fn take_packet(&mut self) -> super::channel::Packet {
        self.packet.take().unwrap_or_else(|| super::channel::Packet::new())
    }

    // bytes acknowledgement = 2;


    pub fn get_acknowledgement(&self) -> &[u8] {
        &self.acknowledgement
    }
    pub fn clear_acknowledgement(&mut self) {
        self.acknowledgement.clear();
    }

    // Param is passed by value, moved
    pub fn set_acknowledgement(&mut self, v: ::std::vec::Vec<u8>) {
        self.acknowledgement = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_acknowledgement(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.acknowledgement
    }

    // Take field
    pub fn take_acknowledgement(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.acknowledgement, ::std::vec::Vec::new())
    }

    // bytes proof_acked = 3;


    pub fn get_proof_acked(&self) -> &[u8] {
        &self.proof_acked
    }
    pub fn clear_proof_acked(&mut self) {
        self.proof_acked.clear();
    }

    // Param is passed by value, moved
    pub fn set_proof_acked(&mut self, v: ::std::vec::Vec<u8>) {
        self.proof_acked = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_proof_acked(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.proof_acked
    }

    // Take field
    pub fn take_proof_acked(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.proof_acked, ::std::vec::Vec::new())
    }

    // .ibc.core.client.v1.Height proof_height = 4;


    pub fn get_proof_height(&self) -> &super::client::Height {
        self.proof_height.as_ref().unwrap_or_else(|| <super::client::Height as ::protobuf::Message>::default_instance())
    }
    pub fn clear_proof_height(&mut self) {
        self.proof_height.clear();
    }

    pub fn has_proof_height(&self) -> bool {
        self.proof_height.is_some()
    }

    // Param is passed by value, moved
    pub fn set_proof_height(&mut self, v: super::client::Height) {
        self.proof_height = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_proof_height(&mut self) -> &mut super::client::Height {
        if self.proof_height.is_none() {
            self.proof_height.set_default();
        }
        self.proof_height.as_mut().unwrap()
    }

    // Take field
    pub fn take_proof_height(&mut self) -> super::client::Height {
        self.proof_height.take().unwrap_or_else(|| super::client::Height::new())
    }

    // string signer = 5;


    pub fn get_signer(&self) -> &str {
        &self.signer
    }
    pub fn clear_signer(&mut self) {
        self.signer.clear();
    }

    // Param is passed by value, moved
    pub fn set_signer(&mut self, v: ::std::string::String) {
        self.signer = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signer(&mut self) -> &mut ::std::string::String {
        &mut self.signer
    }

    // Take field
    pub fn take_signer(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.signer, ::std::string::String::new())
    }
}

impl ::protobuf::Message for MsgAcknowledgement {
    fn is_initialized(&self) -> bool {
        for v in &self.packet {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.proof_height {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.packet)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.acknowledgement)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.proof_acked)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.proof_height)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.signer)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.packet.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.acknowledgement.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.acknowledgement);
        }
        if !self.proof_acked.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.proof_acked);
        }
        if let Some(ref v) = self.proof_height.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.signer.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.signer);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.packet.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.acknowledgement.is_empty() {
            os.write_bytes(2, &self.acknowledgement)?;
        }
        if !self.proof_acked.is_empty() {
            os.write_bytes(3, &self.proof_acked)?;
        }
        if let Some(ref v) = self.proof_height.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.signer.is_empty() {
            os.write_string(5, &self.signer)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MsgAcknowledgement {
        MsgAcknowledgement::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::channel::Packet>>(
                "packet",
                |m: &MsgAcknowledgement| { &m.packet },
                |m: &mut MsgAcknowledgement| { &mut m.packet },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "acknowledgement",
                |m: &MsgAcknowledgement| { &m.acknowledgement },
                |m: &mut MsgAcknowledgement| { &mut m.acknowledgement },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "proof_acked",
                |m: &MsgAcknowledgement| { &m.proof_acked },
                |m: &mut MsgAcknowledgement| { &mut m.proof_acked },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::client::Height>>(
                "proof_height",
                |m: &MsgAcknowledgement| { &m.proof_height },
                |m: &mut MsgAcknowledgement| { &mut m.proof_height },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "signer",
                |m: &MsgAcknowledgement| { &m.signer },
                |m: &mut MsgAcknowledgement| { &mut m.signer },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MsgAcknowledgement>(
                "MsgAcknowledgement",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MsgAcknowledgement {
        static instance: ::protobuf::rt::LazyV2<MsgAcknowledgement> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MsgAcknowledgement::new)
    }
}

impl ::protobuf::Clear for MsgAcknowledgement {
    fn clear(&mut self) {
        self.packet.clear();
        self.acknowledgement.clear();
        self.proof_acked.clear();
        self.proof_height.clear();
        self.signer.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MsgAcknowledgement {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgAcknowledgement {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MsgAcknowledgementResponse {
    // message fields
    pub result: ResponseResultType,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MsgAcknowledgementResponse {
    fn default() -> &'a MsgAcknowledgementResponse {
        <MsgAcknowledgementResponse as ::protobuf::Message>::default_instance()
    }
}

impl MsgAcknowledgementResponse {
    pub fn new() -> MsgAcknowledgementResponse {
        ::std::default::Default::default()
    }

    // .ibc.core.channel.v1.ResponseResultType result = 1;


    pub fn get_result(&self) -> ResponseResultType {
        self.result
    }
    pub fn clear_result(&mut self) {
        self.result = ResponseResultType::RESPONSE_RESULT_TYPE_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: ResponseResultType) {
        self.result = v;
    }
}

impl ::protobuf::Message for MsgAcknowledgementResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.result, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.result != ResponseResultType::RESPONSE_RESULT_TYPE_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(1, self.result);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.result != ResponseResultType::RESPONSE_RESULT_TYPE_UNSPECIFIED {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.result))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MsgAcknowledgementResponse {
        MsgAcknowledgementResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ResponseResultType>>(
                "result",
                |m: &MsgAcknowledgementResponse| { &m.result },
                |m: &mut MsgAcknowledgementResponse| { &mut m.result },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MsgAcknowledgementResponse>(
                "MsgAcknowledgementResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MsgAcknowledgementResponse {
        static instance: ::protobuf::rt::LazyV2<MsgAcknowledgementResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MsgAcknowledgementResponse::new)
    }
}

impl ::protobuf::Clear for MsgAcknowledgementResponse {
    fn clear(&mut self) {
        self.result = ResponseResultType::RESPONSE_RESULT_TYPE_UNSPECIFIED;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MsgAcknowledgementResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MsgAcknowledgementResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ResponseResultType {
    RESPONSE_RESULT_TYPE_UNSPECIFIED = 0,
    RESPONSE_RESULT_TYPE_NOOP = 1,
    RESPONSE_RESULT_TYPE_SUCCESS = 2,
}

impl ::protobuf::ProtobufEnum for ResponseResultType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ResponseResultType> {
        match value {
            0 => ::std::option::Option::Some(ResponseResultType::RESPONSE_RESULT_TYPE_UNSPECIFIED),
            1 => ::std::option::Option::Some(ResponseResultType::RESPONSE_RESULT_TYPE_NOOP),
            2 => ::std::option::Option::Some(ResponseResultType::RESPONSE_RESULT_TYPE_SUCCESS),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ResponseResultType] = &[
            ResponseResultType::RESPONSE_RESULT_TYPE_UNSPECIFIED,
            ResponseResultType::RESPONSE_RESULT_TYPE_NOOP,
            ResponseResultType::RESPONSE_RESULT_TYPE_SUCCESS,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ResponseResultType>("ResponseResultType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ResponseResultType {
}

impl ::std::default::Default for ResponseResultType {
    fn default() -> Self {
        ResponseResultType::RESPONSE_RESULT_TYPE_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for ResponseResultType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1cibc/core/channel/v1/tx.proto\x12\x13ibc.core.channel.v1\x1a\x14gog\
    oproto/gogo.proto\x1a\x1fibc/core/client/v1/client.proto\x1a!ibc/core/ch\
    annel/v1/channel.proto\"\xa1\x01\n\x12MsgChannelOpenInit\x12+\n\x07port_\
    id\x18\x01\x20\x01(\tR\x06portIdB\x12\xf2\xde\x1f\x0eyaml:\"port_id\"\
    \x12<\n\x07channel\x18\x02\x20\x01(\x0b2\x1c.ibc.core.channel.v1.Channel\
    R\x07channelB\x04\xc8\xde\x1f\0\x12\x16\n\x06signer\x18\x03\x20\x01(\tR\
    \x06signer:\x08\x88\xa0\x1f\0\xe8\xa0\x1f\0\"l\n\x1aMsgChannelOpenInitRe\
    sponse\x124\n\nchannel_id\x18\x01\x20\x01(\tR\tchannelIdB\x15\xf2\xde\
    \x1f\x11yaml:\"channel_id\"\x12\x18\n\x07version\x18\x02\x20\x01(\tR\x07\
    version\"\xd8\x03\n\x11MsgChannelOpenTry\x12+\n\x07port_id\x18\x01\x20\
    \x01(\tR\x06portIdB\x12\xf2\xde\x1f\x0eyaml:\"port_id\"\x12P\n\x13previo\
    us_channel_id\x18\x02\x20\x01(\tR\x11previousChannelIdB\x20\x18\x01\xf2\
    \xde\x1f\x1ayaml:\"previous_channel_id\"\x12<\n\x07channel\x18\x03\x20\
    \x01(\x0b2\x1c.ibc.core.channel.v1.ChannelR\x07channelB\x04\xc8\xde\x1f\
    \0\x12R\n\x14counterparty_version\x18\x04\x20\x01(\tR\x13counterpartyVer\
    sionB\x1f\xf2\xde\x1f\x1byaml:\"counterparty_version\"\x124\n\nproof_ini\
    t\x18\x05\x20\x01(\x0cR\tproofInitB\x15\xf2\xde\x1f\x11yaml:\"proof_init\
    \"\x12Z\n\x0cproof_height\x18\x06\x20\x01(\x0b2\x1a.ibc.core.client.v1.H\
    eightR\x0bproofHeightB\x1b\xf2\xde\x1f\x13yaml:\"proof_height\"\xc8\xde\
    \x1f\0\x12\x16\n\x06signer\x18\x07\x20\x01(\tR\x06signer:\x08\x88\xa0\
    \x1f\0\xe8\xa0\x1f\0\"5\n\x19MsgChannelOpenTryResponse\x12\x18\n\x07vers\
    ion\x18\x01\x20\x01(\tR\x07version\"\xd7\x03\n\x11MsgChannelOpenAck\x12+\
    \n\x07port_id\x18\x01\x20\x01(\tR\x06portIdB\x12\xf2\xde\x1f\x0eyaml:\"p\
    ort_id\"\x124\n\nchannel_id\x18\x02\x20\x01(\tR\tchannelIdB\x15\xf2\xde\
    \x1f\x11yaml:\"channel_id\"\x12Z\n\x17counterparty_channel_id\x18\x03\
    \x20\x01(\tR\x15counterpartyChannelIdB\"\xf2\xde\x1f\x1eyaml:\"counterpa\
    rty_channel_id\"\x12R\n\x14counterparty_version\x18\x04\x20\x01(\tR\x13c\
    ounterpartyVersionB\x1f\xf2\xde\x1f\x1byaml:\"counterparty_version\"\x12\
    1\n\tproof_try\x18\x05\x20\x01(\x0cR\x08proofTryB\x14\xf2\xde\x1f\x10yam\
    l:\"proof_try\"\x12Z\n\x0cproof_height\x18\x06\x20\x01(\x0b2\x1a.ibc.cor\
    e.client.v1.HeightR\x0bproofHeightB\x1b\xf2\xde\x1f\x13yaml:\"proof_heig\
    ht\"\xc8\xde\x1f\0\x12\x16\n\x06signer\x18\x07\x20\x01(\tR\x06signer:\
    \x08\x88\xa0\x1f\0\xe8\xa0\x1f\0\"\x1b\n\x19MsgChannelOpenAckResponse\"\
    \xab\x02\n\x15MsgChannelOpenConfirm\x12+\n\x07port_id\x18\x01\x20\x01(\t\
    R\x06portIdB\x12\xf2\xde\x1f\x0eyaml:\"port_id\"\x124\n\nchannel_id\x18\
    \x02\x20\x01(\tR\tchannelIdB\x15\xf2\xde\x1f\x11yaml:\"channel_id\"\x121\
    \n\tproof_ack\x18\x03\x20\x01(\x0cR\x08proofAckB\x14\xf2\xde\x1f\x10yaml\
    :\"proof_ack\"\x12Z\n\x0cproof_height\x18\x04\x20\x01(\x0b2\x1a.ibc.core\
    .client.v1.HeightR\x0bproofHeightB\x1b\xf2\xde\x1f\x13yaml:\"proof_heigh\
    t\"\xc8\xde\x1f\0\x12\x16\n\x06signer\x18\x05\x20\x01(\tR\x06signer:\x08\
    \x88\xa0\x1f\0\xe8\xa0\x1f\0\"\x1f\n\x1dMsgChannelOpenConfirmResponse\"\
    \x9a\x01\n\x13MsgChannelCloseInit\x12+\n\x07port_id\x18\x01\x20\x01(\tR\
    \x06portIdB\x12\xf2\xde\x1f\x0eyaml:\"port_id\"\x124\n\nchannel_id\x18\
    \x02\x20\x01(\tR\tchannelIdB\x15\xf2\xde\x1f\x11yaml:\"channel_id\"\x12\
    \x16\n\x06signer\x18\x03\x20\x01(\tR\x06signer:\x08\x88\xa0\x1f\0\xe8\
    \xa0\x1f\0\"\x1d\n\x1bMsgChannelCloseInitResponse\"\xaf\x02\n\x16MsgChan\
    nelCloseConfirm\x12+\n\x07port_id\x18\x01\x20\x01(\tR\x06portIdB\x12\xf2\
    \xde\x1f\x0eyaml:\"port_id\"\x124\n\nchannel_id\x18\x02\x20\x01(\tR\tcha\
    nnelIdB\x15\xf2\xde\x1f\x11yaml:\"channel_id\"\x124\n\nproof_init\x18\
    \x03\x20\x01(\x0cR\tproofInitB\x15\xf2\xde\x1f\x11yaml:\"proof_init\"\
    \x12Z\n\x0cproof_height\x18\x04\x20\x01(\x0b2\x1a.ibc.core.client.v1.Hei\
    ghtR\x0bproofHeightB\x1b\xf2\xde\x1f\x13yaml:\"proof_height\"\xc8\xde\
    \x1f\0\x12\x16\n\x06signer\x18\x05\x20\x01(\tR\x06signer:\x08\x88\xa0\
    \x1f\0\xe8\xa0\x1f\0\"\x20\n\x1eMsgChannelCloseConfirmResponse\"\x90\x02\
    \n\rMsgRecvPacket\x129\n\x06packet\x18\x01\x20\x01(\x0b2\x1b.ibc.core.ch\
    annel.v1.PacketR\x06packetB\x04\xc8\xde\x1f\0\x12F\n\x10proof_commitment\
    \x18\x02\x20\x01(\x0cR\x0fproofCommitmentB\x1b\xf2\xde\x1f\x17yaml:\"pro\
    of_commitment\"\x12Z\n\x0cproof_height\x18\x03\x20\x01(\x0b2\x1a.ibc.cor\
    e.client.v1.HeightR\x0bproofHeightB\x1b\xf2\xde\x1f\x13yaml:\"proof_heig\
    ht\"\xc8\xde\x1f\0\x12\x16\n\x06signer\x18\x04\x20\x01(\tR\x06signer:\
    \x08\x88\xa0\x1f\0\xe8\xa0\x1f\0\"^\n\x15MsgRecvPacketResponse\x12?\n\
    \x06result\x18\x01\x20\x01(\x0e2'.ibc.core.channel.v1.ResponseResultType\
    R\x06result:\x04\x88\xa0\x1f\0\"\xda\x02\n\nMsgTimeout\x129\n\x06packet\
    \x18\x01\x20\x01(\x0b2\x1b.ibc.core.channel.v1.PacketR\x06packetB\x04\
    \xc8\xde\x1f\0\x12F\n\x10proof_unreceived\x18\x02\x20\x01(\x0cR\x0fproof\
    UnreceivedB\x1b\xf2\xde\x1f\x17yaml:\"proof_unreceived\"\x12Z\n\x0cproof\
    _height\x18\x03\x20\x01(\x0b2\x1a.ibc.core.client.v1.HeightR\x0bproofHei\
    ghtB\x1b\xf2\xde\x1f\x13yaml:\"proof_height\"\xc8\xde\x1f\0\x12K\n\x12ne\
    xt_sequence_recv\x18\x04\x20\x01(\x04R\x10nextSequenceRecvB\x1d\xf2\xde\
    \x1f\x19yaml:\"next_sequence_recv\"\x12\x16\n\x06signer\x18\x05\x20\x01(\
    \tR\x06signer:\x08\x88\xa0\x1f\0\xe8\xa0\x1f\0\"[\n\x12MsgTimeoutRespons\
    e\x12?\n\x06result\x18\x01\x20\x01(\x0e2'.ibc.core.channel.v1.ResponseRe\
    sultTypeR\x06result:\x04\x88\xa0\x1f\0\"\x9a\x03\n\x11MsgTimeoutOnClose\
    \x129\n\x06packet\x18\x01\x20\x01(\x0b2\x1b.ibc.core.channel.v1.PacketR\
    \x06packetB\x04\xc8\xde\x1f\0\x12F\n\x10proof_unreceived\x18\x02\x20\x01\
    (\x0cR\x0fproofUnreceivedB\x1b\xf2\xde\x1f\x17yaml:\"proof_unreceived\"\
    \x127\n\x0bproof_close\x18\x03\x20\x01(\x0cR\nproofCloseB\x16\xf2\xde\
    \x1f\x12yaml:\"proof_close\"\x12Z\n\x0cproof_height\x18\x04\x20\x01(\x0b\
    2\x1a.ibc.core.client.v1.HeightR\x0bproofHeightB\x1b\xf2\xde\x1f\x13yaml\
    :\"proof_height\"\xc8\xde\x1f\0\x12K\n\x12next_sequence_recv\x18\x05\x20\
    \x01(\x04R\x10nextSequenceRecvB\x1d\xf2\xde\x1f\x19yaml:\"next_sequence_\
    recv\"\x12\x16\n\x06signer\x18\x06\x20\x01(\tR\x06signer:\x08\x88\xa0\
    \x1f\0\xe8\xa0\x1f\0\"b\n\x19MsgTimeoutOnCloseResponse\x12?\n\x06result\
    \x18\x01\x20\x01(\x0e2'.ibc.core.channel.v1.ResponseResultTypeR\x06resul\
    t:\x04\x88\xa0\x1f\0\"\xb0\x02\n\x12MsgAcknowledgement\x129\n\x06packet\
    \x18\x01\x20\x01(\x0b2\x1b.ibc.core.channel.v1.PacketR\x06packetB\x04\
    \xc8\xde\x1f\0\x12(\n\x0facknowledgement\x18\x02\x20\x01(\x0cR\x0facknow\
    ledgement\x127\n\x0bproof_acked\x18\x03\x20\x01(\x0cR\nproofAckedB\x16\
    \xf2\xde\x1f\x12yaml:\"proof_acked\"\x12Z\n\x0cproof_height\x18\x04\x20\
    \x01(\x0b2\x1a.ibc.core.client.v1.HeightR\x0bproofHeightB\x1b\xf2\xde\
    \x1f\x13yaml:\"proof_height\"\xc8\xde\x1f\0\x12\x16\n\x06signer\x18\x05\
    \x20\x01(\tR\x06signer:\x08\x88\xa0\x1f\0\xe8\xa0\x1f\0\"c\n\x1aMsgAckno\
    wledgementResponse\x12?\n\x06result\x18\x01\x20\x01(\x0e2'.ibc.core.chan\
    nel.v1.ResponseResultTypeR\x06result:\x04\x88\xa0\x1f\0*\xa9\x01\n\x12Re\
    sponseResultType\x125\n\x20RESPONSE_RESULT_TYPE_UNSPECIFIED\x10\0\x1a\
    \x0f\x8a\x9d\x20\x0bUNSPECIFIED\x12'\n\x19RESPONSE_RESULT_TYPE_NOOP\x10\
    \x01\x1a\x08\x8a\x9d\x20\x04NOOP\x12-\n\x1cRESPONSE_RESULT_TYPE_SUCCESS\
    \x10\x02\x1a\x0b\x8a\x9d\x20\x07SUCCESS\x1a\x04\x88\xa3\x1e\02\xaf\x08\n\
    \x03Msg\x12k\n\x0fChannelOpenInit\x12'.ibc.core.channel.v1.MsgChannelOpe\
    nInit\x1a/.ibc.core.channel.v1.MsgChannelOpenInitResponse\x12h\n\x0eChan\
    nelOpenTry\x12&.ibc.core.channel.v1.MsgChannelOpenTry\x1a..ibc.core.chan\
    nel.v1.MsgChannelOpenTryResponse\x12h\n\x0eChannelOpenAck\x12&.ibc.core.\
    channel.v1.MsgChannelOpenAck\x1a..ibc.core.channel.v1.MsgChannelOpenAckR\
    esponse\x12t\n\x12ChannelOpenConfirm\x12*.ibc.core.channel.v1.MsgChannel\
    OpenConfirm\x1a2.ibc.core.channel.v1.MsgChannelOpenConfirmResponse\x12n\
    \n\x10ChannelCloseInit\x12(.ibc.core.channel.v1.MsgChannelCloseInit\x1a0\
    .ibc.core.channel.v1.MsgChannelCloseInitResponse\x12w\n\x13ChannelCloseC\
    onfirm\x12+.ibc.core.channel.v1.MsgChannelCloseConfirm\x1a3.ibc.core.cha\
    nnel.v1.MsgChannelCloseConfirmResponse\x12\\\n\nRecvPacket\x12\".ibc.cor\
    e.channel.v1.MsgRecvPacket\x1a*.ibc.core.channel.v1.MsgRecvPacketRespons\
    e\x12S\n\x07Timeout\x12\x1f.ibc.core.channel.v1.MsgTimeout\x1a'.ibc.core\
    .channel.v1.MsgTimeoutResponse\x12h\n\x0eTimeoutOnClose\x12&.ibc.core.ch\
    annel.v1.MsgTimeoutOnClose\x1a..ibc.core.channel.v1.MsgTimeoutOnCloseRes\
    ponse\x12k\n\x0fAcknowledgement\x12'.ibc.core.channel.v1.MsgAcknowledgem\
    ent\x1a/.ibc.core.channel.v1.MsgAcknowledgementResponseB;Z9github.com/co\
    smos/ibc-go/v4/modules/core/04-channel/typesb\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
